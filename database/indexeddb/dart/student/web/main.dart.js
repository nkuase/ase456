// Generated by dart2js (, csp, intern-composite-values), the Dart to JavaScript compiler version: 3.8.1.
// The code supports the following hooks:
// dartPrint(message):
//    if this function is defined it is called instead of the Dart [print]
//    method.
//
// dartMainRunner(main, args):
//    if this function is defined, the Dart [main] method will not be invoked
//    directly. Instead, a closure that will invoke [main], and its arguments
//    [args] is passed to [dartMainRunner].
//
// dartDeferredLibraryLoader(uri, successCallback, errorCallback, loadId, loadPriority):
//    if this function is defined, it will be called when a deferred library
//    is loaded. It should load and eval the javascript of `uri`, and call
//    successCallback. If it fails to do so, it should call errorCallback with
//    an error. The loadId argument is the deferred import that resulted in
//    this uri being loaded. The loadPriority argument is an arbitrary argument
//    string forwarded from the 'dart2js:load-priority' pragma option.
// dartDeferredLibraryMultiLoader(uris, successCallback, errorCallback, loadId, loadPriority):
//    if this function is defined, it will be called when a deferred library
//    is loaded. It should load and eval the javascript of every URI in `uris`,
//    and call successCallback. If it fails to do so, it should call
//    errorCallback with an error. The loadId argument is the deferred import
//    that resulted in this uri being loaded. The loadPriority argument is an
//    arbitrary argument string forwarded from the 'dart2js:load-priority'
//    pragma option.
//
// dartCallInstrumentation(id, qualifiedName):
//    if this function is defined, it will be called at each entry of a
//    method or constructor. Used only when compiling programs with
//    --experiment-call-instrumentation.
(function dartProgram() {
  function copyProperties(from, to) {
    var keys = Object.keys(from);
    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];
      to[key] = from[key];
    }
  }
  function mixinPropertiesHard(from, to) {
    var keys = Object.keys(from);
    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];
      if (!to.hasOwnProperty(key)) {
        to[key] = from[key];
      }
    }
  }
  function mixinPropertiesEasy(from, to) {
    Object.assign(to, from);
  }
  var supportsDirectProtoAccess = function() {
    var cls = function() {
    };
    cls.prototype = {p: {}};
    var object = new cls();
    if (!(Object.getPrototypeOf(object) && Object.getPrototypeOf(object).p === cls.prototype.p))
      return false;
    try {
      if (typeof navigator != "undefined" && typeof navigator.userAgent == "string" && navigator.userAgent.indexOf("Chrome/") >= 0)
        return true;
      if (typeof version == "function" && version.length == 0) {
        var v = version();
        if (/^\d+\.\d+\.\d+\.\d+$/.test(v))
          return true;
      }
    } catch (_) {
    }
    return false;
  }();
  function inherit(cls, sup) {
    cls.prototype.constructor = cls;
    cls.prototype["$is" + cls.name] = cls;
    if (sup != null) {
      if (supportsDirectProtoAccess) {
        Object.setPrototypeOf(cls.prototype, sup.prototype);
        return;
      }
      var clsPrototype = Object.create(sup.prototype);
      copyProperties(cls.prototype, clsPrototype);
      cls.prototype = clsPrototype;
    }
  }
  function inheritMany(sup, classes) {
    for (var i = 0; i < classes.length; i++) {
      inherit(classes[i], sup);
    }
  }
  function mixinEasy(cls, mixin) {
    mixinPropertiesEasy(mixin.prototype, cls.prototype);
    cls.prototype.constructor = cls;
  }
  function mixinHard(cls, mixin) {
    mixinPropertiesHard(mixin.prototype, cls.prototype);
    cls.prototype.constructor = cls;
  }
  function lazy(holder, name, getterName, initializer) {
    var uninitializedSentinel = holder;
    holder[name] = uninitializedSentinel;
    holder[getterName] = function() {
      if (holder[name] === uninitializedSentinel) {
        holder[name] = initializer();
      }
      holder[getterName] = function() {
        return this[name];
      };
      return holder[name];
    };
  }
  function lazyFinal(holder, name, getterName, initializer) {
    var uninitializedSentinel = holder;
    holder[name] = uninitializedSentinel;
    holder[getterName] = function() {
      if (holder[name] === uninitializedSentinel) {
        var value = initializer();
        if (holder[name] !== uninitializedSentinel) {
          A.throwLateFieldADI(name);
        }
        holder[name] = value;
      }
      var finalValue = holder[name];
      holder[getterName] = function() {
        return finalValue;
      };
      return finalValue;
    };
  }
  function makeConstList(list) {
    list.$flags = 7;
    return list;
  }
  function convertToFastObject(properties) {
    function t() {
    }
    t.prototype = properties;
    new t();
    return properties;
  }
  function convertAllToFastObject(arrayOfObjects) {
    for (var i = 0; i < arrayOfObjects.length; ++i) {
      convertToFastObject(arrayOfObjects[i]);
    }
  }
  var functionCounter = 0;
  function instanceTearOffGetter(isIntercepted, parameters) {
    var cache = null;
    return isIntercepted ? function(receiver) {
      if (cache === null)
        cache = A.closureFromTearOff(parameters);
      return new cache(receiver, this);
    } : function() {
      if (cache === null)
        cache = A.closureFromTearOff(parameters);
      return new cache(this, null);
    };
  }
  function staticTearOffGetter(parameters) {
    var cache = null;
    return function() {
      if (cache === null)
        cache = A.closureFromTearOff(parameters).prototype;
      return cache;
    };
  }
  var typesOffset = 0;
  function tearOffParameters(container, isStatic, isIntercepted, requiredParameterCount, optionalParameterDefaultValues, callNames, funsOrNames, funType, applyIndex, needsDirectAccess) {
    if (typeof funType == "number") {
      funType += typesOffset;
    }
    return {co: container, iS: isStatic, iI: isIntercepted, rC: requiredParameterCount, dV: optionalParameterDefaultValues, cs: callNames, fs: funsOrNames, fT: funType, aI: applyIndex || 0, nDA: needsDirectAccess};
  }
  function installStaticTearOff(holder, getterName, requiredParameterCount, optionalParameterDefaultValues, callNames, funsOrNames, funType, applyIndex) {
    var parameters = tearOffParameters(holder, true, false, requiredParameterCount, optionalParameterDefaultValues, callNames, funsOrNames, funType, applyIndex, false);
    var getterFunction = staticTearOffGetter(parameters);
    holder[getterName] = getterFunction;
  }
  function installInstanceTearOff(prototype, getterName, isIntercepted, requiredParameterCount, optionalParameterDefaultValues, callNames, funsOrNames, funType, applyIndex, needsDirectAccess) {
    isIntercepted = !!isIntercepted;
    var parameters = tearOffParameters(prototype, false, isIntercepted, requiredParameterCount, optionalParameterDefaultValues, callNames, funsOrNames, funType, applyIndex, !!needsDirectAccess);
    var getterFunction = instanceTearOffGetter(isIntercepted, parameters);
    prototype[getterName] = getterFunction;
  }
  function setOrUpdateInterceptorsByTag(newTags) {
    var tags = init.interceptorsByTag;
    if (!tags) {
      init.interceptorsByTag = newTags;
      return;
    }
    copyProperties(newTags, tags);
  }
  function setOrUpdateLeafTags(newTags) {
    var tags = init.leafTags;
    if (!tags) {
      init.leafTags = newTags;
      return;
    }
    copyProperties(newTags, tags);
  }
  function updateTypes(newTypes) {
    var types = init.types;
    var length = types.length;
    types.push.apply(types, newTypes);
    return length;
  }
  function updateHolder(holder, newHolder) {
    copyProperties(newHolder, holder);
    return holder;
  }
  var hunkHelpers = function() {
    var mkInstance = function(isIntercepted, requiredParameterCount, optionalParameterDefaultValues, callNames, applyIndex) {
        return function(container, getterName, name, funType) {
          return installInstanceTearOff(container, getterName, isIntercepted, requiredParameterCount, optionalParameterDefaultValues, callNames, [name], funType, applyIndex, false);
        };
      },
      mkStatic = function(requiredParameterCount, optionalParameterDefaultValues, callNames, applyIndex) {
        return function(container, getterName, name, funType) {
          return installStaticTearOff(container, getterName, requiredParameterCount, optionalParameterDefaultValues, callNames, [name], funType, applyIndex);
        };
      };
    return {inherit: inherit, inheritMany: inheritMany, mixin: mixinEasy, mixinHard: mixinHard, installStaticTearOff: installStaticTearOff, installInstanceTearOff: installInstanceTearOff, _instance_0u: mkInstance(0, 0, null, ["call$0"], 0), _instance_1u: mkInstance(0, 1, null, ["call$1"], 0), _instance_2u: mkInstance(0, 2, null, ["call$2"], 0), _instance_0i: mkInstance(1, 0, null, ["call$0"], 0), _instance_1i: mkInstance(1, 1, null, ["call$1"], 0), _instance_2i: mkInstance(1, 2, null, ["call$2"], 0), _static_0: mkStatic(0, null, ["call$0"], 0), _static_1: mkStatic(1, null, ["call$1"], 0), _static_2: mkStatic(2, null, ["call$2"], 0), makeConstList: makeConstList, lazy: lazy, lazyFinal: lazyFinal, updateHolder: updateHolder, convertToFastObject: convertToFastObject, updateTypes: updateTypes, setOrUpdateInterceptorsByTag: setOrUpdateInterceptorsByTag, setOrUpdateLeafTags: setOrUpdateLeafTags};
  }();
  function initializeDeferredHunk(hunk) {
    typesOffset = init.types.length;
    hunk(hunkHelpers, init, holders, $);
  }
  var J = {
    makeDispatchRecord(interceptor, proto, extension, indexability) {
      return {i: interceptor, p: proto, e: extension, x: indexability};
    },
    getNativeInterceptor(object) {
      var proto, objectProto, $constructor, interceptor, t1,
        record = object[init.dispatchPropertyName];
      if (record == null)
        if ($.initNativeDispatchFlag == null) {
          A.initNativeDispatch();
          record = object[init.dispatchPropertyName];
        }
      if (record != null) {
        proto = record.p;
        if (false === proto)
          return record.i;
        if (true === proto)
          return object;
        objectProto = Object.getPrototypeOf(object);
        if (proto === objectProto)
          return record.i;
        if (record.e === objectProto)
          throw A.wrapException(A.UnimplementedError$("Return interceptor for " + A.S(proto(object, record))));
      }
      $constructor = object.constructor;
      if ($constructor == null)
        interceptor = null;
      else {
        t1 = $._JS_INTEROP_INTERCEPTOR_TAG;
        if (t1 == null)
          t1 = $._JS_INTEROP_INTERCEPTOR_TAG = init.getIsolateTag("_$dart_js");
        interceptor = $constructor[t1];
      }
      if (interceptor != null)
        return interceptor;
      interceptor = A.lookupAndCacheInterceptor(object);
      if (interceptor != null)
        return interceptor;
      if (typeof object == "function")
        return B.JavaScriptFunction_methods;
      proto = Object.getPrototypeOf(object);
      if (proto == null)
        return B.PlainJavaScriptObject_methods;
      if (proto === Object.prototype)
        return B.PlainJavaScriptObject_methods;
      if (typeof $constructor == "function") {
        t1 = $._JS_INTEROP_INTERCEPTOR_TAG;
        if (t1 == null)
          t1 = $._JS_INTEROP_INTERCEPTOR_TAG = init.getIsolateTag("_$dart_js");
        Object.defineProperty($constructor, t1, {value: B.UnknownJavaScriptObject_methods, enumerable: false, writable: true, configurable: true});
        return B.UnknownJavaScriptObject_methods;
      }
      return B.UnknownJavaScriptObject_methods;
    },
    JSArray_JSArray$fixed($length, $E) {
      if ($length < 0 || $length > 4294967295)
        throw A.wrapException(A.RangeError$range($length, 0, 4294967295, "length", null));
      return J.JSArray_JSArray$markFixed(new Array($length), $E);
    },
    JSArray_JSArray$growable($length, $E) {
      if ($length < 0)
        throw A.wrapException(A.ArgumentError$("Length must be a non-negative integer: " + $length, null));
      return A._setArrayType(new Array($length), $E._eval$1("JSArray<0>"));
    },
    JSArray_JSArray$allocateGrowable($length, $E) {
      if ($length < 0)
        throw A.wrapException(A.ArgumentError$("Length must be a non-negative integer: " + $length, null));
      return A._setArrayType(new Array($length), $E._eval$1("JSArray<0>"));
    },
    JSArray_JSArray$markFixed(allocation, $E) {
      var t1 = A._setArrayType(allocation, $E._eval$1("JSArray<0>"));
      t1.$flags = 1;
      return t1;
    },
    JSArray__compareAny(a, b) {
      var t1 = type$.Comparable_dynamic;
      return J.compareTo$1$ns(t1._as(a), t1._as(b));
    },
    JSString__isWhitespace(codeUnit) {
      if (codeUnit < 256)
        switch (codeUnit) {
          case 9:
          case 10:
          case 11:
          case 12:
          case 13:
          case 32:
          case 133:
          case 160:
            return true;
          default:
            return false;
        }
      switch (codeUnit) {
        case 5760:
        case 8192:
        case 8193:
        case 8194:
        case 8195:
        case 8196:
        case 8197:
        case 8198:
        case 8199:
        case 8200:
        case 8201:
        case 8202:
        case 8232:
        case 8233:
        case 8239:
        case 8287:
        case 12288:
        case 65279:
          return true;
        default:
          return false;
      }
    },
    JSString__skipLeadingWhitespace(string, index) {
      var t1, codeUnit;
      for (t1 = string.length; index < t1;) {
        codeUnit = string.charCodeAt(index);
        if (codeUnit !== 32 && codeUnit !== 13 && !J.JSString__isWhitespace(codeUnit))
          break;
        ++index;
      }
      return index;
    },
    JSString__skipTrailingWhitespace(string, index) {
      var t1, index0, codeUnit;
      for (t1 = string.length; index > 0; index = index0) {
        index0 = index - 1;
        if (!(index0 < t1))
          return A.ioore(string, index0);
        codeUnit = string.charCodeAt(index0);
        if (codeUnit !== 32 && codeUnit !== 13 && !J.JSString__isWhitespace(codeUnit))
          break;
      }
      return index;
    },
    getInterceptor$(receiver) {
      if (typeof receiver == "number") {
        if (Math.floor(receiver) == receiver)
          return J.JSInt.prototype;
        return J.JSNumNotInt.prototype;
      }
      if (typeof receiver == "string")
        return J.JSString.prototype;
      if (receiver == null)
        return J.JSNull.prototype;
      if (typeof receiver == "boolean")
        return J.JSBool.prototype;
      if (Array.isArray(receiver))
        return J.JSArray.prototype;
      if (typeof receiver != "object") {
        if (typeof receiver == "function")
          return J.JavaScriptFunction.prototype;
        if (typeof receiver == "symbol")
          return J.JavaScriptSymbol.prototype;
        if (typeof receiver == "bigint")
          return J.JavaScriptBigInt.prototype;
        return receiver;
      }
      if (receiver instanceof A.Object)
        return receiver;
      return J.getNativeInterceptor(receiver);
    },
    getInterceptor$asx(receiver) {
      if (typeof receiver == "string")
        return J.JSString.prototype;
      if (receiver == null)
        return receiver;
      if (Array.isArray(receiver))
        return J.JSArray.prototype;
      if (typeof receiver != "object") {
        if (typeof receiver == "function")
          return J.JavaScriptFunction.prototype;
        if (typeof receiver == "symbol")
          return J.JavaScriptSymbol.prototype;
        if (typeof receiver == "bigint")
          return J.JavaScriptBigInt.prototype;
        return receiver;
      }
      if (receiver instanceof A.Object)
        return receiver;
      return J.getNativeInterceptor(receiver);
    },
    getInterceptor$ax(receiver) {
      if (receiver == null)
        return receiver;
      if (Array.isArray(receiver))
        return J.JSArray.prototype;
      if (typeof receiver != "object") {
        if (typeof receiver == "function")
          return J.JavaScriptFunction.prototype;
        if (typeof receiver == "symbol")
          return J.JavaScriptSymbol.prototype;
        if (typeof receiver == "bigint")
          return J.JavaScriptBigInt.prototype;
        return receiver;
      }
      if (receiver instanceof A.Object)
        return receiver;
      return J.getNativeInterceptor(receiver);
    },
    getInterceptor$ns(receiver) {
      if (typeof receiver == "number")
        return J.JSNumber.prototype;
      if (typeof receiver == "string")
        return J.JSString.prototype;
      if (receiver == null)
        return receiver;
      if (!(receiver instanceof A.Object))
        return J.UnknownJavaScriptObject.prototype;
      return receiver;
    },
    get$first$ax(receiver) {
      return J.getInterceptor$ax(receiver).get$first(receiver);
    },
    get$hashCode$(receiver) {
      return J.getInterceptor$(receiver).get$hashCode(receiver);
    },
    get$isEmpty$asx(receiver) {
      return J.getInterceptor$asx(receiver).get$isEmpty(receiver);
    },
    get$isNotEmpty$asx(receiver) {
      return J.getInterceptor$asx(receiver).get$isNotEmpty(receiver);
    },
    get$iterator$ax(receiver) {
      return J.getInterceptor$ax(receiver).get$iterator(receiver);
    },
    get$length$asx(receiver) {
      return J.getInterceptor$asx(receiver).get$length(receiver);
    },
    get$runtimeType$(receiver) {
      return J.getInterceptor$(receiver).get$runtimeType(receiver);
    },
    $eq$(receiver, a0) {
      if (receiver == null)
        return a0 == null;
      if (typeof receiver != "object")
        return a0 != null && receiver === a0;
      return J.getInterceptor$(receiver).$eq(receiver, a0);
    },
    $index$asx(receiver, a0) {
      if (typeof a0 === "number")
        if (Array.isArray(receiver) || typeof receiver == "string" || A.isJsIndexable(receiver, receiver[init.dispatchPropertyName]))
          if (a0 >>> 0 === a0 && a0 < receiver.length)
            return receiver[a0];
      return J.getInterceptor$asx(receiver).$index(receiver, a0);
    },
    $indexSet$ax(receiver, a0, a1) {
      return J.getInterceptor$ax(receiver).$indexSet(receiver, a0, a1);
    },
    add$1$ax(receiver, a0) {
      return J.getInterceptor$ax(receiver).add$1(receiver, a0);
    },
    addAll$1$ax(receiver, a0) {
      return J.getInterceptor$ax(receiver).addAll$1(receiver, a0);
    },
    cast$1$0$ax(receiver, $T1) {
      return J.getInterceptor$ax(receiver).cast$1$0(receiver, $T1);
    },
    clear$0$ax(receiver) {
      return J.getInterceptor$ax(receiver).clear$0(receiver);
    },
    compareTo$1$ns(receiver, a0) {
      return J.getInterceptor$ns(receiver).compareTo$1(receiver, a0);
    },
    contains$1$asx(receiver, a0) {
      return J.getInterceptor$asx(receiver).contains$1(receiver, a0);
    },
    elementAt$1$ax(receiver, a0) {
      return J.getInterceptor$ax(receiver).elementAt$1(receiver, a0);
    },
    forEach$1$ax(receiver, a0) {
      return J.getInterceptor$ax(receiver).forEach$1(receiver, a0);
    },
    map$1$1$ax(receiver, a0, $T1) {
      return J.getInterceptor$ax(receiver).map$1$1(receiver, a0, $T1);
    },
    skip$1$ax(receiver, a0) {
      return J.getInterceptor$ax(receiver).skip$1(receiver, a0);
    },
    take$1$ax(receiver, a0) {
      return J.getInterceptor$ax(receiver).take$1(receiver, a0);
    },
    toList$1$growable$ax(receiver, a0) {
      return J.getInterceptor$ax(receiver).toList$1$growable(receiver, a0);
    },
    toString$0$(receiver) {
      return J.getInterceptor$(receiver).toString$0(receiver);
    },
    Interceptor: function Interceptor() {
    },
    JSBool: function JSBool() {
    },
    JSNull: function JSNull() {
    },
    JavaScriptObject: function JavaScriptObject() {
    },
    LegacyJavaScriptObject: function LegacyJavaScriptObject() {
    },
    PlainJavaScriptObject: function PlainJavaScriptObject() {
    },
    UnknownJavaScriptObject: function UnknownJavaScriptObject() {
    },
    JavaScriptFunction: function JavaScriptFunction() {
    },
    JavaScriptBigInt: function JavaScriptBigInt() {
    },
    JavaScriptSymbol: function JavaScriptSymbol() {
    },
    JSArray: function JSArray(t0) {
      this.$ti = t0;
    },
    JSUnmodifiableArray: function JSUnmodifiableArray(t0) {
      this.$ti = t0;
    },
    ArrayIterator: function ArrayIterator(t0, t1, t2) {
      var _ = this;
      _._iterable = t0;
      _._length = t1;
      _._index = 0;
      _._current = null;
      _.$ti = t2;
    },
    JSNumber: function JSNumber() {
    },
    JSInt: function JSInt() {
    },
    JSNumNotInt: function JSNumNotInt() {
    },
    JSString: function JSString() {
    }
  },
  A = {JS_CONST: function JS_CONST() {
    },
    CastIterable_CastIterable(source, $S, $T) {
      if (type$.EfficientLengthIterable_dynamic._is(source))
        return new A._EfficientLengthCastIterable(source, $S._eval$1("@<0>")._bind$1($T)._eval$1("_EfficientLengthCastIterable<1,2>"));
      return new A.CastIterable(source, $S._eval$1("@<0>")._bind$1($T)._eval$1("CastIterable<1,2>"));
    },
    LateError$fieldADI(fieldName) {
      return new A.LateError("Field '" + fieldName + "' has been assigned during initialization.");
    },
    LateError$fieldNI(fieldName) {
      return new A.LateError("Field '" + fieldName + "' has not been initialized.");
    },
    SystemHash_combine(hash, value) {
      hash = hash + value & 536870911;
      hash = hash + ((hash & 524287) << 10) & 536870911;
      return hash ^ hash >>> 6;
    },
    SystemHash_finish(hash) {
      hash = hash + ((hash & 67108863) << 3) & 536870911;
      hash ^= hash >>> 11;
      return hash + ((hash & 16383) << 15) & 536870911;
    },
    checkNotNullable(value, $name, $T) {
      return value;
    },
    isToStringVisiting(object) {
      var t1, i;
      for (t1 = $.toStringVisiting.length, i = 0; i < t1; ++i)
        if (object === $.toStringVisiting[i])
          return true;
      return false;
    },
    SubListIterable$(_iterable, _start, _endOrLength, $E) {
      A.RangeError_checkNotNegative(_start, "start");
      if (_endOrLength != null) {
        A.RangeError_checkNotNegative(_endOrLength, "end");
        if (_start > _endOrLength)
          A.throwExpression(A.RangeError$range(_start, 0, _endOrLength, "start", null));
      }
      return new A.SubListIterable(_iterable, _start, _endOrLength, $E._eval$1("SubListIterable<0>"));
    },
    MappedIterable_MappedIterable(iterable, $function, $S, $T) {
      if (type$.EfficientLengthIterable_dynamic._is(iterable))
        return new A.EfficientLengthMappedIterable(iterable, $function, $S._eval$1("@<0>")._bind$1($T)._eval$1("EfficientLengthMappedIterable<1,2>"));
      return new A.MappedIterable(iterable, $function, $S._eval$1("@<0>")._bind$1($T)._eval$1("MappedIterable<1,2>"));
    },
    TakeIterable_TakeIterable(iterable, takeCount, $E) {
      var _s9_ = "takeCount";
      A.ArgumentError_checkNotNull(takeCount, _s9_, type$.int);
      A.RangeError_checkNotNegative(takeCount, _s9_);
      if (type$.EfficientLengthIterable_dynamic._is(iterable))
        return new A.EfficientLengthTakeIterable(iterable, takeCount, $E._eval$1("EfficientLengthTakeIterable<0>"));
      return new A.TakeIterable(iterable, takeCount, $E._eval$1("TakeIterable<0>"));
    },
    SkipIterable_SkipIterable(iterable, count, $E) {
      var _s5_ = "count";
      if (type$.EfficientLengthIterable_dynamic._is(iterable)) {
        A.ArgumentError_checkNotNull(count, _s5_, type$.int);
        A.RangeError_checkNotNegative(count, _s5_);
        return new A.EfficientLengthSkipIterable(iterable, count, $E._eval$1("EfficientLengthSkipIterable<0>"));
      }
      A.ArgumentError_checkNotNull(count, _s5_, type$.int);
      A.RangeError_checkNotNegative(count, _s5_);
      return new A.SkipIterable(iterable, count, $E._eval$1("SkipIterable<0>"));
    },
    IndexedIterable_IndexedIterable(source, start, $T) {
      return new A.EfficientLengthIndexedIterable(source, start, $T._eval$1("EfficientLengthIndexedIterable<0>"));
    },
    IterableElementError_noElement() {
      return new A.StateError("No element");
    },
    _CastIterableBase: function _CastIterableBase() {
    },
    CastIterator: function CastIterator(t0, t1) {
      this._source = t0;
      this.$ti = t1;
    },
    CastIterable: function CastIterable(t0, t1) {
      this._source = t0;
      this.$ti = t1;
    },
    _EfficientLengthCastIterable: function _EfficientLengthCastIterable(t0, t1) {
      this._source = t0;
      this.$ti = t1;
    },
    _CastListBase: function _CastListBase() {
    },
    CastList: function CastList(t0, t1) {
      this._source = t0;
      this.$ti = t1;
    },
    CastSet: function CastSet(t0, t1, t2) {
      this._source = t0;
      this._emptySet = t1;
      this.$ti = t2;
    },
    CastMap: function CastMap(t0, t1) {
      this._source = t0;
      this.$ti = t1;
    },
    CastMap_forEach_closure: function CastMap_forEach_closure(t0, t1) {
      this.$this = t0;
      this.f = t1;
    },
    LateError: function LateError(t0) {
      this.__internal$_message = t0;
    },
    nullFuture_closure: function nullFuture_closure() {
    },
    SentinelValue: function SentinelValue() {
    },
    EfficientLengthIterable: function EfficientLengthIterable() {
    },
    ListIterable: function ListIterable() {
    },
    SubListIterable: function SubListIterable(t0, t1, t2, t3) {
      var _ = this;
      _.__internal$_iterable = t0;
      _._start = t1;
      _._endOrLength = t2;
      _.$ti = t3;
    },
    ListIterator: function ListIterator(t0, t1, t2) {
      var _ = this;
      _.__internal$_iterable = t0;
      _.__internal$_length = t1;
      _.__internal$_index = 0;
      _.__internal$_current = null;
      _.$ti = t2;
    },
    MappedIterable: function MappedIterable(t0, t1, t2) {
      this.__internal$_iterable = t0;
      this._f = t1;
      this.$ti = t2;
    },
    EfficientLengthMappedIterable: function EfficientLengthMappedIterable(t0, t1, t2) {
      this.__internal$_iterable = t0;
      this._f = t1;
      this.$ti = t2;
    },
    MappedIterator: function MappedIterator(t0, t1, t2) {
      var _ = this;
      _.__internal$_current = null;
      _._iterator = t0;
      _._f = t1;
      _.$ti = t2;
    },
    MappedListIterable: function MappedListIterable(t0, t1, t2) {
      this._source = t0;
      this._f = t1;
      this.$ti = t2;
    },
    WhereIterable: function WhereIterable(t0, t1, t2) {
      this.__internal$_iterable = t0;
      this._f = t1;
      this.$ti = t2;
    },
    WhereIterator: function WhereIterator(t0, t1, t2) {
      this._iterator = t0;
      this._f = t1;
      this.$ti = t2;
    },
    TakeIterable: function TakeIterable(t0, t1, t2) {
      this.__internal$_iterable = t0;
      this._takeCount = t1;
      this.$ti = t2;
    },
    EfficientLengthTakeIterable: function EfficientLengthTakeIterable(t0, t1, t2) {
      this.__internal$_iterable = t0;
      this._takeCount = t1;
      this.$ti = t2;
    },
    TakeIterator: function TakeIterator(t0, t1, t2) {
      this._iterator = t0;
      this._remaining = t1;
      this.$ti = t2;
    },
    SkipIterable: function SkipIterable(t0, t1, t2) {
      this.__internal$_iterable = t0;
      this._skipCount = t1;
      this.$ti = t2;
    },
    EfficientLengthSkipIterable: function EfficientLengthSkipIterable(t0, t1, t2) {
      this.__internal$_iterable = t0;
      this._skipCount = t1;
      this.$ti = t2;
    },
    SkipIterator: function SkipIterator(t0, t1, t2) {
      this._iterator = t0;
      this._skipCount = t1;
      this.$ti = t2;
    },
    EmptyIterable: function EmptyIterable(t0) {
      this.$ti = t0;
    },
    EmptyIterator: function EmptyIterator(t0) {
      this.$ti = t0;
    },
    IndexedIterable: function IndexedIterable(t0, t1, t2) {
      this._source = t0;
      this._start = t1;
      this.$ti = t2;
    },
    EfficientLengthIndexedIterable: function EfficientLengthIndexedIterable(t0, t1, t2) {
      this._source = t0;
      this._start = t1;
      this.$ti = t2;
    },
    IndexedIterator: function IndexedIterator(t0, t1, t2) {
      var _ = this;
      _._source = t0;
      _._start = t1;
      _.__internal$_index = -1;
      _.$ti = t2;
    },
    FixedLengthListMixin: function FixedLengthListMixin() {
    },
    __CastListBase__CastIterableBase_ListMixin: function __CastListBase__CastIterableBase_ListMixin() {
    },
    unminifyOrTag(rawClassName) {
      var preserved = init.mangledGlobalNames[rawClassName];
      if (preserved != null)
        return preserved;
      return rawClassName;
    },
    isJsIndexable(object, record) {
      var result;
      if (record != null) {
        result = record.x;
        if (result != null)
          return result;
      }
      return type$.JavaScriptIndexingBehavior_dynamic._is(object);
    },
    S(value) {
      var result;
      if (typeof value == "string")
        return value;
      if (typeof value == "number") {
        if (value !== 0)
          return "" + value;
      } else if (true === value)
        return "true";
      else if (false === value)
        return "false";
      else if (value == null)
        return "null";
      result = J.toString$0$(value);
      return result;
    },
    Primitives_objectHashCode(object) {
      var hash,
        property = $.Primitives__identityHashCodeProperty;
      if (property == null)
        property = $.Primitives__identityHashCodeProperty = Symbol("identityHashCode");
      hash = object[property];
      if (hash == null) {
        hash = Math.random() * 0x3fffffff | 0;
        object[property] = hash;
      }
      return hash;
    },
    Primitives_parseInt(source, radix) {
      var decimalMatch, maxCharCode, digitsPart, t1, i, _null = null,
        match = /^\s*[+-]?((0x[a-f0-9]+)|(\d+)|([a-z0-9]+))\s*$/i.exec(source);
      if (match == null)
        return _null;
      if (3 >= match.length)
        return A.ioore(match, 3);
      decimalMatch = match[3];
      if (radix == null) {
        if (decimalMatch != null)
          return parseInt(source, 10);
        if (match[2] != null)
          return parseInt(source, 16);
        return _null;
      }
      if (radix < 2 || radix > 36)
        throw A.wrapException(A.RangeError$range(radix, 2, 36, "radix", _null));
      if (radix === 10 && decimalMatch != null)
        return parseInt(source, 10);
      if (radix < 10 || decimalMatch == null) {
        maxCharCode = radix <= 10 ? 47 + radix : 86 + radix;
        digitsPart = match[1];
        for (t1 = digitsPart.length, i = 0; i < t1; ++i)
          if ((digitsPart.charCodeAt(i) | 32) > maxCharCode)
            return _null;
      }
      return parseInt(source, radix);
    },
    Primitives_objectTypeName(object) {
      var interceptor, dispatchName, $constructor, constructorName;
      if (object instanceof A.Object)
        return A._rtiToString(A.instanceType(object), null);
      interceptor = J.getInterceptor$(object);
      if (interceptor === B.Interceptor_methods || interceptor === B.JavaScriptObject_methods || type$.UnknownJavaScriptObject._is(object)) {
        dispatchName = B.C_JS_CONST(object);
        if (dispatchName !== "Object" && dispatchName !== "")
          return dispatchName;
        $constructor = object.constructor;
        if (typeof $constructor == "function") {
          constructorName = $constructor.name;
          if (typeof constructorName == "string" && constructorName !== "Object" && constructorName !== "")
            return constructorName;
        }
      }
      return A._rtiToString(A.instanceType(object), null);
    },
    Primitives_safeToString(object) {
      if (object == null || typeof object == "number" || A._isBool(object))
        return J.toString$0$(object);
      if (typeof object == "string")
        return JSON.stringify(object);
      if (object instanceof A.Closure)
        return object.toString$0(0);
      if (object instanceof A._Record)
        return object._toString$1(true);
      return "Instance of '" + A.Primitives_objectTypeName(object) + "'";
    },
    Primitives_dateNow() {
      return Date.now();
    },
    Primitives_initTicker() {
      var $window, performance;
      if ($.Primitives_timerFrequency !== 0)
        return;
      $.Primitives_timerFrequency = 1000;
      if (typeof window == "undefined")
        return;
      $window = window;
      if ($window == null)
        return;
      if (!!$window.dartUseDateNowForTicks)
        return;
      performance = $window.performance;
      if (performance == null)
        return;
      if (typeof performance.now != "function")
        return;
      $.Primitives_timerFrequency = 1000000;
      $.Primitives_timerTicks = new A.Primitives_initTicker_closure(performance);
    },
    Primitives__fromCharCodeApply(array) {
      var result, i, i0, chunkEnd,
        end = array.length;
      if (end <= 500)
        return String.fromCharCode.apply(null, array);
      for (result = "", i = 0; i < end; i = i0) {
        i0 = i + 500;
        chunkEnd = i0 < end ? i0 : end;
        result += String.fromCharCode.apply(null, array.slice(i, chunkEnd));
      }
      return result;
    },
    Primitives_stringFromCodePoints(codePoints) {
      var t1, _i, i,
        a = A._setArrayType([], type$.JSArray_int);
      for (t1 = codePoints.length, _i = 0; _i < codePoints.length; codePoints.length === t1 || (0, A.throwConcurrentModificationError)(codePoints), ++_i) {
        i = codePoints[_i];
        if (!A._isInt(i))
          throw A.wrapException(A.argumentErrorValue(i));
        if (i <= 65535)
          B.JSArray_methods.add$1(a, i);
        else if (i <= 1114111) {
          B.JSArray_methods.add$1(a, 55296 + (B.JSInt_methods._shrOtherPositive$1(i - 65536, 10) & 1023));
          B.JSArray_methods.add$1(a, 56320 + (i & 1023));
        } else
          throw A.wrapException(A.argumentErrorValue(i));
      }
      return A.Primitives__fromCharCodeApply(a);
    },
    Primitives_stringFromCharCodes(charCodes) {
      var t1, _i, i;
      for (t1 = charCodes.length, _i = 0; _i < t1; ++_i) {
        i = charCodes[_i];
        if (!A._isInt(i))
          throw A.wrapException(A.argumentErrorValue(i));
        if (i < 0)
          throw A.wrapException(A.argumentErrorValue(i));
        if (i > 65535)
          return A.Primitives_stringFromCodePoints(charCodes);
      }
      return A.Primitives__fromCharCodeApply(charCodes);
    },
    Primitives_stringFromNativeUint8List(charCodes, start, end) {
      var i, result, i0, chunkEnd;
      if (end <= 500 && start === 0 && end === charCodes.length)
        return String.fromCharCode.apply(null, charCodes);
      for (i = start, result = ""; i < end; i = i0) {
        i0 = i + 500;
        chunkEnd = i0 < end ? i0 : end;
        result += String.fromCharCode.apply(null, charCodes.subarray(i, chunkEnd));
      }
      return result;
    },
    Primitives_stringFromCharCode(charCode) {
      var bits;
      if (0 <= charCode) {
        if (charCode <= 65535)
          return String.fromCharCode(charCode);
        if (charCode <= 1114111) {
          bits = charCode - 65536;
          return String.fromCharCode((B.JSInt_methods._shrOtherPositive$1(bits, 10) | 55296) >>> 0, bits & 1023 | 56320);
        }
      }
      throw A.wrapException(A.RangeError$range(charCode, 0, 1114111, null, null));
    },
    Primitives_valueFromDecomposedDate(years, month, day, hours, minutes, seconds, milliseconds, microseconds, isUtc) {
      var remainder, value, t1,
        jsMonth = month - 1;
      if (0 <= years && years < 100) {
        years += 400;
        jsMonth -= 4800;
      }
      remainder = B.JSInt_methods.$mod(microseconds, 1000);
      milliseconds += B.JSInt_methods._tdivFast$1(microseconds - remainder, 1000);
      value = isUtc ? Date.UTC(years, jsMonth, day, hours, minutes, seconds, milliseconds) : new Date(years, jsMonth, day, hours, minutes, seconds, milliseconds).valueOf();
      t1 = true;
      if (!isNaN(value))
        if (!(value < -864e13))
          if (!(value > 864e13))
            t1 = value === 864e13 && remainder !== 0;
      if (t1)
        return null;
      return value;
    },
    Primitives_lazyAsJsDate(receiver) {
      if (receiver.date === void 0)
        receiver.date = new Date(receiver._core$_value);
      return receiver.date;
    },
    Primitives_getYear(receiver) {
      return receiver.isUtc ? A.Primitives_lazyAsJsDate(receiver).getUTCFullYear() + 0 : A.Primitives_lazyAsJsDate(receiver).getFullYear() + 0;
    },
    Primitives_getMonth(receiver) {
      return receiver.isUtc ? A.Primitives_lazyAsJsDate(receiver).getUTCMonth() + 1 : A.Primitives_lazyAsJsDate(receiver).getMonth() + 1;
    },
    Primitives_getDay(receiver) {
      return receiver.isUtc ? A.Primitives_lazyAsJsDate(receiver).getUTCDate() + 0 : A.Primitives_lazyAsJsDate(receiver).getDate() + 0;
    },
    Primitives_getHours(receiver) {
      return receiver.isUtc ? A.Primitives_lazyAsJsDate(receiver).getUTCHours() + 0 : A.Primitives_lazyAsJsDate(receiver).getHours() + 0;
    },
    Primitives_getMinutes(receiver) {
      return receiver.isUtc ? A.Primitives_lazyAsJsDate(receiver).getUTCMinutes() + 0 : A.Primitives_lazyAsJsDate(receiver).getMinutes() + 0;
    },
    Primitives_getSeconds(receiver) {
      return receiver.isUtc ? A.Primitives_lazyAsJsDate(receiver).getUTCSeconds() + 0 : A.Primitives_lazyAsJsDate(receiver).getSeconds() + 0;
    },
    Primitives_getMilliseconds(receiver) {
      return receiver.isUtc ? A.Primitives_lazyAsJsDate(receiver).getUTCMilliseconds() + 0 : A.Primitives_lazyAsJsDate(receiver).getMilliseconds() + 0;
    },
    Primitives_extractStackTrace(error) {
      var jsError = error.$thrownJsError;
      if (jsError == null)
        return null;
      return A.getTraceFromException(jsError);
    },
    Primitives_trySetStackTrace(error, stackTrace) {
      var jsError;
      if (error.$thrownJsError == null) {
        jsError = new Error();
        A.initializeExceptionWrapper(error, jsError);
        error.$thrownJsError = jsError;
        jsError.stack = stackTrace.toString$0(0);
      }
    },
    ioore(receiver, index) {
      if (receiver == null)
        J.get$length$asx(receiver);
      throw A.wrapException(A.diagnoseIndexError(receiver, index));
    },
    diagnoseIndexError(indexable, index) {
      var $length, _s5_ = "index";
      if (!A._isInt(index))
        return new A.ArgumentError(true, index, _s5_, null);
      $length = A._asInt(J.get$length$asx(indexable));
      if (index < 0 || index >= $length)
        return A.IndexError$withLength(index, $length, indexable, null, _s5_);
      return A.RangeError$value(index, _s5_);
    },
    argumentErrorValue(object) {
      return new A.ArgumentError(true, object, null, null);
    },
    wrapException(ex) {
      return A.initializeExceptionWrapper(ex, new Error());
    },
    initializeExceptionWrapper(ex, wrapper) {
      var t1;
      if (ex == null)
        ex = new A.TypeError();
      wrapper.dartException = ex;
      t1 = A.toStringWrapper;
      if ("defineProperty" in Object) {
        Object.defineProperty(wrapper, "message", {get: t1});
        wrapper.name = "";
      } else
        wrapper.toString = t1;
      return wrapper;
    },
    toStringWrapper() {
      return J.toString$0$(this.dartException);
    },
    throwExpression(ex, wrapper) {
      throw A.initializeExceptionWrapper(ex, wrapper == null ? new Error() : wrapper);
    },
    throwUnsupportedOperation(o, operation, verb) {
      var wrapper;
      if (operation == null)
        operation = 0;
      if (verb == null)
        verb = 0;
      wrapper = Error();
      A.throwExpression(A._diagnoseUnsupportedOperation(o, operation, verb), wrapper);
    },
    _diagnoseUnsupportedOperation(o, encodedOperation, encodedVerb) {
      var operation, table, tableLength, index, verb, object, flags, article, adjective;
      if (typeof encodedOperation == "string")
        operation = encodedOperation;
      else {
        table = "[]=;add;removeWhere;retainWhere;removeRange;setRange;setInt8;setInt16;setInt32;setUint8;setUint16;setUint32;setFloat32;setFloat64".split(";");
        tableLength = table.length;
        index = encodedOperation;
        if (index > tableLength) {
          encodedVerb = index / tableLength | 0;
          index %= tableLength;
        }
        operation = table[index];
      }
      verb = typeof encodedVerb == "string" ? encodedVerb : "modify;remove from;add to".split(";")[encodedVerb];
      object = type$.List_dynamic._is(o) ? "list" : "ByteData";
      flags = o.$flags | 0;
      article = "a ";
      if ((flags & 4) !== 0)
        adjective = "constant ";
      else if ((flags & 2) !== 0) {
        adjective = "unmodifiable ";
        article = "an ";
      } else
        adjective = (flags & 1) !== 0 ? "fixed-length " : "";
      return new A.UnsupportedError("'" + operation + "': Cannot " + verb + " " + article + adjective + object);
    },
    throwConcurrentModificationError(collection) {
      throw A.wrapException(A.ConcurrentModificationError$(collection));
    },
    TypeErrorDecoder_extractPattern(message) {
      var match, $arguments, argumentsExpr, expr, method, receiver;
      message = A.quoteStringForRegExp(message.replace(String({}), "$receiver$"));
      match = message.match(/\\\$[a-zA-Z]+\\\$/g);
      if (match == null)
        match = A._setArrayType([], type$.JSArray_String);
      $arguments = match.indexOf("\\$arguments\\$");
      argumentsExpr = match.indexOf("\\$argumentsExpr\\$");
      expr = match.indexOf("\\$expr\\$");
      method = match.indexOf("\\$method\\$");
      receiver = match.indexOf("\\$receiver\\$");
      return new A.TypeErrorDecoder(message.replace(new RegExp("\\\\\\$arguments\\\\\\$", "g"), "((?:x|[^x])*)").replace(new RegExp("\\\\\\$argumentsExpr\\\\\\$", "g"), "((?:x|[^x])*)").replace(new RegExp("\\\\\\$expr\\\\\\$", "g"), "((?:x|[^x])*)").replace(new RegExp("\\\\\\$method\\\\\\$", "g"), "((?:x|[^x])*)").replace(new RegExp("\\\\\\$receiver\\\\\\$", "g"), "((?:x|[^x])*)"), $arguments, argumentsExpr, expr, method, receiver);
    },
    TypeErrorDecoder_provokeCallErrorOn(expression) {
      return function($expr$) {
        var $argumentsExpr$ = "$arguments$";
        try {
          $expr$.$method$($argumentsExpr$);
        } catch (e) {
          return e.message;
        }
      }(expression);
    },
    TypeErrorDecoder_provokePropertyErrorOn(expression) {
      return function($expr$) {
        try {
          $expr$.$method$;
        } catch (e) {
          return e.message;
        }
      }(expression);
    },
    JsNoSuchMethodError$(_message, match) {
      var t1 = match == null,
        t2 = t1 ? null : match.method;
      return new A.JsNoSuchMethodError(_message, t2, t1 ? null : match.receiver);
    },
    unwrapException(ex) {
      var t1;
      if (ex == null)
        return new A.NullThrownFromJavaScriptException(ex);
      if (ex instanceof A.ExceptionAndStackTrace) {
        t1 = ex.dartException;
        return A.saveStackTrace(ex, t1 == null ? type$.Object._as(t1) : t1);
      }
      if (typeof ex !== "object")
        return ex;
      if ("dartException" in ex)
        return A.saveStackTrace(ex, ex.dartException);
      return A._unwrapNonDartException(ex);
    },
    saveStackTrace(ex, error) {
      if (type$.Error._is(error))
        if (error.$thrownJsError == null)
          error.$thrownJsError = ex;
      return error;
    },
    _unwrapNonDartException(ex) {
      var message, number, ieErrorCode, nsme, notClosure, nullCall, nullLiteralCall, undefCall, undefLiteralCall, nullProperty, undefProperty, undefLiteralProperty, match;
      if (!("message" in ex))
        return ex;
      message = ex.message;
      if ("number" in ex && typeof ex.number == "number") {
        number = ex.number;
        ieErrorCode = number & 65535;
        if ((B.JSInt_methods._shrOtherPositive$1(number, 16) & 8191) === 10)
          switch (ieErrorCode) {
            case 438:
              return A.saveStackTrace(ex, A.JsNoSuchMethodError$(A.S(message) + " (Error " + ieErrorCode + ")", null));
            case 445:
            case 5007:
              A.S(message);
              return A.saveStackTrace(ex, new A.NullError());
          }
      }
      if (ex instanceof TypeError) {
        nsme = $.$get$TypeErrorDecoder_noSuchMethodPattern();
        notClosure = $.$get$TypeErrorDecoder_notClosurePattern();
        nullCall = $.$get$TypeErrorDecoder_nullCallPattern();
        nullLiteralCall = $.$get$TypeErrorDecoder_nullLiteralCallPattern();
        undefCall = $.$get$TypeErrorDecoder_undefinedCallPattern();
        undefLiteralCall = $.$get$TypeErrorDecoder_undefinedLiteralCallPattern();
        nullProperty = $.$get$TypeErrorDecoder_nullPropertyPattern();
        $.$get$TypeErrorDecoder_nullLiteralPropertyPattern();
        undefProperty = $.$get$TypeErrorDecoder_undefinedPropertyPattern();
        undefLiteralProperty = $.$get$TypeErrorDecoder_undefinedLiteralPropertyPattern();
        match = nsme.matchTypeError$1(message);
        if (match != null)
          return A.saveStackTrace(ex, A.JsNoSuchMethodError$(A._asString(message), match));
        else {
          match = notClosure.matchTypeError$1(message);
          if (match != null) {
            match.method = "call";
            return A.saveStackTrace(ex, A.JsNoSuchMethodError$(A._asString(message), match));
          } else if (nullCall.matchTypeError$1(message) != null || nullLiteralCall.matchTypeError$1(message) != null || undefCall.matchTypeError$1(message) != null || undefLiteralCall.matchTypeError$1(message) != null || nullProperty.matchTypeError$1(message) != null || nullLiteralCall.matchTypeError$1(message) != null || undefProperty.matchTypeError$1(message) != null || undefLiteralProperty.matchTypeError$1(message) != null) {
            A._asString(message);
            return A.saveStackTrace(ex, new A.NullError());
          }
        }
        return A.saveStackTrace(ex, new A.UnknownJsTypeError(typeof message == "string" ? message : ""));
      }
      if (ex instanceof RangeError) {
        if (typeof message == "string" && message.indexOf("call stack") !== -1)
          return new A.StackOverflowError();
        message = function(ex) {
          try {
            return String(ex);
          } catch (e) {
          }
          return null;
        }(ex);
        return A.saveStackTrace(ex, new A.ArgumentError(false, null, null, typeof message == "string" ? message.replace(/^RangeError:\s*/, "") : message));
      }
      if (typeof InternalError == "function" && ex instanceof InternalError)
        if (typeof message == "string" && message === "too much recursion")
          return new A.StackOverflowError();
      return ex;
    },
    getTraceFromException(exception) {
      var trace;
      if (exception instanceof A.ExceptionAndStackTrace)
        return exception.stackTrace;
      if (exception == null)
        return new A._StackTrace(exception);
      trace = exception.$cachedTrace;
      if (trace != null)
        return trace;
      trace = new A._StackTrace(exception);
      if (typeof exception === "object")
        exception.$cachedTrace = trace;
      return trace;
    },
    objectHashCode(object) {
      if (object == null)
        return J.get$hashCode$(object);
      if (typeof object == "object")
        return A.Primitives_objectHashCode(object);
      return J.get$hashCode$(object);
    },
    fillLiteralMap(keyValuePairs, result) {
      var index, index0, index1,
        $length = keyValuePairs.length;
      for (index = 0; index < $length; index = index1) {
        index0 = index + 1;
        index1 = index0 + 1;
        result.$indexSet(0, keyValuePairs[index], keyValuePairs[index0]);
      }
      return result;
    },
    _invokeClosure(closure, numberOfArguments, arg1, arg2, arg3, arg4) {
      type$.Function._as(closure);
      switch (A._asInt(numberOfArguments)) {
        case 0:
          return closure.call$0();
        case 1:
          return closure.call$1(arg1);
        case 2:
          return closure.call$2(arg1, arg2);
        case 3:
          return closure.call$3(arg1, arg2, arg3);
        case 4:
          return closure.call$4(arg1, arg2, arg3, arg4);
      }
      throw A.wrapException(new A._Exception("Unsupported number of arguments for wrapped closure"));
    },
    convertDartClosureToJS(closure, arity) {
      var $function = closure.$identity;
      if (!!$function)
        return $function;
      $function = A.convertDartClosureToJSUncached(closure, arity);
      closure.$identity = $function;
      return $function;
    },
    convertDartClosureToJSUncached(closure, arity) {
      var entry;
      switch (arity) {
        case 0:
          entry = closure.call$0;
          break;
        case 1:
          entry = closure.call$1;
          break;
        case 2:
          entry = closure.call$2;
          break;
        case 3:
          entry = closure.call$3;
          break;
        case 4:
          entry = closure.call$4;
          break;
        default:
          entry = null;
      }
      if (entry != null)
        return entry.bind(closure);
      return function(closure, arity, invoke) {
        return function(a1, a2, a3, a4) {
          return invoke(closure, arity, a1, a2, a3, a4);
        };
      }(closure, arity, A._invokeClosure);
    },
    Closure_fromTearOff(parameters) {
      var $prototype, $constructor, t2, trampoline, applyTrampoline, i, stub, stub0, stubName, stubCallName,
        container = parameters.co,
        isStatic = parameters.iS,
        isIntercepted = parameters.iI,
        needsDirectAccess = parameters.nDA,
        applyTrampolineIndex = parameters.aI,
        funsOrNames = parameters.fs,
        callNames = parameters.cs,
        $name = funsOrNames[0],
        callName = callNames[0],
        $function = container[$name],
        t1 = parameters.fT;
      t1.toString;
      $prototype = isStatic ? Object.create(new A.StaticClosure().constructor.prototype) : Object.create(new A.BoundClosure(null, null).constructor.prototype);
      $prototype.$initialize = $prototype.constructor;
      $constructor = isStatic ? function static_tear_off() {
        this.$initialize();
      } : function tear_off(a, b) {
        this.$initialize(a, b);
      };
      $prototype.constructor = $constructor;
      $constructor.prototype = $prototype;
      $prototype.$_name = $name;
      $prototype.$_target = $function;
      t2 = !isStatic;
      if (t2)
        trampoline = A.Closure_forwardCallTo($name, $function, isIntercepted, needsDirectAccess);
      else {
        $prototype.$static_name = $name;
        trampoline = $function;
      }
      $prototype.$signature = A.Closure__computeSignatureFunction(t1, isStatic, isIntercepted);
      $prototype[callName] = trampoline;
      for (applyTrampoline = trampoline, i = 1; i < funsOrNames.length; ++i) {
        stub = funsOrNames[i];
        if (typeof stub == "string") {
          stub0 = container[stub];
          stubName = stub;
          stub = stub0;
        } else
          stubName = "";
        stubCallName = callNames[i];
        if (stubCallName != null) {
          if (t2)
            stub = A.Closure_forwardCallTo(stubName, stub, isIntercepted, needsDirectAccess);
          $prototype[stubCallName] = stub;
        }
        if (i === applyTrampolineIndex)
          applyTrampoline = stub;
      }
      $prototype["call*"] = applyTrampoline;
      $prototype.$requiredArgCount = parameters.rC;
      $prototype.$defaultValues = parameters.dV;
      return $constructor;
    },
    Closure__computeSignatureFunction(functionType, isStatic, isIntercepted) {
      if (typeof functionType == "number")
        return functionType;
      if (typeof functionType == "string") {
        if (isStatic)
          throw A.wrapException("Cannot compute signature for static tearoff.");
        return function(recipe, evalOnReceiver) {
          return function() {
            return evalOnReceiver(this, recipe);
          };
        }(functionType, A.BoundClosure_evalRecipe);
      }
      throw A.wrapException("Error in functionType of tearoff");
    },
    Closure_cspForwardCall(arity, needsDirectAccess, stubName, $function) {
      var getReceiver = A.BoundClosure_receiverOf;
      switch (needsDirectAccess ? -1 : arity) {
        case 0:
          return function(entry, receiverOf) {
            return function() {
              return receiverOf(this)[entry]();
            };
          }(stubName, getReceiver);
        case 1:
          return function(entry, receiverOf) {
            return function(a) {
              return receiverOf(this)[entry](a);
            };
          }(stubName, getReceiver);
        case 2:
          return function(entry, receiverOf) {
            return function(a, b) {
              return receiverOf(this)[entry](a, b);
            };
          }(stubName, getReceiver);
        case 3:
          return function(entry, receiverOf) {
            return function(a, b, c) {
              return receiverOf(this)[entry](a, b, c);
            };
          }(stubName, getReceiver);
        case 4:
          return function(entry, receiverOf) {
            return function(a, b, c, d) {
              return receiverOf(this)[entry](a, b, c, d);
            };
          }(stubName, getReceiver);
        case 5:
          return function(entry, receiverOf) {
            return function(a, b, c, d, e) {
              return receiverOf(this)[entry](a, b, c, d, e);
            };
          }(stubName, getReceiver);
        default:
          return function(f, receiverOf) {
            return function() {
              return f.apply(receiverOf(this), arguments);
            };
          }($function, getReceiver);
      }
    },
    Closure_forwardCallTo(stubName, $function, isIntercepted, needsDirectAccess) {
      if (isIntercepted)
        return A.Closure_forwardInterceptedCallTo(stubName, $function, needsDirectAccess);
      return A.Closure_cspForwardCall($function.length, needsDirectAccess, stubName, $function);
    },
    Closure_cspForwardInterceptedCall(arity, needsDirectAccess, stubName, $function) {
      var getReceiver = A.BoundClosure_receiverOf,
        getInterceptor = A.BoundClosure_interceptorOf;
      switch (needsDirectAccess ? -1 : arity) {
        case 0:
          throw A.wrapException(new A.RuntimeError("Intercepted function with no arguments."));
        case 1:
          return function(entry, interceptorOf, receiverOf) {
            return function() {
              return interceptorOf(this)[entry](receiverOf(this));
            };
          }(stubName, getInterceptor, getReceiver);
        case 2:
          return function(entry, interceptorOf, receiverOf) {
            return function(a) {
              return interceptorOf(this)[entry](receiverOf(this), a);
            };
          }(stubName, getInterceptor, getReceiver);
        case 3:
          return function(entry, interceptorOf, receiverOf) {
            return function(a, b) {
              return interceptorOf(this)[entry](receiverOf(this), a, b);
            };
          }(stubName, getInterceptor, getReceiver);
        case 4:
          return function(entry, interceptorOf, receiverOf) {
            return function(a, b, c) {
              return interceptorOf(this)[entry](receiverOf(this), a, b, c);
            };
          }(stubName, getInterceptor, getReceiver);
        case 5:
          return function(entry, interceptorOf, receiverOf) {
            return function(a, b, c, d) {
              return interceptorOf(this)[entry](receiverOf(this), a, b, c, d);
            };
          }(stubName, getInterceptor, getReceiver);
        case 6:
          return function(entry, interceptorOf, receiverOf) {
            return function(a, b, c, d, e) {
              return interceptorOf(this)[entry](receiverOf(this), a, b, c, d, e);
            };
          }(stubName, getInterceptor, getReceiver);
        default:
          return function(f, interceptorOf, receiverOf) {
            return function() {
              var a = [receiverOf(this)];
              Array.prototype.push.apply(a, arguments);
              return f.apply(interceptorOf(this), a);
            };
          }($function, getInterceptor, getReceiver);
      }
    },
    Closure_forwardInterceptedCallTo(stubName, $function, needsDirectAccess) {
      var arity, t1;
      if ($.BoundClosure__interceptorFieldNameCache == null)
        $.BoundClosure__interceptorFieldNameCache = A.BoundClosure__computeFieldNamed("interceptor");
      if ($.BoundClosure__receiverFieldNameCache == null)
        $.BoundClosure__receiverFieldNameCache = A.BoundClosure__computeFieldNamed("receiver");
      arity = $function.length;
      t1 = A.Closure_cspForwardInterceptedCall(arity, needsDirectAccess, stubName, $function);
      return t1;
    },
    closureFromTearOff(parameters) {
      return A.Closure_fromTearOff(parameters);
    },
    BoundClosure_evalRecipe(closure, recipe) {
      return A._Universe_evalInEnvironment(init.typeUniverse, A.instanceType(closure._receiver), recipe);
    },
    BoundClosure_receiverOf(closure) {
      return closure._receiver;
    },
    BoundClosure_interceptorOf(closure) {
      return closure._interceptor;
    },
    BoundClosure__computeFieldNamed(fieldName) {
      var names, i, $name,
        template = new A.BoundClosure("receiver", "interceptor"),
        t1 = Object.getOwnPropertyNames(template);
      t1.$flags = 1;
      names = t1;
      for (t1 = names.length, i = 0; i < t1; ++i) {
        $name = names[i];
        if (template[$name] === fieldName)
          return $name;
      }
      throw A.wrapException(A.ArgumentError$("Field name " + fieldName + " not found.", null));
    },
    getIsolateAffinityTag($name) {
      return init.getIsolateTag($name);
    },
    staticInteropGlobalContext() {
      return init.G;
    },
    defineProperty(obj, property, value) {
      Object.defineProperty(obj, property, {value: value, enumerable: false, writable: true, configurable: true});
    },
    lookupAndCacheInterceptor(obj) {
      var interceptor, interceptorClass, altTag, mark, t1,
        tag = A._asString($.getTagFunction.call$1(obj)),
        record = $.dispatchRecordsForInstanceTags[tag];
      if (record != null) {
        Object.defineProperty(obj, init.dispatchPropertyName, {value: record, enumerable: false, writable: true, configurable: true});
        return record.i;
      }
      interceptor = $.interceptorsForUncacheableTags[tag];
      if (interceptor != null)
        return interceptor;
      interceptorClass = init.interceptorsByTag[tag];
      if (interceptorClass == null) {
        altTag = A._asStringQ($.alternateTagFunction.call$2(obj, tag));
        if (altTag != null) {
          record = $.dispatchRecordsForInstanceTags[altTag];
          if (record != null) {
            Object.defineProperty(obj, init.dispatchPropertyName, {value: record, enumerable: false, writable: true, configurable: true});
            return record.i;
          }
          interceptor = $.interceptorsForUncacheableTags[altTag];
          if (interceptor != null)
            return interceptor;
          interceptorClass = init.interceptorsByTag[altTag];
          tag = altTag;
        }
      }
      if (interceptorClass == null)
        return null;
      interceptor = interceptorClass.prototype;
      mark = tag[0];
      if (mark === "!") {
        record = A.makeLeafDispatchRecord(interceptor);
        $.dispatchRecordsForInstanceTags[tag] = record;
        Object.defineProperty(obj, init.dispatchPropertyName, {value: record, enumerable: false, writable: true, configurable: true});
        return record.i;
      }
      if (mark === "~") {
        $.interceptorsForUncacheableTags[tag] = interceptor;
        return interceptor;
      }
      if (mark === "-") {
        t1 = A.makeLeafDispatchRecord(interceptor);
        Object.defineProperty(Object.getPrototypeOf(obj), init.dispatchPropertyName, {value: t1, enumerable: false, writable: true, configurable: true});
        return t1.i;
      }
      if (mark === "+")
        return A.patchInteriorProto(obj, interceptor);
      if (mark === "*")
        throw A.wrapException(A.UnimplementedError$(tag));
      if (init.leafTags[tag] === true) {
        t1 = A.makeLeafDispatchRecord(interceptor);
        Object.defineProperty(Object.getPrototypeOf(obj), init.dispatchPropertyName, {value: t1, enumerable: false, writable: true, configurable: true});
        return t1.i;
      } else
        return A.patchInteriorProto(obj, interceptor);
    },
    patchInteriorProto(obj, interceptor) {
      var proto = Object.getPrototypeOf(obj);
      Object.defineProperty(proto, init.dispatchPropertyName, {value: J.makeDispatchRecord(interceptor, proto, null, null), enumerable: false, writable: true, configurable: true});
      return interceptor;
    },
    makeLeafDispatchRecord(interceptor) {
      return J.makeDispatchRecord(interceptor, false, null, !!interceptor.$isJavaScriptIndexingBehavior);
    },
    makeDefaultDispatchRecord(tag, interceptorClass, proto) {
      var interceptor = interceptorClass.prototype;
      if (init.leafTags[tag] === true)
        return A.makeLeafDispatchRecord(interceptor);
      else
        return J.makeDispatchRecord(interceptor, proto, null, null);
    },
    initNativeDispatch() {
      if (true === $.initNativeDispatchFlag)
        return;
      $.initNativeDispatchFlag = true;
      A.initNativeDispatchContinue();
    },
    initNativeDispatchContinue() {
      var map, tags, fun, i, tag, proto, record, interceptorClass;
      $.dispatchRecordsForInstanceTags = Object.create(null);
      $.interceptorsForUncacheableTags = Object.create(null);
      A.initHooks();
      map = init.interceptorsByTag;
      tags = Object.getOwnPropertyNames(map);
      if (typeof window != "undefined") {
        window;
        fun = function() {
        };
        for (i = 0; i < tags.length; ++i) {
          tag = tags[i];
          proto = $.prototypeForTagFunction.call$1(tag);
          if (proto != null) {
            record = A.makeDefaultDispatchRecord(tag, map[tag], proto);
            if (record != null) {
              Object.defineProperty(proto, init.dispatchPropertyName, {value: record, enumerable: false, writable: true, configurable: true});
              fun.prototype = proto;
            }
          }
        }
      }
      for (i = 0; i < tags.length; ++i) {
        tag = tags[i];
        if (/^[A-Za-z_]/.test(tag)) {
          interceptorClass = map[tag];
          map["!" + tag] = interceptorClass;
          map["~" + tag] = interceptorClass;
          map["-" + tag] = interceptorClass;
          map["+" + tag] = interceptorClass;
          map["*" + tag] = interceptorClass;
        }
      }
    },
    initHooks() {
      var transformers, i, transformer, getTag, getUnknownTag, prototypeForTag,
        hooks = B.C_JS_CONST0();
      hooks = A.applyHooksTransformer(B.C_JS_CONST1, A.applyHooksTransformer(B.C_JS_CONST2, A.applyHooksTransformer(B.C_JS_CONST3, A.applyHooksTransformer(B.C_JS_CONST3, A.applyHooksTransformer(B.C_JS_CONST4, A.applyHooksTransformer(B.C_JS_CONST5, A.applyHooksTransformer(B.C_JS_CONST6(B.C_JS_CONST), hooks)))))));
      if (typeof dartNativeDispatchHooksTransformer != "undefined") {
        transformers = dartNativeDispatchHooksTransformer;
        if (typeof transformers == "function")
          transformers = [transformers];
        if (Array.isArray(transformers))
          for (i = 0; i < transformers.length; ++i) {
            transformer = transformers[i];
            if (typeof transformer == "function")
              hooks = transformer(hooks) || hooks;
          }
      }
      getTag = hooks.getTag;
      getUnknownTag = hooks.getUnknownTag;
      prototypeForTag = hooks.prototypeForTag;
      $.getTagFunction = new A.initHooks_closure(getTag);
      $.alternateTagFunction = new A.initHooks_closure0(getUnknownTag);
      $.prototypeForTagFunction = new A.initHooks_closure1(prototypeForTag);
    },
    applyHooksTransformer(transformer, hooks) {
      return transformer(hooks) || hooks;
    },
    createRecordTypePredicate(shape, fieldRtis) {
      var $length = fieldRtis.length,
        $function = init.rttc["" + $length + ";" + shape];
      if ($function == null)
        return null;
      if ($length === 0)
        return $function;
      if ($length === $function.length)
        return $function.apply(null, fieldRtis);
      return $function(fieldRtis);
    },
    JSSyntaxRegExp_makeNative(source, multiLine, caseSensitive, unicode, dotAll, extraFlags) {
      var m = multiLine ? "m" : "",
        i = caseSensitive ? "" : "i",
        u = unicode ? "u" : "",
        s = dotAll ? "s" : "",
        regexp = function(source, modifiers) {
          try {
            return new RegExp(source, modifiers);
          } catch (e) {
            return e;
          }
        }(source, m + i + u + s + extraFlags);
      if (regexp instanceof RegExp)
        return regexp;
      throw A.wrapException(A.FormatException$("Illegal RegExp pattern (" + String(regexp) + ")", source, null));
    },
    quoteStringForRegExp(string) {
      if (/[[\]{}()*+?.\\^$|]/.test(string))
        return string.replace(/[[\]{}()*+?.\\^$|]/g, "\\$&");
      return string;
    },
    _Record_2: function _Record_2(t0, t1) {
      this._0 = t0;
      this._1 = t1;
    },
    Primitives_initTicker_closure: function Primitives_initTicker_closure(t0) {
      this.performance = t0;
    },
    TypeErrorDecoder: function TypeErrorDecoder(t0, t1, t2, t3, t4, t5) {
      var _ = this;
      _._pattern = t0;
      _._arguments = t1;
      _._argumentsExpr = t2;
      _._expr = t3;
      _._method = t4;
      _._receiver = t5;
    },
    NullError: function NullError() {
    },
    JsNoSuchMethodError: function JsNoSuchMethodError(t0, t1, t2) {
      this.__js_helper$_message = t0;
      this._method = t1;
      this._receiver = t2;
    },
    UnknownJsTypeError: function UnknownJsTypeError(t0) {
      this.__js_helper$_message = t0;
    },
    NullThrownFromJavaScriptException: function NullThrownFromJavaScriptException(t0) {
      this._irritant = t0;
    },
    ExceptionAndStackTrace: function ExceptionAndStackTrace(t0, t1) {
      this.dartException = t0;
      this.stackTrace = t1;
    },
    _StackTrace: function _StackTrace(t0) {
      this._exception = t0;
      this._trace = null;
    },
    Closure: function Closure() {
    },
    Closure0Args: function Closure0Args() {
    },
    Closure2Args: function Closure2Args() {
    },
    TearOffClosure: function TearOffClosure() {
    },
    StaticClosure: function StaticClosure() {
    },
    BoundClosure: function BoundClosure(t0, t1) {
      this._receiver = t0;
      this._interceptor = t1;
    },
    RuntimeError: function RuntimeError(t0) {
      this.message = t0;
    },
    JsLinkedHashMap: function JsLinkedHashMap(t0) {
      var _ = this;
      _.__js_helper$_length = 0;
      _._last = _._first = _.__js_helper$_rest = _._nums = _._strings = null;
      _._modifications = 0;
      _.$ti = t0;
    },
    LinkedHashMapCell: function LinkedHashMapCell(t0, t1) {
      var _ = this;
      _.hashMapCellKey = t0;
      _.hashMapCellValue = t1;
      _._previous = _._next = null;
    },
    LinkedHashMapKeysIterable: function LinkedHashMapKeysIterable(t0, t1) {
      this._map = t0;
      this.$ti = t1;
    },
    LinkedHashMapKeyIterator: function LinkedHashMapKeyIterator(t0, t1, t2, t3) {
      var _ = this;
      _._map = t0;
      _._modifications = t1;
      _._cell = t2;
      _.__js_helper$_current = null;
      _.$ti = t3;
    },
    LinkedHashMapValuesIterable: function LinkedHashMapValuesIterable(t0, t1) {
      this._map = t0;
      this.$ti = t1;
    },
    LinkedHashMapValueIterator: function LinkedHashMapValueIterator(t0, t1, t2, t3) {
      var _ = this;
      _._map = t0;
      _._modifications = t1;
      _._cell = t2;
      _.__js_helper$_current = null;
      _.$ti = t3;
    },
    initHooks_closure: function initHooks_closure(t0) {
      this.getTag = t0;
    },
    initHooks_closure0: function initHooks_closure0(t0) {
      this.getUnknownTag = t0;
    },
    initHooks_closure1: function initHooks_closure1(t0) {
      this.prototypeForTag = t0;
    },
    _Record: function _Record() {
    },
    _Record2: function _Record2() {
    },
    JSSyntaxRegExp: function JSSyntaxRegExp(t0, t1) {
      var _ = this;
      _.pattern = t0;
      _._nativeRegExp = t1;
      _._hasCapturesCache = _._nativeAnchoredRegExp = _._nativeGlobalRegExp = null;
    },
    _MatchImplementation: function _MatchImplementation(t0) {
      this._match = t0;
    },
    throwLateFieldNI(fieldName) {
      throw A.initializeExceptionWrapper(A.LateError$fieldNI(fieldName), new Error());
    },
    throwLateFieldADI(fieldName) {
      throw A.initializeExceptionWrapper(A.LateError$fieldADI(fieldName), new Error());
    },
    _Cell$named(_name) {
      var t1 = new A._Cell(_name);
      return t1._value = t1;
    },
    _Cell: function _Cell(t0) {
      this._name = t0;
      this._value = null;
    },
    _ensureNativeList(list) {
      return list;
    },
    NativeInt8List__create1(arg) {
      return new Int8Array(arg);
    },
    NativeUint8List_NativeUint8List($length) {
      return new Uint8Array($length);
    },
    _checkValidIndex(index, list, $length) {
      if (index >>> 0 !== index || index >= $length)
        throw A.wrapException(A.diagnoseIndexError(list, index));
    },
    NativeByteBuffer: function NativeByteBuffer() {
    },
    NativeTypedData: function NativeTypedData() {
    },
    NativeByteData: function NativeByteData() {
    },
    NativeTypedArray: function NativeTypedArray() {
    },
    NativeTypedArrayOfDouble: function NativeTypedArrayOfDouble() {
    },
    NativeTypedArrayOfInt: function NativeTypedArrayOfInt() {
    },
    NativeFloat32List: function NativeFloat32List() {
    },
    NativeFloat64List: function NativeFloat64List() {
    },
    NativeInt16List: function NativeInt16List() {
    },
    NativeInt32List: function NativeInt32List() {
    },
    NativeInt8List: function NativeInt8List() {
    },
    NativeUint16List: function NativeUint16List() {
    },
    NativeUint32List: function NativeUint32List() {
    },
    NativeUint8ClampedList: function NativeUint8ClampedList() {
    },
    NativeUint8List: function NativeUint8List() {
    },
    _NativeTypedArrayOfDouble_NativeTypedArray_ListMixin: function _NativeTypedArrayOfDouble_NativeTypedArray_ListMixin() {
    },
    _NativeTypedArrayOfDouble_NativeTypedArray_ListMixin_FixedLengthListMixin: function _NativeTypedArrayOfDouble_NativeTypedArray_ListMixin_FixedLengthListMixin() {
    },
    _NativeTypedArrayOfInt_NativeTypedArray_ListMixin: function _NativeTypedArrayOfInt_NativeTypedArray_ListMixin() {
    },
    _NativeTypedArrayOfInt_NativeTypedArray_ListMixin_FixedLengthListMixin: function _NativeTypedArrayOfInt_NativeTypedArray_ListMixin_FixedLengthListMixin() {
    },
    Rti__getFutureFromFutureOr(universe, rti) {
      var future = rti._precomputed1;
      return future == null ? rti._precomputed1 = A._Universe__lookupInterfaceRti(universe, "Future", [rti._primary]) : future;
    },
    Rti__isUnionOfFunctionType(rti) {
      var kind = rti._kind;
      if (kind === 6 || kind === 7)
        return A.Rti__isUnionOfFunctionType(rti._primary);
      return kind === 11 || kind === 12;
    },
    Rti__getCanonicalRecipe(rti) {
      return rti._canonicalRecipe;
    },
    findType(recipe) {
      return A._Universe_eval(init.typeUniverse, recipe, false);
    },
    _substitute(universe, rti, typeArguments, depth) {
      var baseType, substitutedBaseType, interfaceTypeArguments, substitutedInterfaceTypeArguments, base, substitutedBase, $arguments, substitutedArguments, t1, fields, substitutedFields, returnType, substitutedReturnType, functionParameters, substitutedFunctionParameters, bounds, substitutedBounds, index, argument,
        kind = rti._kind;
      switch (kind) {
        case 5:
        case 1:
        case 2:
        case 3:
        case 4:
          return rti;
        case 6:
          baseType = rti._primary;
          substitutedBaseType = A._substitute(universe, baseType, typeArguments, depth);
          if (substitutedBaseType === baseType)
            return rti;
          return A._Universe__lookupQuestionRti(universe, substitutedBaseType, true);
        case 7:
          baseType = rti._primary;
          substitutedBaseType = A._substitute(universe, baseType, typeArguments, depth);
          if (substitutedBaseType === baseType)
            return rti;
          return A._Universe__lookupFutureOrRti(universe, substitutedBaseType, true);
        case 8:
          interfaceTypeArguments = rti._rest;
          substitutedInterfaceTypeArguments = A._substituteArray(universe, interfaceTypeArguments, typeArguments, depth);
          if (substitutedInterfaceTypeArguments === interfaceTypeArguments)
            return rti;
          return A._Universe__lookupInterfaceRti(universe, rti._primary, substitutedInterfaceTypeArguments);
        case 9:
          base = rti._primary;
          substitutedBase = A._substitute(universe, base, typeArguments, depth);
          $arguments = rti._rest;
          substitutedArguments = A._substituteArray(universe, $arguments, typeArguments, depth);
          if (substitutedBase === base && substitutedArguments === $arguments)
            return rti;
          return A._Universe__lookupBindingRti(universe, substitutedBase, substitutedArguments);
        case 10:
          t1 = rti._primary;
          fields = rti._rest;
          substitutedFields = A._substituteArray(universe, fields, typeArguments, depth);
          if (substitutedFields === fields)
            return rti;
          return A._Universe__lookupRecordRti(universe, t1, substitutedFields);
        case 11:
          returnType = rti._primary;
          substitutedReturnType = A._substitute(universe, returnType, typeArguments, depth);
          functionParameters = rti._rest;
          substitutedFunctionParameters = A._substituteFunctionParameters(universe, functionParameters, typeArguments, depth);
          if (substitutedReturnType === returnType && substitutedFunctionParameters === functionParameters)
            return rti;
          return A._Universe__lookupFunctionRti(universe, substitutedReturnType, substitutedFunctionParameters);
        case 12:
          bounds = rti._rest;
          depth += bounds.length;
          substitutedBounds = A._substituteArray(universe, bounds, typeArguments, depth);
          base = rti._primary;
          substitutedBase = A._substitute(universe, base, typeArguments, depth);
          if (substitutedBounds === bounds && substitutedBase === base)
            return rti;
          return A._Universe__lookupGenericFunctionRti(universe, substitutedBase, substitutedBounds, true);
        case 13:
          index = rti._primary;
          if (index < depth)
            return rti;
          argument = typeArguments[index - depth];
          if (argument == null)
            return rti;
          return argument;
        default:
          throw A.wrapException(A.AssertionError$("Attempted to substitute unexpected RTI kind " + kind));
      }
    },
    _substituteArray(universe, rtiArray, typeArguments, depth) {
      var changed, i, rti, substitutedRti,
        $length = rtiArray.length,
        result = A._Utils_newArrayOrEmpty($length);
      for (changed = false, i = 0; i < $length; ++i) {
        rti = rtiArray[i];
        substitutedRti = A._substitute(universe, rti, typeArguments, depth);
        if (substitutedRti !== rti)
          changed = true;
        result[i] = substitutedRti;
      }
      return changed ? result : rtiArray;
    },
    _substituteNamed(universe, namedArray, typeArguments, depth) {
      var changed, i, t1, t2, rti, substitutedRti,
        $length = namedArray.length,
        result = A._Utils_newArrayOrEmpty($length);
      for (changed = false, i = 0; i < $length; i += 3) {
        t1 = namedArray[i];
        t2 = namedArray[i + 1];
        rti = namedArray[i + 2];
        substitutedRti = A._substitute(universe, rti, typeArguments, depth);
        if (substitutedRti !== rti)
          changed = true;
        result.splice(i, 3, t1, t2, substitutedRti);
      }
      return changed ? result : namedArray;
    },
    _substituteFunctionParameters(universe, functionParameters, typeArguments, depth) {
      var result,
        requiredPositional = functionParameters._requiredPositional,
        substitutedRequiredPositional = A._substituteArray(universe, requiredPositional, typeArguments, depth),
        optionalPositional = functionParameters._optionalPositional,
        substitutedOptionalPositional = A._substituteArray(universe, optionalPositional, typeArguments, depth),
        named = functionParameters._named,
        substitutedNamed = A._substituteNamed(universe, named, typeArguments, depth);
      if (substitutedRequiredPositional === requiredPositional && substitutedOptionalPositional === optionalPositional && substitutedNamed === named)
        return functionParameters;
      result = new A._FunctionParameters();
      result._requiredPositional = substitutedRequiredPositional;
      result._optionalPositional = substitutedOptionalPositional;
      result._named = substitutedNamed;
      return result;
    },
    _setArrayType(target, rti) {
      target[init.arrayRti] = rti;
      return target;
    },
    closureFunctionType(closure) {
      var signature = closure.$signature;
      if (signature != null) {
        if (typeof signature == "number")
          return A.getTypeFromTypesTable(signature);
        return closure.$signature();
      }
      return null;
    },
    instanceOrFunctionType(object, testRti) {
      var rti;
      if (A.Rti__isUnionOfFunctionType(testRti))
        if (object instanceof A.Closure) {
          rti = A.closureFunctionType(object);
          if (rti != null)
            return rti;
        }
      return A.instanceType(object);
    },
    instanceType(object) {
      if (object instanceof A.Object)
        return A._instanceType(object);
      if (Array.isArray(object))
        return A._arrayInstanceType(object);
      return A._instanceTypeFromConstructor(J.getInterceptor$(object));
    },
    _arrayInstanceType(object) {
      var rti = object[init.arrayRti],
        defaultRti = type$.JSArray_dynamic;
      if (rti == null)
        return defaultRti;
      if (rti.constructor !== defaultRti.constructor)
        return defaultRti;
      return rti;
    },
    _instanceType(object) {
      var rti = object.$ti;
      return rti != null ? rti : A._instanceTypeFromConstructor(object);
    },
    _instanceTypeFromConstructor(instance) {
      var $constructor = instance.constructor,
        probe = $constructor.$ccache;
      if (probe != null)
        return probe;
      return A._instanceTypeFromConstructorMiss(instance, $constructor);
    },
    _instanceTypeFromConstructorMiss(instance, $constructor) {
      var effectiveConstructor = instance instanceof A.Closure ? Object.getPrototypeOf(Object.getPrototypeOf(instance)).constructor : $constructor,
        rti = A._Universe_findErasedType(init.typeUniverse, effectiveConstructor.name);
      $constructor.$ccache = rti;
      return rti;
    },
    getTypeFromTypesTable(index) {
      var rti,
        table = init.types,
        type = table[index];
      if (typeof type == "string") {
        rti = A._Universe_eval(init.typeUniverse, type, false);
        table[index] = rti;
        return rti;
      }
      return type;
    },
    getRuntimeTypeOfDartObject(object) {
      return A.createRuntimeType(A._instanceType(object));
    },
    _structuralTypeOf(object) {
      var functionRti;
      if (object instanceof A._Record)
        return object._getRti$0();
      functionRti = object instanceof A.Closure ? A.closureFunctionType(object) : null;
      if (functionRti != null)
        return functionRti;
      if (type$.TrustedGetRuntimeType._is(object))
        return J.get$runtimeType$(object)._rti;
      if (Array.isArray(object))
        return A._arrayInstanceType(object);
      return A.instanceType(object);
    },
    createRuntimeType(rti) {
      var t1 = rti._cachedRuntimeType;
      return t1 == null ? rti._cachedRuntimeType = new A._Type(rti) : t1;
    },
    evaluateRtiForRecord(recordRecipe, valuesList) {
      var bindings, i,
        values = valuesList,
        $length = values.length;
      if ($length === 0)
        return type$.Record_0;
      if (0 >= $length)
        return A.ioore(values, 0);
      bindings = A._Universe_evalInEnvironment(init.typeUniverse, A._structuralTypeOf(values[0]), "@<0>");
      for (i = 1; i < $length; ++i) {
        if (!(i < values.length))
          return A.ioore(values, i);
        bindings = A._Universe_bind(init.typeUniverse, bindings, A._structuralTypeOf(values[i]));
      }
      return A._Universe_evalInEnvironment(init.typeUniverse, bindings, recordRecipe);
    },
    typeLiteral(recipe) {
      return A.createRuntimeType(A._Universe_eval(init.typeUniverse, recipe, false));
    },
    _installSpecializedIsTest(object) {
      var kind, isFn, $name, predicate, testRti = this;
      if (testRti === type$.Object)
        return A._finishIsFn(testRti, object, A._isObject);
      if (A.isTopType(testRti))
        return A._finishIsFn(testRti, object, A._isTop);
      kind = testRti._kind;
      if (kind === 6)
        return A._finishIsFn(testRti, object, A._generalNullableIsTestImplementation);
      if (kind === 1)
        return A._finishIsFn(testRti, object, A._isNever);
      if (kind === 7)
        return A._finishIsFn(testRti, object, A._isFutureOr);
      if (testRti === type$.int)
        isFn = A._isInt;
      else if (testRti === type$.double || testRti === type$.num)
        isFn = A._isNum;
      else if (testRti === type$.String)
        isFn = A._isString;
      else
        isFn = testRti === type$.bool ? A._isBool : null;
      if (isFn != null)
        return A._finishIsFn(testRti, object, isFn);
      if (kind === 8) {
        $name = testRti._primary;
        if (testRti._rest.every(A.isTopType)) {
          testRti._specializedTestResource = "$is" + $name;
          if ($name === "List")
            return A._finishIsFn(testRti, object, A._isListTestViaProperty);
          return A._finishIsFn(testRti, object, A._isTestViaProperty);
        }
      } else if (kind === 10) {
        predicate = A.createRecordTypePredicate(testRti._primary, testRti._rest);
        return A._finishIsFn(testRti, object, predicate == null ? A._isNever : predicate);
      }
      return A._finishIsFn(testRti, object, A._generalIsTestImplementation);
    },
    _finishIsFn(testRti, object, isFn) {
      testRti._is = isFn;
      return testRti._is(object);
    },
    _installSpecializedAsCheck(object) {
      var testRti = this,
        asFn = A._generalAsCheckImplementation;
      if (A.isTopType(testRti))
        asFn = A._asTop;
      else if (testRti === type$.Object)
        asFn = A._asObject;
      else if (A.isNullable(testRti))
        asFn = A._generalNullableAsCheckImplementation;
      if (testRti === type$.int)
        asFn = A._asInt;
      else if (testRti === type$.nullable_int)
        asFn = A._asIntQ;
      else if (testRti === type$.String)
        asFn = A._asString;
      else if (testRti === type$.nullable_String)
        asFn = A._asStringQ;
      else if (testRti === type$.bool)
        asFn = A._asBool;
      else if (testRti === type$.nullable_bool)
        asFn = A._asBoolQ;
      else if (testRti === type$.num)
        asFn = A._asNum;
      else if (testRti === type$.nullable_num)
        asFn = A._asNumQ;
      else if (testRti === type$.double)
        asFn = A._asDouble;
      else if (testRti === type$.nullable_double)
        asFn = A._asDoubleQ;
      testRti._as = asFn;
      return testRti._as(object);
    },
    _generalIsTestImplementation(object) {
      var testRti = this;
      if (object == null)
        return A.isNullable(testRti);
      return A.isSubtype(init.typeUniverse, A.instanceOrFunctionType(object, testRti), testRti);
    },
    _generalNullableIsTestImplementation(object) {
      if (object == null)
        return true;
      return this._primary._is(object);
    },
    _isTestViaProperty(object) {
      var tag, testRti = this;
      if (object == null)
        return A.isNullable(testRti);
      tag = testRti._specializedTestResource;
      if (object instanceof A.Object)
        return !!object[tag];
      return !!J.getInterceptor$(object)[tag];
    },
    _isListTestViaProperty(object) {
      var tag, testRti = this;
      if (object == null)
        return A.isNullable(testRti);
      if (typeof object != "object")
        return false;
      if (Array.isArray(object))
        return true;
      tag = testRti._specializedTestResource;
      if (object instanceof A.Object)
        return !!object[tag];
      return !!J.getInterceptor$(object)[tag];
    },
    _generalAsCheckImplementation(object) {
      var testRti = this;
      if (object == null) {
        if (A.isNullable(testRti))
          return object;
      } else if (testRti._is(object))
        return object;
      throw A.initializeExceptionWrapper(A._errorForAsCheck(object, testRti), new Error());
    },
    _generalNullableAsCheckImplementation(object) {
      var testRti = this;
      if (object == null || testRti._is(object))
        return object;
      throw A.initializeExceptionWrapper(A._errorForAsCheck(object, testRti), new Error());
    },
    _errorForAsCheck(object, testRti) {
      return new A._TypeError("TypeError: " + A._Error_compose(object, A._rtiToString(testRti, null)));
    },
    _Error_compose(object, checkedTypeDescription) {
      return A.Error_safeToString(object) + ": type '" + A._rtiToString(A._structuralTypeOf(object), null) + "' is not a subtype of type '" + checkedTypeDescription + "'";
    },
    _TypeError__TypeError$forType(object, type) {
      return new A._TypeError("TypeError: " + A._Error_compose(object, type));
    },
    _isFutureOr(object) {
      var testRti = this;
      return testRti._primary._is(object) || A.Rti__getFutureFromFutureOr(init.typeUniverse, testRti)._is(object);
    },
    _isObject(object) {
      return object != null;
    },
    _asObject(object) {
      if (object != null)
        return object;
      throw A.initializeExceptionWrapper(A._TypeError__TypeError$forType(object, "Object"), new Error());
    },
    _isTop(object) {
      return true;
    },
    _asTop(object) {
      return object;
    },
    _isNever(object) {
      return false;
    },
    _isBool(object) {
      return true === object || false === object;
    },
    _asBool(object) {
      if (true === object)
        return true;
      if (false === object)
        return false;
      throw A.initializeExceptionWrapper(A._TypeError__TypeError$forType(object, "bool"), new Error());
    },
    _asBoolQ(object) {
      if (true === object)
        return true;
      if (false === object)
        return false;
      if (object == null)
        return object;
      throw A.initializeExceptionWrapper(A._TypeError__TypeError$forType(object, "bool?"), new Error());
    },
    _asDouble(object) {
      if (typeof object == "number")
        return object;
      throw A.initializeExceptionWrapper(A._TypeError__TypeError$forType(object, "double"), new Error());
    },
    _asDoubleQ(object) {
      if (typeof object == "number")
        return object;
      if (object == null)
        return object;
      throw A.initializeExceptionWrapper(A._TypeError__TypeError$forType(object, "double?"), new Error());
    },
    _isInt(object) {
      return typeof object == "number" && Math.floor(object) === object;
    },
    _asInt(object) {
      if (typeof object == "number" && Math.floor(object) === object)
        return object;
      throw A.initializeExceptionWrapper(A._TypeError__TypeError$forType(object, "int"), new Error());
    },
    _asIntQ(object) {
      if (typeof object == "number" && Math.floor(object) === object)
        return object;
      if (object == null)
        return object;
      throw A.initializeExceptionWrapper(A._TypeError__TypeError$forType(object, "int?"), new Error());
    },
    _isNum(object) {
      return typeof object == "number";
    },
    _asNum(object) {
      if (typeof object == "number")
        return object;
      throw A.initializeExceptionWrapper(A._TypeError__TypeError$forType(object, "num"), new Error());
    },
    _asNumQ(object) {
      if (typeof object == "number")
        return object;
      if (object == null)
        return object;
      throw A.initializeExceptionWrapper(A._TypeError__TypeError$forType(object, "num?"), new Error());
    },
    _isString(object) {
      return typeof object == "string";
    },
    _asString(object) {
      if (typeof object == "string")
        return object;
      throw A.initializeExceptionWrapper(A._TypeError__TypeError$forType(object, "String"), new Error());
    },
    _asStringQ(object) {
      if (typeof object == "string")
        return object;
      if (object == null)
        return object;
      throw A.initializeExceptionWrapper(A._TypeError__TypeError$forType(object, "String?"), new Error());
    },
    _rtiArrayToString(array, genericContext) {
      var s, sep, i;
      for (s = "", sep = "", i = 0; i < array.length; ++i, sep = ", ")
        s += sep + A._rtiToString(array[i], genericContext);
      return s;
    },
    _recordRtiToString(recordType, genericContext) {
      var fieldCount, names, namesIndex, s, comma, i,
        partialShape = recordType._primary,
        fields = recordType._rest;
      if ("" === partialShape)
        return "(" + A._rtiArrayToString(fields, genericContext) + ")";
      fieldCount = fields.length;
      names = partialShape.split(",");
      namesIndex = names.length - fieldCount;
      for (s = "(", comma = "", i = 0; i < fieldCount; ++i, comma = ", ") {
        s += comma;
        if (namesIndex === 0)
          s += "{";
        s += A._rtiToString(fields[i], genericContext);
        if (namesIndex >= 0)
          s += " " + names[namesIndex];
        ++namesIndex;
      }
      return s + "})";
    },
    _functionRtiToString(functionType, genericContext, bounds) {
      var boundsLength, offset, i, t1, typeParametersText, typeSep, t2, t3, boundRti, kind, parameters, requiredPositional, requiredPositionalLength, optionalPositional, optionalPositionalLength, named, namedLength, returnTypeText, argumentsText, sep, _s2_ = ", ", outerContextLength = null;
      if (bounds != null) {
        boundsLength = bounds.length;
        if (genericContext == null)
          genericContext = A._setArrayType([], type$.JSArray_String);
        else
          outerContextLength = genericContext.length;
        offset = genericContext.length;
        for (i = boundsLength; i > 0; --i)
          B.JSArray_methods.add$1(genericContext, "T" + (offset + i));
        for (t1 = type$.nullable_Object, typeParametersText = "<", typeSep = "", i = 0; i < boundsLength; ++i, typeSep = _s2_) {
          t2 = genericContext.length;
          t3 = t2 - 1 - i;
          if (!(t3 >= 0))
            return A.ioore(genericContext, t3);
          typeParametersText = typeParametersText + typeSep + genericContext[t3];
          boundRti = bounds[i];
          kind = boundRti._kind;
          if (!(kind === 2 || kind === 3 || kind === 4 || kind === 5 || boundRti === t1))
            typeParametersText += " extends " + A._rtiToString(boundRti, genericContext);
        }
        typeParametersText += ">";
      } else
        typeParametersText = "";
      t1 = functionType._primary;
      parameters = functionType._rest;
      requiredPositional = parameters._requiredPositional;
      requiredPositionalLength = requiredPositional.length;
      optionalPositional = parameters._optionalPositional;
      optionalPositionalLength = optionalPositional.length;
      named = parameters._named;
      namedLength = named.length;
      returnTypeText = A._rtiToString(t1, genericContext);
      for (argumentsText = "", sep = "", i = 0; i < requiredPositionalLength; ++i, sep = _s2_)
        argumentsText += sep + A._rtiToString(requiredPositional[i], genericContext);
      if (optionalPositionalLength > 0) {
        argumentsText += sep + "[";
        for (sep = "", i = 0; i < optionalPositionalLength; ++i, sep = _s2_)
          argumentsText += sep + A._rtiToString(optionalPositional[i], genericContext);
        argumentsText += "]";
      }
      if (namedLength > 0) {
        argumentsText += sep + "{";
        for (sep = "", i = 0; i < namedLength; i += 3, sep = _s2_) {
          argumentsText += sep;
          if (named[i + 1])
            argumentsText += "required ";
          argumentsText += A._rtiToString(named[i + 2], genericContext) + " " + named[i];
        }
        argumentsText += "}";
      }
      if (outerContextLength != null) {
        genericContext.toString;
        genericContext.length = outerContextLength;
      }
      return typeParametersText + "(" + argumentsText + ") => " + returnTypeText;
    },
    _rtiToString(rti, genericContext) {
      var questionArgument, s, argumentKind, $name, $arguments, t1, t2,
        kind = rti._kind;
      if (kind === 5)
        return "erased";
      if (kind === 2)
        return "dynamic";
      if (kind === 3)
        return "void";
      if (kind === 1)
        return "Never";
      if (kind === 4)
        return "any";
      if (kind === 6) {
        questionArgument = rti._primary;
        s = A._rtiToString(questionArgument, genericContext);
        argumentKind = questionArgument._kind;
        return (argumentKind === 11 || argumentKind === 12 ? "(" + s + ")" : s) + "?";
      }
      if (kind === 7)
        return "FutureOr<" + A._rtiToString(rti._primary, genericContext) + ">";
      if (kind === 8) {
        $name = A._unminifyOrTag(rti._primary);
        $arguments = rti._rest;
        return $arguments.length > 0 ? $name + ("<" + A._rtiArrayToString($arguments, genericContext) + ">") : $name;
      }
      if (kind === 10)
        return A._recordRtiToString(rti, genericContext);
      if (kind === 11)
        return A._functionRtiToString(rti, genericContext, null);
      if (kind === 12)
        return A._functionRtiToString(rti._primary, genericContext, rti._rest);
      if (kind === 13) {
        t1 = rti._primary;
        t2 = genericContext.length;
        t1 = t2 - 1 - t1;
        if (!(t1 >= 0 && t1 < t2))
          return A.ioore(genericContext, t1);
        return genericContext[t1];
      }
      return "?";
    },
    _unminifyOrTag(rawClassName) {
      var preserved = init.mangledGlobalNames[rawClassName];
      if (preserved != null)
        return preserved;
      return rawClassName;
    },
    _Universe_findRule(universe, targetType) {
      var rule = universe.tR[targetType];
      for (; typeof rule == "string";)
        rule = universe.tR[rule];
      return rule;
    },
    _Universe_findErasedType(universe, cls) {
      var $length, erased, $arguments, i, $interface,
        t1 = universe.eT,
        probe = t1[cls];
      if (probe == null)
        return A._Universe_eval(universe, cls, false);
      else if (typeof probe == "number") {
        $length = probe;
        erased = A._Universe__lookupTerminalRti(universe, 5, "#");
        $arguments = A._Utils_newArrayOrEmpty($length);
        for (i = 0; i < $length; ++i)
          $arguments[i] = erased;
        $interface = A._Universe__lookupInterfaceRti(universe, cls, $arguments);
        t1[cls] = $interface;
        return $interface;
      } else
        return probe;
    },
    _Universe_addRules(universe, rules) {
      return A._Utils_objectAssign(universe.tR, rules);
    },
    _Universe_addErasedTypes(universe, types) {
      return A._Utils_objectAssign(universe.eT, types);
    },
    _Universe_eval(universe, recipe, normalize) {
      var rti,
        t1 = universe.eC,
        probe = t1.get(recipe);
      if (probe != null)
        return probe;
      rti = A._Parser_parse(A._Parser_create(universe, null, recipe, false));
      t1.set(recipe, rti);
      return rti;
    },
    _Universe_evalInEnvironment(universe, environment, recipe) {
      var probe, rti,
        cache = environment._evalCache;
      if (cache == null)
        cache = environment._evalCache = new Map();
      probe = cache.get(recipe);
      if (probe != null)
        return probe;
      rti = A._Parser_parse(A._Parser_create(universe, environment, recipe, true));
      cache.set(recipe, rti);
      return rti;
    },
    _Universe_bind(universe, environment, argumentsRti) {
      var argumentsRecipe, probe, rti,
        cache = environment._bindCache;
      if (cache == null)
        cache = environment._bindCache = new Map();
      argumentsRecipe = argumentsRti._canonicalRecipe;
      probe = cache.get(argumentsRecipe);
      if (probe != null)
        return probe;
      rti = A._Universe__lookupBindingRti(universe, environment, argumentsRti._kind === 9 ? argumentsRti._rest : [argumentsRti]);
      cache.set(argumentsRecipe, rti);
      return rti;
    },
    _Universe__installTypeTests(universe, rti) {
      rti._as = A._installSpecializedAsCheck;
      rti._is = A._installSpecializedIsTest;
      return rti;
    },
    _Universe__lookupTerminalRti(universe, kind, key) {
      var rti, t1,
        probe = universe.eC.get(key);
      if (probe != null)
        return probe;
      rti = new A.Rti(null, null);
      rti._kind = kind;
      rti._canonicalRecipe = key;
      t1 = A._Universe__installTypeTests(universe, rti);
      universe.eC.set(key, t1);
      return t1;
    },
    _Universe__lookupQuestionRti(universe, baseType, normalize) {
      var t1,
        key = baseType._canonicalRecipe + "?",
        probe = universe.eC.get(key);
      if (probe != null)
        return probe;
      t1 = A._Universe__createQuestionRti(universe, baseType, key, normalize);
      universe.eC.set(key, t1);
      return t1;
    },
    _Universe__createQuestionRti(universe, baseType, key, normalize) {
      var baseKind, t1, rti;
      if (normalize) {
        baseKind = baseType._kind;
        t1 = true;
        if (!A.isTopType(baseType))
          if (!(baseType === type$.Null || baseType === type$.JSNull))
            if (baseKind !== 6)
              t1 = baseKind === 7 && A.isNullable(baseType._primary);
        if (t1)
          return baseType;
        else if (baseKind === 1)
          return type$.Null;
      }
      rti = new A.Rti(null, null);
      rti._kind = 6;
      rti._primary = baseType;
      rti._canonicalRecipe = key;
      return A._Universe__installTypeTests(universe, rti);
    },
    _Universe__lookupFutureOrRti(universe, baseType, normalize) {
      var t1,
        key = baseType._canonicalRecipe + "/",
        probe = universe.eC.get(key);
      if (probe != null)
        return probe;
      t1 = A._Universe__createFutureOrRti(universe, baseType, key, normalize);
      universe.eC.set(key, t1);
      return t1;
    },
    _Universe__createFutureOrRti(universe, baseType, key, normalize) {
      var t1, rti;
      if (normalize) {
        t1 = baseType._kind;
        if (A.isTopType(baseType) || baseType === type$.Object)
          return baseType;
        else if (t1 === 1)
          return A._Universe__lookupInterfaceRti(universe, "Future", [baseType]);
        else if (baseType === type$.Null || baseType === type$.JSNull)
          return type$.nullable_Future_Null;
      }
      rti = new A.Rti(null, null);
      rti._kind = 7;
      rti._primary = baseType;
      rti._canonicalRecipe = key;
      return A._Universe__installTypeTests(universe, rti);
    },
    _Universe__lookupGenericFunctionParameterRti(universe, index) {
      var rti, t1,
        key = "" + index + "^",
        probe = universe.eC.get(key);
      if (probe != null)
        return probe;
      rti = new A.Rti(null, null);
      rti._kind = 13;
      rti._primary = index;
      rti._canonicalRecipe = key;
      t1 = A._Universe__installTypeTests(universe, rti);
      universe.eC.set(key, t1);
      return t1;
    },
    _Universe__canonicalRecipeJoin($arguments) {
      var s, sep, i,
        $length = $arguments.length;
      for (s = "", sep = "", i = 0; i < $length; ++i, sep = ",")
        s += sep + $arguments[i]._canonicalRecipe;
      return s;
    },
    _Universe__canonicalRecipeJoinNamed($arguments) {
      var s, sep, i, t1, nameSep,
        $length = $arguments.length;
      for (s = "", sep = "", i = 0; i < $length; i += 3, sep = ",") {
        t1 = $arguments[i];
        nameSep = $arguments[i + 1] ? "!" : ":";
        s += sep + t1 + nameSep + $arguments[i + 2]._canonicalRecipe;
      }
      return s;
    },
    _Universe__lookupInterfaceRti(universe, $name, $arguments) {
      var probe, rti, t1,
        s = $name;
      if ($arguments.length > 0)
        s += "<" + A._Universe__canonicalRecipeJoin($arguments) + ">";
      probe = universe.eC.get(s);
      if (probe != null)
        return probe;
      rti = new A.Rti(null, null);
      rti._kind = 8;
      rti._primary = $name;
      rti._rest = $arguments;
      if ($arguments.length > 0)
        rti._precomputed1 = $arguments[0];
      rti._canonicalRecipe = s;
      t1 = A._Universe__installTypeTests(universe, rti);
      universe.eC.set(s, t1);
      return t1;
    },
    _Universe__lookupBindingRti(universe, base, $arguments) {
      var newBase, newArguments, key, probe, rti, t1;
      if (base._kind === 9) {
        newBase = base._primary;
        newArguments = base._rest.concat($arguments);
      } else {
        newArguments = $arguments;
        newBase = base;
      }
      key = newBase._canonicalRecipe + (";<" + A._Universe__canonicalRecipeJoin(newArguments) + ">");
      probe = universe.eC.get(key);
      if (probe != null)
        return probe;
      rti = new A.Rti(null, null);
      rti._kind = 9;
      rti._primary = newBase;
      rti._rest = newArguments;
      rti._canonicalRecipe = key;
      t1 = A._Universe__installTypeTests(universe, rti);
      universe.eC.set(key, t1);
      return t1;
    },
    _Universe__lookupRecordRti(universe, partialShapeTag, fields) {
      var rti, t1,
        key = "+" + (partialShapeTag + "(" + A._Universe__canonicalRecipeJoin(fields) + ")"),
        probe = universe.eC.get(key);
      if (probe != null)
        return probe;
      rti = new A.Rti(null, null);
      rti._kind = 10;
      rti._primary = partialShapeTag;
      rti._rest = fields;
      rti._canonicalRecipe = key;
      t1 = A._Universe__installTypeTests(universe, rti);
      universe.eC.set(key, t1);
      return t1;
    },
    _Universe__lookupFunctionRti(universe, returnType, parameters) {
      var sep, key, probe, rti, t1,
        s = returnType._canonicalRecipe,
        requiredPositional = parameters._requiredPositional,
        requiredPositionalLength = requiredPositional.length,
        optionalPositional = parameters._optionalPositional,
        optionalPositionalLength = optionalPositional.length,
        named = parameters._named,
        namedLength = named.length,
        recipe = "(" + A._Universe__canonicalRecipeJoin(requiredPositional);
      if (optionalPositionalLength > 0) {
        sep = requiredPositionalLength > 0 ? "," : "";
        recipe += sep + "[" + A._Universe__canonicalRecipeJoin(optionalPositional) + "]";
      }
      if (namedLength > 0) {
        sep = requiredPositionalLength > 0 ? "," : "";
        recipe += sep + "{" + A._Universe__canonicalRecipeJoinNamed(named) + "}";
      }
      key = s + (recipe + ")");
      probe = universe.eC.get(key);
      if (probe != null)
        return probe;
      rti = new A.Rti(null, null);
      rti._kind = 11;
      rti._primary = returnType;
      rti._rest = parameters;
      rti._canonicalRecipe = key;
      t1 = A._Universe__installTypeTests(universe, rti);
      universe.eC.set(key, t1);
      return t1;
    },
    _Universe__lookupGenericFunctionRti(universe, baseFunctionType, bounds, normalize) {
      var t1,
        key = baseFunctionType._canonicalRecipe + ("<" + A._Universe__canonicalRecipeJoin(bounds) + ">"),
        probe = universe.eC.get(key);
      if (probe != null)
        return probe;
      t1 = A._Universe__createGenericFunctionRti(universe, baseFunctionType, bounds, key, normalize);
      universe.eC.set(key, t1);
      return t1;
    },
    _Universe__createGenericFunctionRti(universe, baseFunctionType, bounds, key, normalize) {
      var $length, typeArguments, count, i, bound, substitutedBase, substitutedBounds, rti;
      if (normalize) {
        $length = bounds.length;
        typeArguments = A._Utils_newArrayOrEmpty($length);
        for (count = 0, i = 0; i < $length; ++i) {
          bound = bounds[i];
          if (bound._kind === 1) {
            typeArguments[i] = bound;
            ++count;
          }
        }
        if (count > 0) {
          substitutedBase = A._substitute(universe, baseFunctionType, typeArguments, 0);
          substitutedBounds = A._substituteArray(universe, bounds, typeArguments, 0);
          return A._Universe__lookupGenericFunctionRti(universe, substitutedBase, substitutedBounds, bounds !== substitutedBounds);
        }
      }
      rti = new A.Rti(null, null);
      rti._kind = 12;
      rti._primary = baseFunctionType;
      rti._rest = bounds;
      rti._canonicalRecipe = key;
      return A._Universe__installTypeTests(universe, rti);
    },
    _Parser_create(universe, environment, recipe, normalize) {
      return {u: universe, e: environment, r: recipe, s: [], p: 0, n: normalize};
    },
    _Parser_parse(parser) {
      var t2, i, ch, t3, array, end, item,
        source = parser.r,
        t1 = parser.s;
      for (t2 = source.length, i = 0; i < t2;) {
        ch = source.charCodeAt(i);
        if (ch >= 48 && ch <= 57)
          i = A._Parser_handleDigit(i + 1, ch, source, t1);
        else if ((((ch | 32) >>> 0) - 97 & 65535) < 26 || ch === 95 || ch === 36 || ch === 124)
          i = A._Parser_handleIdentifier(parser, i, source, t1, false);
        else if (ch === 46)
          i = A._Parser_handleIdentifier(parser, i, source, t1, true);
        else {
          ++i;
          switch (ch) {
            case 44:
              break;
            case 58:
              t1.push(false);
              break;
            case 33:
              t1.push(true);
              break;
            case 59:
              t1.push(A._Parser_toType(parser.u, parser.e, t1.pop()));
              break;
            case 94:
              t1.push(A._Universe__lookupGenericFunctionParameterRti(parser.u, t1.pop()));
              break;
            case 35:
              t1.push(A._Universe__lookupTerminalRti(parser.u, 5, "#"));
              break;
            case 64:
              t1.push(A._Universe__lookupTerminalRti(parser.u, 2, "@"));
              break;
            case 126:
              t1.push(A._Universe__lookupTerminalRti(parser.u, 3, "~"));
              break;
            case 60:
              t1.push(parser.p);
              parser.p = t1.length;
              break;
            case 62:
              A._Parser_handleTypeArguments(parser, t1);
              break;
            case 38:
              A._Parser_handleExtendedOperations(parser, t1);
              break;
            case 63:
              t3 = parser.u;
              t1.push(A._Universe__lookupQuestionRti(t3, A._Parser_toType(t3, parser.e, t1.pop()), parser.n));
              break;
            case 47:
              t3 = parser.u;
              t1.push(A._Universe__lookupFutureOrRti(t3, A._Parser_toType(t3, parser.e, t1.pop()), parser.n));
              break;
            case 40:
              t1.push(-3);
              t1.push(parser.p);
              parser.p = t1.length;
              break;
            case 41:
              A._Parser_handleArguments(parser, t1);
              break;
            case 91:
              t1.push(parser.p);
              parser.p = t1.length;
              break;
            case 93:
              array = t1.splice(parser.p);
              A._Parser_toTypes(parser.u, parser.e, array);
              parser.p = t1.pop();
              t1.push(array);
              t1.push(-1);
              break;
            case 123:
              t1.push(parser.p);
              parser.p = t1.length;
              break;
            case 125:
              array = t1.splice(parser.p);
              A._Parser_toTypesNamed(parser.u, parser.e, array);
              parser.p = t1.pop();
              t1.push(array);
              t1.push(-2);
              break;
            case 43:
              end = source.indexOf("(", i);
              t1.push(source.substring(i, end));
              t1.push(-4);
              t1.push(parser.p);
              parser.p = t1.length;
              i = end + 1;
              break;
            default:
              throw "Bad character " + ch;
          }
        }
      }
      item = t1.pop();
      return A._Parser_toType(parser.u, parser.e, item);
    },
    _Parser_handleDigit(i, digit, source, stack) {
      var t1, ch,
        value = digit - 48;
      for (t1 = source.length; i < t1; ++i) {
        ch = source.charCodeAt(i);
        if (!(ch >= 48 && ch <= 57))
          break;
        value = value * 10 + (ch - 48);
      }
      stack.push(value);
      return i;
    },
    _Parser_handleIdentifier(parser, start, source, stack, hasPeriod) {
      var t1, ch, t2, string, environment, recipe,
        i = start + 1;
      for (t1 = source.length; i < t1; ++i) {
        ch = source.charCodeAt(i);
        if (ch === 46) {
          if (hasPeriod)
            break;
          hasPeriod = true;
        } else {
          if (!((((ch | 32) >>> 0) - 97 & 65535) < 26 || ch === 95 || ch === 36 || ch === 124))
            t2 = ch >= 48 && ch <= 57;
          else
            t2 = true;
          if (!t2)
            break;
        }
      }
      string = source.substring(start, i);
      if (hasPeriod) {
        t1 = parser.u;
        environment = parser.e;
        if (environment._kind === 9)
          environment = environment._primary;
        recipe = A._Universe_findRule(t1, environment._primary)[string];
        if (recipe == null)
          A.throwExpression('No "' + string + '" in "' + A.Rti__getCanonicalRecipe(environment) + '"');
        stack.push(A._Universe_evalInEnvironment(t1, environment, recipe));
      } else
        stack.push(string);
      return i;
    },
    _Parser_handleTypeArguments(parser, stack) {
      var base,
        t1 = parser.u,
        $arguments = A._Parser_collectArray(parser, stack),
        head = stack.pop();
      if (typeof head == "string")
        stack.push(A._Universe__lookupInterfaceRti(t1, head, $arguments));
      else {
        base = A._Parser_toType(t1, parser.e, head);
        switch (base._kind) {
          case 11:
            stack.push(A._Universe__lookupGenericFunctionRti(t1, base, $arguments, parser.n));
            break;
          default:
            stack.push(A._Universe__lookupBindingRti(t1, base, $arguments));
            break;
        }
      }
    },
    _Parser_handleArguments(parser, stack) {
      var requiredPositional, returnType, parameters,
        t1 = parser.u,
        head = stack.pop(),
        optionalPositional = null, named = null;
      if (typeof head == "number")
        switch (head) {
          case -1:
            optionalPositional = stack.pop();
            break;
          case -2:
            named = stack.pop();
            break;
          default:
            stack.push(head);
            break;
        }
      else
        stack.push(head);
      requiredPositional = A._Parser_collectArray(parser, stack);
      head = stack.pop();
      switch (head) {
        case -3:
          head = stack.pop();
          if (optionalPositional == null)
            optionalPositional = t1.sEA;
          if (named == null)
            named = t1.sEA;
          returnType = A._Parser_toType(t1, parser.e, head);
          parameters = new A._FunctionParameters();
          parameters._requiredPositional = requiredPositional;
          parameters._optionalPositional = optionalPositional;
          parameters._named = named;
          stack.push(A._Universe__lookupFunctionRti(t1, returnType, parameters));
          return;
        case -4:
          stack.push(A._Universe__lookupRecordRti(t1, stack.pop(), requiredPositional));
          return;
        default:
          throw A.wrapException(A.AssertionError$("Unexpected state under `()`: " + A.S(head)));
      }
    },
    _Parser_handleExtendedOperations(parser, stack) {
      var $top = stack.pop();
      if (0 === $top) {
        stack.push(A._Universe__lookupTerminalRti(parser.u, 1, "0&"));
        return;
      }
      if (1 === $top) {
        stack.push(A._Universe__lookupTerminalRti(parser.u, 4, "1&"));
        return;
      }
      throw A.wrapException(A.AssertionError$("Unexpected extended operation " + A.S($top)));
    },
    _Parser_collectArray(parser, stack) {
      var array = stack.splice(parser.p);
      A._Parser_toTypes(parser.u, parser.e, array);
      parser.p = stack.pop();
      return array;
    },
    _Parser_toType(universe, environment, item) {
      if (typeof item == "string")
        return A._Universe__lookupInterfaceRti(universe, item, universe.sEA);
      else if (typeof item == "number") {
        environment.toString;
        return A._Parser_indexToType(universe, environment, item);
      } else
        return item;
    },
    _Parser_toTypes(universe, environment, items) {
      var i,
        $length = items.length;
      for (i = 0; i < $length; ++i)
        items[i] = A._Parser_toType(universe, environment, items[i]);
    },
    _Parser_toTypesNamed(universe, environment, items) {
      var i,
        $length = items.length;
      for (i = 2; i < $length; i += 3)
        items[i] = A._Parser_toType(universe, environment, items[i]);
    },
    _Parser_indexToType(universe, environment, index) {
      var typeArguments, len,
        kind = environment._kind;
      if (kind === 9) {
        if (index === 0)
          return environment._primary;
        typeArguments = environment._rest;
        len = typeArguments.length;
        if (index <= len)
          return typeArguments[index - 1];
        index -= len;
        environment = environment._primary;
        kind = environment._kind;
      } else if (index === 0)
        return environment;
      if (kind !== 8)
        throw A.wrapException(A.AssertionError$("Indexed base must be an interface type"));
      typeArguments = environment._rest;
      if (index <= typeArguments.length)
        return typeArguments[index - 1];
      throw A.wrapException(A.AssertionError$("Bad index " + index + " for " + environment.toString$0(0)));
    },
    isSubtype(universe, s, t) {
      var result,
        sCache = s._isSubtypeCache;
      if (sCache == null)
        sCache = s._isSubtypeCache = new Map();
      result = sCache.get(t);
      if (result == null) {
        result = A._isSubtype(universe, s, null, t, null);
        sCache.set(t, result);
      }
      return result;
    },
    _isSubtype(universe, s, sEnv, t, tEnv) {
      var sKind, leftTypeVariable, tKind, t1, t2, sBounds, tBounds, sLength, i, sBound, tBound;
      if (s === t)
        return true;
      if (A.isTopType(t))
        return true;
      sKind = s._kind;
      if (sKind === 4)
        return true;
      if (A.isTopType(s))
        return false;
      if (s._kind === 1)
        return true;
      leftTypeVariable = sKind === 13;
      if (leftTypeVariable)
        if (A._isSubtype(universe, sEnv[s._primary], sEnv, t, tEnv))
          return true;
      tKind = t._kind;
      t1 = type$.Null;
      if (s === t1 || s === type$.JSNull) {
        if (tKind === 7)
          return A._isSubtype(universe, s, sEnv, t._primary, tEnv);
        return t === t1 || t === type$.JSNull || tKind === 6;
      }
      if (t === type$.Object) {
        if (sKind === 7)
          return A._isSubtype(universe, s._primary, sEnv, t, tEnv);
        return sKind !== 6;
      }
      if (sKind === 7) {
        if (!A._isSubtype(universe, s._primary, sEnv, t, tEnv))
          return false;
        return A._isSubtype(universe, A.Rti__getFutureFromFutureOr(universe, s), sEnv, t, tEnv);
      }
      if (sKind === 6)
        return A._isSubtype(universe, t1, sEnv, t, tEnv) && A._isSubtype(universe, s._primary, sEnv, t, tEnv);
      if (tKind === 7) {
        if (A._isSubtype(universe, s, sEnv, t._primary, tEnv))
          return true;
        return A._isSubtype(universe, s, sEnv, A.Rti__getFutureFromFutureOr(universe, t), tEnv);
      }
      if (tKind === 6)
        return A._isSubtype(universe, s, sEnv, t1, tEnv) || A._isSubtype(universe, s, sEnv, t._primary, tEnv);
      if (leftTypeVariable)
        return false;
      t1 = sKind !== 11;
      if ((!t1 || sKind === 12) && t === type$.Function)
        return true;
      t2 = sKind === 10;
      if (t2 && t === type$.Record)
        return true;
      if (tKind === 12) {
        if (s === type$.JavaScriptFunction)
          return true;
        if (sKind !== 12)
          return false;
        sBounds = s._rest;
        tBounds = t._rest;
        sLength = sBounds.length;
        if (sLength !== tBounds.length)
          return false;
        sEnv = sEnv == null ? sBounds : sBounds.concat(sEnv);
        tEnv = tEnv == null ? tBounds : tBounds.concat(tEnv);
        for (i = 0; i < sLength; ++i) {
          sBound = sBounds[i];
          tBound = tBounds[i];
          if (!A._isSubtype(universe, sBound, sEnv, tBound, tEnv) || !A._isSubtype(universe, tBound, tEnv, sBound, sEnv))
            return false;
        }
        return A._isFunctionSubtype(universe, s._primary, sEnv, t._primary, tEnv);
      }
      if (tKind === 11) {
        if (s === type$.JavaScriptFunction)
          return true;
        if (t1)
          return false;
        return A._isFunctionSubtype(universe, s, sEnv, t, tEnv);
      }
      if (sKind === 8) {
        if (tKind !== 8)
          return false;
        return A._isInterfaceSubtype(universe, s, sEnv, t, tEnv);
      }
      if (t2 && tKind === 10)
        return A._isRecordSubtype(universe, s, sEnv, t, tEnv);
      return false;
    },
    _isFunctionSubtype(universe, s, sEnv, t, tEnv) {
      var sParameters, tParameters, sRequiredPositional, tRequiredPositional, sRequiredPositionalLength, tRequiredPositionalLength, requiredPositionalDelta, sOptionalPositional, tOptionalPositional, sOptionalPositionalLength, tOptionalPositionalLength, i, t1, sNamed, tNamed, sNamedLength, tNamedLength, sIndex, tIndex, tName, sName, sIsRequired;
      if (!A._isSubtype(universe, s._primary, sEnv, t._primary, tEnv))
        return false;
      sParameters = s._rest;
      tParameters = t._rest;
      sRequiredPositional = sParameters._requiredPositional;
      tRequiredPositional = tParameters._requiredPositional;
      sRequiredPositionalLength = sRequiredPositional.length;
      tRequiredPositionalLength = tRequiredPositional.length;
      if (sRequiredPositionalLength > tRequiredPositionalLength)
        return false;
      requiredPositionalDelta = tRequiredPositionalLength - sRequiredPositionalLength;
      sOptionalPositional = sParameters._optionalPositional;
      tOptionalPositional = tParameters._optionalPositional;
      sOptionalPositionalLength = sOptionalPositional.length;
      tOptionalPositionalLength = tOptionalPositional.length;
      if (sRequiredPositionalLength + sOptionalPositionalLength < tRequiredPositionalLength + tOptionalPositionalLength)
        return false;
      for (i = 0; i < sRequiredPositionalLength; ++i) {
        t1 = sRequiredPositional[i];
        if (!A._isSubtype(universe, tRequiredPositional[i], tEnv, t1, sEnv))
          return false;
      }
      for (i = 0; i < requiredPositionalDelta; ++i) {
        t1 = sOptionalPositional[i];
        if (!A._isSubtype(universe, tRequiredPositional[sRequiredPositionalLength + i], tEnv, t1, sEnv))
          return false;
      }
      for (i = 0; i < tOptionalPositionalLength; ++i) {
        t1 = sOptionalPositional[requiredPositionalDelta + i];
        if (!A._isSubtype(universe, tOptionalPositional[i], tEnv, t1, sEnv))
          return false;
      }
      sNamed = sParameters._named;
      tNamed = tParameters._named;
      sNamedLength = sNamed.length;
      tNamedLength = tNamed.length;
      for (sIndex = 0, tIndex = 0; tIndex < tNamedLength; tIndex += 3) {
        tName = tNamed[tIndex];
        for (; true;) {
          if (sIndex >= sNamedLength)
            return false;
          sName = sNamed[sIndex];
          sIndex += 3;
          if (tName < sName)
            return false;
          sIsRequired = sNamed[sIndex - 2];
          if (sName < tName) {
            if (sIsRequired)
              return false;
            continue;
          }
          t1 = tNamed[tIndex + 1];
          if (sIsRequired && !t1)
            return false;
          t1 = sNamed[sIndex - 1];
          if (!A._isSubtype(universe, tNamed[tIndex + 2], tEnv, t1, sEnv))
            return false;
          break;
        }
      }
      for (; sIndex < sNamedLength;) {
        if (sNamed[sIndex + 1])
          return false;
        sIndex += 3;
      }
      return true;
    },
    _isInterfaceSubtype(universe, s, sEnv, t, tEnv) {
      var rule, recipes, $length, supertypeArgs, i,
        sName = s._primary,
        tName = t._primary;
      for (; sName !== tName;) {
        rule = universe.tR[sName];
        if (rule == null)
          return false;
        if (typeof rule == "string") {
          sName = rule;
          continue;
        }
        recipes = rule[tName];
        if (recipes == null)
          return false;
        $length = recipes.length;
        supertypeArgs = $length > 0 ? new Array($length) : init.typeUniverse.sEA;
        for (i = 0; i < $length; ++i)
          supertypeArgs[i] = A._Universe_evalInEnvironment(universe, s, recipes[i]);
        return A._areArgumentsSubtypes(universe, supertypeArgs, null, sEnv, t._rest, tEnv);
      }
      return A._areArgumentsSubtypes(universe, s._rest, null, sEnv, t._rest, tEnv);
    },
    _areArgumentsSubtypes(universe, sArgs, sVariances, sEnv, tArgs, tEnv) {
      var i,
        $length = sArgs.length;
      for (i = 0; i < $length; ++i)
        if (!A._isSubtype(universe, sArgs[i], sEnv, tArgs[i], tEnv))
          return false;
      return true;
    },
    _isRecordSubtype(universe, s, sEnv, t, tEnv) {
      var i,
        sFields = s._rest,
        tFields = t._rest,
        sCount = sFields.length;
      if (sCount !== tFields.length)
        return false;
      if (s._primary !== t._primary)
        return false;
      for (i = 0; i < sCount; ++i)
        if (!A._isSubtype(universe, sFields[i], sEnv, tFields[i], tEnv))
          return false;
      return true;
    },
    isNullable(t) {
      var kind = t._kind,
        t1 = true;
      if (!(t === type$.Null || t === type$.JSNull))
        if (!A.isTopType(t))
          if (kind !== 6)
            t1 = kind === 7 && A.isNullable(t._primary);
      return t1;
    },
    isTopType(t) {
      var kind = t._kind;
      return kind === 2 || kind === 3 || kind === 4 || kind === 5 || t === type$.nullable_Object;
    },
    _Utils_objectAssign(o, other) {
      var i, key,
        keys = Object.keys(other),
        $length = keys.length;
      for (i = 0; i < $length; ++i) {
        key = keys[i];
        o[key] = other[key];
      }
    },
    _Utils_newArrayOrEmpty($length) {
      return $length > 0 ? new Array($length) : init.typeUniverse.sEA;
    },
    Rti: function Rti(t0, t1) {
      var _ = this;
      _._as = t0;
      _._is = t1;
      _._cachedRuntimeType = _._specializedTestResource = _._isSubtypeCache = _._precomputed1 = null;
      _._kind = 0;
      _._canonicalRecipe = _._bindCache = _._evalCache = _._rest = _._primary = null;
    },
    _FunctionParameters: function _FunctionParameters() {
      this._named = this._optionalPositional = this._requiredPositional = null;
    },
    _Type: function _Type(t0) {
      this._rti = t0;
    },
    _Error: function _Error() {
    },
    _TypeError: function _TypeError(t0) {
      this._message = t0;
    },
    _AsyncRun__initializeScheduleImmediate() {
      var t1, div, span;
      if (self.scheduleImmediate != null)
        return A.async__AsyncRun__scheduleImmediateJsOverride$closure();
      if (self.MutationObserver != null && self.document != null) {
        t1 = {};
        div = self.document.createElement("div");
        span = self.document.createElement("span");
        t1.storedCallback = null;
        new self.MutationObserver(A.convertDartClosureToJS(new A._AsyncRun__initializeScheduleImmediate_internalCallback(t1), 1)).observe(div, {childList: true});
        return new A._AsyncRun__initializeScheduleImmediate_closure(t1, div, span);
      } else if (self.setImmediate != null)
        return A.async__AsyncRun__scheduleImmediateWithSetImmediate$closure();
      return A.async__AsyncRun__scheduleImmediateWithTimer$closure();
    },
    _AsyncRun__scheduleImmediateJsOverride(callback) {
      self.scheduleImmediate(A.convertDartClosureToJS(new A._AsyncRun__scheduleImmediateJsOverride_internalCallback(type$.void_Function._as(callback)), 0));
    },
    _AsyncRun__scheduleImmediateWithSetImmediate(callback) {
      self.setImmediate(A.convertDartClosureToJS(new A._AsyncRun__scheduleImmediateWithSetImmediate_internalCallback(type$.void_Function._as(callback)), 0));
    },
    _AsyncRun__scheduleImmediateWithTimer(callback) {
      A.Timer__createTimer(B.Duration_0, type$.void_Function._as(callback));
    },
    Timer__createTimer(duration, callback) {
      var milliseconds = B.JSInt_methods._tdivFast$1(duration._duration, 1000);
      return A._TimerImpl$(milliseconds, callback);
    },
    _TimerImpl$(milliseconds, callback) {
      var t1 = new A._TimerImpl(true);
      t1._TimerImpl$2(milliseconds, callback);
      return t1;
    },
    _makeAsyncAwaitCompleter($T) {
      return new A._AsyncAwaitCompleter(new A._Future($.Zone__current, $T._eval$1("_Future<0>")), $T._eval$1("_AsyncAwaitCompleter<0>"));
    },
    _asyncStartSync(bodyFunction, completer) {
      bodyFunction.call$2(0, null);
      completer.isSync = true;
      return completer._future;
    },
    _asyncAwait(object, bodyFunction) {
      bodyFunction.toString;
      A._awaitOnObject(object, bodyFunction);
    },
    _asyncReturn(object, completer) {
      completer.complete$1(object);
    },
    _asyncRethrow(object, completer) {
      completer.completeError$2(A.unwrapException(object), A.getTraceFromException(object));
    },
    _awaitOnObject(object, bodyFunction) {
      var t1, future,
        thenCallback = new A._awaitOnObject_closure(bodyFunction),
        errorCallback = new A._awaitOnObject_closure0(bodyFunction);
      if (object instanceof A._Future)
        object._thenAwait$1$2(thenCallback, errorCallback, type$.dynamic);
      else {
        t1 = type$.dynamic;
        if (object instanceof A._Future)
          object.then$1$2$onError(thenCallback, errorCallback, t1);
        else {
          future = new A._Future($.Zone__current, type$._Future_dynamic);
          future._state = 8;
          future._resultOrListeners = object;
          future._thenAwait$1$2(thenCallback, errorCallback, t1);
        }
      }
    },
    _wrapJsFunctionForAsync($function) {
      var $protected = function(fn, ERROR) {
        return function(errorCode, result) {
          while (true) {
            try {
              fn(errorCode, result);
              break;
            } catch (error) {
              result = error;
              errorCode = ERROR;
            }
          }
        };
      }($function, 1);
      return $.Zone__current.registerBinaryCallback$3$1(new A._wrapJsFunctionForAsync_closure($protected), type$.void, type$.int, type$.dynamic);
    },
    AsyncError_defaultStackTrace(error) {
      var stackTrace;
      if (type$.Error._is(error)) {
        stackTrace = error.get$stackTrace();
        if (stackTrace != null)
          return stackTrace;
      }
      return B.C__StringStackTrace;
    },
    Future_Future$sync(computation, $T) {
      var error, stackTrace, exception, t1, t2, t3, t4, result = null;
      try {
        result = computation.call$0();
      } catch (exception) {
        error = A.unwrapException(exception);
        stackTrace = A.getTraceFromException(exception);
        t1 = new A._Future($.Zone__current, $T._eval$1("_Future<0>"));
        t2 = error;
        t3 = stackTrace;
        t4 = A._interceptError(t2, t3);
        if (t4 == null)
          t2 = new A.AsyncError(t2, t3 == null ? A.AsyncError_defaultStackTrace(t2) : t3);
        else
          t2 = t4;
        t1._asyncCompleteErrorObject$1(t2);
        return t1;
      }
      return $T._eval$1("Future<0>")._is(result) ? result : A._Future$value(result, $T);
    },
    Future_Future$value(value, $T) {
      var t1 = value == null ? $T._as(value) : value,
        t2 = new A._Future($.Zone__current, $T._eval$1("_Future<0>"));
      t2._asyncComplete$1(t1);
      return t2;
    },
    Future_Future$delayed(duration, computation, $T) {
      var result;
      if (computation == null && !$T._is(null))
        throw A.wrapException(A.ArgumentError$value(null, "computation", "The type parameter is not nullable"));
      result = new A._Future($.Zone__current, $T._eval$1("_Future<0>"));
      A.Timer_Timer(duration, new A.Future_Future$delayed_closure(computation, result, $T));
      return result;
    },
    Future_wait(futures, $T) {
      var handleError, future, pos, e, s, t1, t2, _i, t3, exception, t4, _box_0 = {}, cleanUp = null,
        eagerError = false,
        _future = new A._Future($.Zone__current, $T._eval$1("_Future<List<0>>"));
      _box_0.values = null;
      _box_0.remaining = 0;
      _box_0.stackTrace = _box_0.error = null;
      handleError = new A.Future_wait_handleError(_box_0, cleanUp, eagerError, _future);
      try {
        for (t1 = futures.length, t2 = type$.Null, _i = 0, t3 = 0; _i < futures.length; futures.length === t1 || (0, A.throwConcurrentModificationError)(futures), ++_i) {
          future = futures[_i];
          pos = t3;
          future.then$1$2$onError(new A.Future_wait_closure(_box_0, pos, _future, $T, cleanUp, eagerError), handleError, t2);
          t3 = ++_box_0.remaining;
        }
        if (t3 === 0) {
          t1 = _future;
          t1._completeWithValue$1(A._setArrayType([], $T._eval$1("JSArray<0>")));
          return t1;
        }
        _box_0.values = A.List_List$filled(t3, null, false, $T._eval$1("0?"));
      } catch (exception) {
        e = A.unwrapException(exception);
        s = A.getTraceFromException(exception);
        if (_box_0.remaining === 0 || eagerError) {
          t1 = _future;
          t2 = e;
          t3 = s;
          t4 = A._interceptError(t2, t3);
          if (t4 == null)
            t2 = new A.AsyncError(t2, t3 == null ? A.AsyncError_defaultStackTrace(t2) : t3);
          else
            t2 = t4;
          t1._asyncCompleteErrorObject$1(t2);
          return t1;
        } else {
          _box_0.error = e;
          _box_0.stackTrace = s;
        }
      }
      return _future;
    },
    _interceptError(error, stackTrace) {
      var replacement, t1, t2,
        zone = $.Zone__current;
      if (zone === B.C__RootZone)
        return null;
      replacement = zone.errorCallback$2(error, stackTrace);
      if (replacement == null)
        return null;
      t1 = replacement.error;
      t2 = replacement.stackTrace;
      if (type$.Error._is(t1))
        A.Primitives_trySetStackTrace(t1, t2);
      return replacement;
    },
    _interceptUserError(error, stackTrace) {
      var replacement;
      if ($.Zone__current !== B.C__RootZone) {
        replacement = A._interceptError(error, stackTrace);
        if (replacement != null)
          return replacement;
      }
      if (stackTrace == null)
        if (type$.Error._is(error)) {
          stackTrace = error.get$stackTrace();
          if (stackTrace == null) {
            A.Primitives_trySetStackTrace(error, B.C__StringStackTrace);
            stackTrace = B.C__StringStackTrace;
          }
        } else
          stackTrace = B.C__StringStackTrace;
      else if (type$.Error._is(error))
        A.Primitives_trySetStackTrace(error, stackTrace);
      return new A.AsyncError(error, stackTrace);
    },
    _Future$zoneValue(value, _zone, $T) {
      var t1 = new A._Future(_zone, $T._eval$1("_Future<0>"));
      $T._as(value);
      t1._state = 8;
      t1._resultOrListeners = value;
      return t1;
    },
    _Future$value(value, $T) {
      var t1 = new A._Future($.Zone__current, $T._eval$1("_Future<0>"));
      $T._as(value);
      t1._state = 8;
      t1._resultOrListeners = value;
      return t1;
    },
    _Future__chainCoreFuture(source, target, sync) {
      var t2, t3, ignoreError, listeners, _box_0 = {},
        t1 = _box_0.source = source;
      for (t2 = type$._Future_dynamic; t3 = t1._state, (t3 & 4) !== 0; t1 = source) {
        source = t2._as(t1._resultOrListeners);
        _box_0.source = source;
      }
      if (t1 === target) {
        t2 = A.StackTrace_current();
        target._asyncCompleteErrorObject$1(new A.AsyncError(new A.ArgumentError(true, t1, null, "Cannot complete a future with itself"), t2));
        return;
      }
      ignoreError = target._state & 1;
      t2 = t1._state = t3 | ignoreError;
      if ((t2 & 24) === 0) {
        listeners = type$.nullable__FutureListener_dynamic_dynamic._as(target._resultOrListeners);
        target._state = target._state & 1 | 4;
        target._resultOrListeners = t1;
        t1._prependListeners$1(listeners);
        return;
      }
      if (!sync)
        if (target._resultOrListeners == null)
          t1 = (t2 & 16) === 0 || ignoreError !== 0;
        else
          t1 = false;
      else
        t1 = true;
      if (t1) {
        listeners = target._removeListeners$0();
        target._cloneResult$1(_box_0.source);
        A._Future__propagateToListeners(target, listeners);
        return;
      }
      target._state ^= 2;
      target._zone.scheduleMicrotask$1(new A._Future__chainCoreFuture_closure(_box_0, target));
    },
    _Future__propagateToListeners(source, listeners) {
      var t2, t3, _box_0, t4, t5, hasError, asyncError, nextListener, nextListener0, sourceResult, t6, zone, oldZone, result, current, _box_1 = {},
        t1 = _box_1.source = source;
      for (t2 = type$.AsyncError, t3 = type$.nullable__FutureListener_dynamic_dynamic; true;) {
        _box_0 = {};
        t4 = t1._state;
        t5 = (t4 & 16) === 0;
        hasError = !t5;
        if (listeners == null) {
          if (hasError && (t4 & 1) === 0) {
            asyncError = t2._as(t1._resultOrListeners);
            t1._zone.handleUncaughtError$2(asyncError.error, asyncError.stackTrace);
          }
          return;
        }
        _box_0.listener = listeners;
        nextListener = listeners._nextListener;
        for (t1 = listeners; nextListener != null; t1 = nextListener, nextListener = nextListener0) {
          t1._nextListener = null;
          A._Future__propagateToListeners(_box_1.source, t1);
          _box_0.listener = nextListener;
          nextListener0 = nextListener._nextListener;
        }
        t4 = _box_1.source;
        sourceResult = t4._resultOrListeners;
        _box_0.listenerHasError = hasError;
        _box_0.listenerValueOrError = sourceResult;
        if (t5) {
          t6 = t1.state;
          t6 = (t6 & 1) !== 0 || (t6 & 15) === 8;
        } else
          t6 = true;
        if (t6) {
          zone = t1.result._zone;
          if (hasError) {
            t1 = t4._zone;
            t1 = !(t1 === zone || t1.get$errorZone() === zone.get$errorZone());
          } else
            t1 = false;
          if (t1) {
            t1 = _box_1.source;
            asyncError = t2._as(t1._resultOrListeners);
            t1._zone.handleUncaughtError$2(asyncError.error, asyncError.stackTrace);
            return;
          }
          oldZone = $.Zone__current;
          if (oldZone !== zone)
            $.Zone__current = zone;
          else
            oldZone = null;
          t1 = _box_0.listener.state;
          if ((t1 & 15) === 8)
            new A._Future__propagateToListeners_handleWhenCompleteCallback(_box_0, _box_1, hasError).call$0();
          else if (t5) {
            if ((t1 & 1) !== 0)
              new A._Future__propagateToListeners_handleValueCallback(_box_0, sourceResult).call$0();
          } else if ((t1 & 2) !== 0)
            new A._Future__propagateToListeners_handleError(_box_1, _box_0).call$0();
          if (oldZone != null)
            $.Zone__current = oldZone;
          t1 = _box_0.listenerValueOrError;
          if (t1 instanceof A._Future) {
            t4 = _box_0.listener.$ti;
            t4 = t4._eval$1("Future<2>")._is(t1) || !t4._rest[1]._is(t1);
          } else
            t4 = false;
          if (t4) {
            result = _box_0.listener.result;
            if ((t1._state & 24) !== 0) {
              current = t3._as(result._resultOrListeners);
              result._resultOrListeners = null;
              listeners = result._reverseListeners$1(current);
              result._state = t1._state & 30 | result._state & 1;
              result._resultOrListeners = t1._resultOrListeners;
              _box_1.source = t1;
              continue;
            } else
              A._Future__chainCoreFuture(t1, result, true);
            return;
          }
        }
        result = _box_0.listener.result;
        current = t3._as(result._resultOrListeners);
        result._resultOrListeners = null;
        listeners = result._reverseListeners$1(current);
        t1 = _box_0.listenerHasError;
        t4 = _box_0.listenerValueOrError;
        if (!t1) {
          result.$ti._precomputed1._as(t4);
          result._state = 8;
          result._resultOrListeners = t4;
        } else {
          t2._as(t4);
          result._state = result._state & 1 | 16;
          result._resultOrListeners = t4;
        }
        _box_1.source = result;
        t1 = result;
      }
    },
    _registerErrorHandler(errorHandler, zone) {
      if (type$.dynamic_Function_Object_StackTrace._is(errorHandler))
        return zone.registerBinaryCallback$3$1(errorHandler, type$.dynamic, type$.Object, type$.StackTrace);
      if (type$.dynamic_Function_Object._is(errorHandler))
        return zone.registerUnaryCallback$2$1(errorHandler, type$.dynamic, type$.Object);
      throw A.wrapException(A.ArgumentError$value(errorHandler, "onError", string$.Error_));
    },
    _microtaskLoop() {
      var entry, next;
      for (entry = $._nextCallback; entry != null; entry = $._nextCallback) {
        $._lastPriorityCallback = null;
        next = entry.next;
        $._nextCallback = next;
        if (next == null)
          $._lastCallback = null;
        entry.callback.call$0();
      }
    },
    _startMicrotaskLoop() {
      $._isInCallbackLoop = true;
      try {
        A._microtaskLoop();
      } finally {
        $._lastPriorityCallback = null;
        $._isInCallbackLoop = false;
        if ($._nextCallback != null)
          $.$get$_AsyncRun__scheduleImmediateClosure().call$1(A.async___startMicrotaskLoop$closure());
      }
    },
    _scheduleAsyncCallback(callback) {
      var newEntry = new A._AsyncCallbackEntry(callback),
        lastCallback = $._lastCallback;
      if (lastCallback == null) {
        $._nextCallback = $._lastCallback = newEntry;
        if (!$._isInCallbackLoop)
          $.$get$_AsyncRun__scheduleImmediateClosure().call$1(A.async___startMicrotaskLoop$closure());
      } else
        $._lastCallback = lastCallback.next = newEntry;
    },
    _schedulePriorityAsyncCallback(callback) {
      var entry, lastPriorityCallback, next,
        t1 = $._nextCallback;
      if (t1 == null) {
        A._scheduleAsyncCallback(callback);
        $._lastPriorityCallback = $._lastCallback;
        return;
      }
      entry = new A._AsyncCallbackEntry(callback);
      lastPriorityCallback = $._lastPriorityCallback;
      if (lastPriorityCallback == null) {
        entry.next = t1;
        $._nextCallback = $._lastPriorityCallback = entry;
      } else {
        next = lastPriorityCallback.next;
        entry.next = next;
        $._lastPriorityCallback = lastPriorityCallback.next = entry;
        if (next == null)
          $._lastCallback = entry;
      }
    },
    scheduleMicrotask(callback) {
      var t1, _null = null,
        currentZone = $.Zone__current;
      if (B.C__RootZone === currentZone) {
        A._rootScheduleMicrotask(_null, _null, B.C__RootZone, callback);
        return;
      }
      if (B.C__RootZone === currentZone.get$_scheduleMicrotask().zone)
        t1 = B.C__RootZone.get$errorZone() === currentZone.get$errorZone();
      else
        t1 = false;
      if (t1) {
        A._rootScheduleMicrotask(_null, _null, currentZone, currentZone.registerCallback$1$1(callback, type$.void));
        return;
      }
      t1 = $.Zone__current;
      t1.scheduleMicrotask$1(t1.bindCallbackGuarded$1(callback));
    },
    StreamIterator_StreamIterator(stream, $T) {
      return new A._StreamIterator(A.checkNotNullable(stream, "stream", type$.Object), $T._eval$1("_StreamIterator<0>"));
    },
    StreamController_StreamController(sync, $T) {
      var _null = null;
      return new A._SyncStreamController(_null, _null, _null, _null, $T._eval$1("_SyncStreamController<0>"));
    },
    _runGuarded(notificationHandler) {
      return;
    },
    _BufferingStreamSubscription__registerErrorHandler(zone, handleError) {
      if (handleError == null)
        handleError = A.async___nullErrorHandler$closure();
      if (type$.void_Function_Object_StackTrace._is(handleError))
        return zone.registerBinaryCallback$3$1(handleError, type$.dynamic, type$.Object, type$.StackTrace);
      if (type$.void_Function_Object._is(handleError))
        return zone.registerUnaryCallback$2$1(handleError, type$.dynamic, type$.Object);
      throw A.wrapException(A.ArgumentError$("handleError callback must take either an Object (the error), or both an Object (the error) and a StackTrace.", null));
    },
    _nullErrorHandler(error, stackTrace) {
      type$.Object._as(error);
      type$.StackTrace._as(stackTrace);
      $.Zone__current.handleUncaughtError$2(error, stackTrace);
    },
    Timer_Timer(duration, callback) {
      var t1 = $.Zone__current;
      if (t1 === B.C__RootZone)
        return t1.createTimer$2(duration, callback);
      return t1.createTimer$2(duration, t1.bindCallbackGuarded$1(callback));
    },
    _rootHandleError(error, stackTrace) {
      A._schedulePriorityAsyncCallback(new A._rootHandleError_closure(error, stackTrace));
    },
    _rootRun($self, $parent, zone, f, $R) {
      var old, t1;
      type$.nullable_Zone._as($self);
      type$.nullable_ZoneDelegate._as($parent);
      type$.Zone._as(zone);
      $R._eval$1("0()")._as(f);
      t1 = $.Zone__current;
      if (t1 === zone)
        return f.call$0();
      $.Zone__current = zone;
      old = t1;
      try {
        t1 = f.call$0();
        return t1;
      } finally {
        $.Zone__current = old;
      }
    },
    _rootRunUnary($self, $parent, zone, f, arg, $R, $T) {
      var old, t1;
      type$.nullable_Zone._as($self);
      type$.nullable_ZoneDelegate._as($parent);
      type$.Zone._as(zone);
      $R._eval$1("@<0>")._bind$1($T)._eval$1("1(2)")._as(f);
      $T._as(arg);
      t1 = $.Zone__current;
      if (t1 === zone)
        return f.call$1(arg);
      $.Zone__current = zone;
      old = t1;
      try {
        t1 = f.call$1(arg);
        return t1;
      } finally {
        $.Zone__current = old;
      }
    },
    _rootRunBinary($self, $parent, zone, f, arg1, arg2, $R, T1, T2) {
      var old, t1;
      type$.nullable_Zone._as($self);
      type$.nullable_ZoneDelegate._as($parent);
      type$.Zone._as(zone);
      $R._eval$1("@<0>")._bind$1(T1)._bind$1(T2)._eval$1("1(2,3)")._as(f);
      T1._as(arg1);
      T2._as(arg2);
      t1 = $.Zone__current;
      if (t1 === zone)
        return f.call$2(arg1, arg2);
      $.Zone__current = zone;
      old = t1;
      try {
        t1 = f.call$2(arg1, arg2);
        return t1;
      } finally {
        $.Zone__current = old;
      }
    },
    _rootScheduleMicrotask($self, $parent, zone, f) {
      var t1, t2;
      type$.void_Function._as(f);
      if (B.C__RootZone !== zone) {
        t1 = B.C__RootZone.get$errorZone();
        t2 = zone.get$errorZone();
        f = t1 !== t2 ? zone.bindCallbackGuarded$1(f) : zone.bindCallback$1$1(f, type$.void);
      }
      A._scheduleAsyncCallback(f);
    },
    _AsyncRun__initializeScheduleImmediate_internalCallback: function _AsyncRun__initializeScheduleImmediate_internalCallback(t0) {
      this._box_0 = t0;
    },
    _AsyncRun__initializeScheduleImmediate_closure: function _AsyncRun__initializeScheduleImmediate_closure(t0, t1, t2) {
      this._box_0 = t0;
      this.div = t1;
      this.span = t2;
    },
    _AsyncRun__scheduleImmediateJsOverride_internalCallback: function _AsyncRun__scheduleImmediateJsOverride_internalCallback(t0) {
      this.callback = t0;
    },
    _AsyncRun__scheduleImmediateWithSetImmediate_internalCallback: function _AsyncRun__scheduleImmediateWithSetImmediate_internalCallback(t0) {
      this.callback = t0;
    },
    _TimerImpl: function _TimerImpl(t0) {
      this._once = t0;
      this._handle = null;
      this._tick = 0;
    },
    _TimerImpl_internalCallback: function _TimerImpl_internalCallback(t0, t1) {
      this.$this = t0;
      this.callback = t1;
    },
    _AsyncAwaitCompleter: function _AsyncAwaitCompleter(t0, t1) {
      this._future = t0;
      this.isSync = false;
      this.$ti = t1;
    },
    _awaitOnObject_closure: function _awaitOnObject_closure(t0) {
      this.bodyFunction = t0;
    },
    _awaitOnObject_closure0: function _awaitOnObject_closure0(t0) {
      this.bodyFunction = t0;
    },
    _wrapJsFunctionForAsync_closure: function _wrapJsFunctionForAsync_closure(t0) {
      this.$protected = t0;
    },
    AsyncError: function AsyncError(t0, t1) {
      this.error = t0;
      this.stackTrace = t1;
    },
    Future_Future$delayed_closure: function Future_Future$delayed_closure(t0, t1, t2) {
      this.computation = t0;
      this.result = t1;
      this.T = t2;
    },
    Future_wait_handleError: function Future_wait_handleError(t0, t1, t2, t3) {
      var _ = this;
      _._box_0 = t0;
      _.cleanUp = t1;
      _.eagerError = t2;
      _._future = t3;
    },
    Future_wait_closure: function Future_wait_closure(t0, t1, t2, t3, t4, t5) {
      var _ = this;
      _._box_0 = t0;
      _.pos = t1;
      _._future = t2;
      _.T = t3;
      _.cleanUp = t4;
      _.eagerError = t5;
    },
    _Completer: function _Completer() {
    },
    _AsyncCompleter: function _AsyncCompleter(t0, t1) {
      this.future = t0;
      this.$ti = t1;
    },
    _SyncCompleter: function _SyncCompleter(t0, t1) {
      this.future = t0;
      this.$ti = t1;
    },
    _FutureListener: function _FutureListener(t0, t1, t2, t3, t4) {
      var _ = this;
      _._nextListener = null;
      _.result = t0;
      _.state = t1;
      _.callback = t2;
      _.errorCallback = t3;
      _.$ti = t4;
    },
    _Future: function _Future(t0, t1) {
      var _ = this;
      _._state = 0;
      _._zone = t0;
      _._resultOrListeners = null;
      _.$ti = t1;
    },
    _Future__addListener_closure: function _Future__addListener_closure(t0, t1) {
      this.$this = t0;
      this.listener = t1;
    },
    _Future__prependListeners_closure: function _Future__prependListeners_closure(t0, t1) {
      this._box_0 = t0;
      this.$this = t1;
    },
    _Future__chainCoreFuture_closure: function _Future__chainCoreFuture_closure(t0, t1) {
      this._box_0 = t0;
      this.target = t1;
    },
    _Future__asyncCompleteWithValue_closure: function _Future__asyncCompleteWithValue_closure(t0, t1) {
      this.$this = t0;
      this.value = t1;
    },
    _Future__asyncCompleteErrorObject_closure: function _Future__asyncCompleteErrorObject_closure(t0, t1) {
      this.$this = t0;
      this.error = t1;
    },
    _Future__propagateToListeners_handleWhenCompleteCallback: function _Future__propagateToListeners_handleWhenCompleteCallback(t0, t1, t2) {
      this._box_0 = t0;
      this._box_1 = t1;
      this.hasError = t2;
    },
    _Future__propagateToListeners_handleWhenCompleteCallback_closure: function _Future__propagateToListeners_handleWhenCompleteCallback_closure(t0, t1) {
      this.joinedResult = t0;
      this.originalSource = t1;
    },
    _Future__propagateToListeners_handleWhenCompleteCallback_closure0: function _Future__propagateToListeners_handleWhenCompleteCallback_closure0(t0) {
      this.joinedResult = t0;
    },
    _Future__propagateToListeners_handleValueCallback: function _Future__propagateToListeners_handleValueCallback(t0, t1) {
      this._box_0 = t0;
      this.sourceResult = t1;
    },
    _Future__propagateToListeners_handleError: function _Future__propagateToListeners_handleError(t0, t1) {
      this._box_1 = t0;
      this._box_0 = t1;
    },
    _AsyncCallbackEntry: function _AsyncCallbackEntry(t0) {
      this.callback = t0;
      this.next = null;
    },
    Stream: function Stream() {
    },
    Stream_length_closure: function Stream_length_closure(t0, t1) {
      this._box_0 = t0;
      this.$this = t1;
    },
    Stream_length_closure0: function Stream_length_closure0(t0, t1) {
      this._box_0 = t0;
      this.future = t1;
    },
    _StreamController: function _StreamController() {
    },
    _StreamController__subscribe_closure: function _StreamController__subscribe_closure(t0) {
      this.$this = t0;
    },
    _StreamController__recordCancel_complete: function _StreamController__recordCancel_complete(t0) {
      this.$this = t0;
    },
    _SyncStreamControllerDispatch: function _SyncStreamControllerDispatch() {
    },
    _SyncStreamController: function _SyncStreamController(t0, t1, t2, t3, t4) {
      var _ = this;
      _._varData = null;
      _._state = 0;
      _._doneFuture = null;
      _.onListen = t0;
      _.onPause = t1;
      _.onResume = t2;
      _.onCancel = t3;
      _.$ti = t4;
    },
    _ControllerStream: function _ControllerStream(t0, t1) {
      this._controller = t0;
      this.$ti = t1;
    },
    _ControllerSubscription: function _ControllerSubscription(t0, t1, t2, t3, t4, t5, t6) {
      var _ = this;
      _._controller = t0;
      _._onData = t1;
      _._onError = t2;
      _._onDone = t3;
      _._zone = t4;
      _._state = t5;
      _._pending = _._cancelFuture = null;
      _.$ti = t6;
    },
    _BufferingStreamSubscription: function _BufferingStreamSubscription() {
    },
    _BufferingStreamSubscription__sendError_sendError: function _BufferingStreamSubscription__sendError_sendError(t0, t1, t2) {
      this.$this = t0;
      this.error = t1;
      this.stackTrace = t2;
    },
    _BufferingStreamSubscription__sendDone_sendDone: function _BufferingStreamSubscription__sendDone_sendDone(t0) {
      this.$this = t0;
    },
    _StreamImpl: function _StreamImpl() {
    },
    _DelayedEvent: function _DelayedEvent() {
    },
    _DelayedData: function _DelayedData(t0, t1) {
      this.value = t0;
      this.next = null;
      this.$ti = t1;
    },
    _DelayedError: function _DelayedError(t0, t1) {
      this.error = t0;
      this.stackTrace = t1;
      this.next = null;
    },
    _DelayedDone: function _DelayedDone() {
    },
    _PendingEvents: function _PendingEvents(t0) {
      var _ = this;
      _._state = 0;
      _.lastPendingEvent = _.firstPendingEvent = null;
      _.$ti = t0;
    },
    _PendingEvents_schedule_closure: function _PendingEvents_schedule_closure(t0, t1) {
      this.$this = t0;
      this.dispatch = t1;
    },
    _StreamIterator: function _StreamIterator(t0, t1) {
      var _ = this;
      _._subscription = null;
      _._stateData = t0;
      _._async$_hasValue = false;
      _.$ti = t1;
    },
    _ZoneFunction: function _ZoneFunction(t0, t1, t2) {
      this.zone = t0;
      this.$function = t1;
      this.$ti = t2;
    },
    _Zone: function _Zone() {
    },
    _rootHandleError_closure: function _rootHandleError_closure(t0, t1) {
      this.error = t0;
      this.stackTrace = t1;
    },
    _RootZone: function _RootZone() {
    },
    _RootZone_bindCallback_closure: function _RootZone_bindCallback_closure(t0, t1, t2) {
      this.$this = t0;
      this.f = t1;
      this.R = t2;
    },
    _RootZone_bindCallbackGuarded_closure: function _RootZone_bindCallbackGuarded_closure(t0, t1) {
      this.$this = t0;
      this.f = t1;
    },
    _RootZone_bindUnaryCallbackGuarded_closure: function _RootZone_bindUnaryCallbackGuarded_closure(t0, t1, t2) {
      this.$this = t0;
      this.f = t1;
      this.T = t2;
    },
    HashMap_HashMap(equals, hashCode, isValidKey, $K, $V) {
      if (isValidKey == null)
        if (hashCode == null) {
          if (equals == null)
            return new A._HashMap($K._eval$1("@<0>")._bind$1($V)._eval$1("_HashMap<1,2>"));
          hashCode = A.collection___defaultHashCode$closure();
        } else {
          if (A.core__identityHashCode$closure() === hashCode && A.core__identical$closure() === equals)
            return new A._IdentityHashMap($K._eval$1("@<0>")._bind$1($V)._eval$1("_IdentityHashMap<1,2>"));
          if (equals == null)
            equals = A.collection___defaultEquals$closure();
        }
      else {
        if (hashCode == null)
          hashCode = A.collection___defaultHashCode$closure();
        if (equals == null)
          equals = A.collection___defaultEquals$closure();
      }
      return A._CustomHashMap$(equals, hashCode, isValidKey, $K, $V);
    },
    _HashMap__getTableEntry(table, key) {
      var entry = table[key];
      return entry === table ? null : entry;
    },
    _HashMap__setTableEntry(table, key, value) {
      if (value == null)
        table[key] = table;
      else
        table[key] = value;
    },
    _HashMap__newHashTable() {
      var table = Object.create(null);
      A._HashMap__setTableEntry(table, "<non-identifier-key>", table);
      delete table["<non-identifier-key>"];
      return table;
    },
    _CustomHashMap$(_equals, _hashCode, validKey, $K, $V) {
      var t1 = validKey != null ? validKey : new A._CustomHashMap_closure($K);
      return new A._CustomHashMap(_equals, _hashCode, t1, $K._eval$1("@<0>")._bind$1($V)._eval$1("_CustomHashMap<1,2>"));
    },
    LinkedHashMap_LinkedHashMap($K, $V) {
      return new A.JsLinkedHashMap($K._eval$1("@<0>")._bind$1($V)._eval$1("JsLinkedHashMap<1,2>"));
    },
    LinkedHashMap_LinkedHashMap$_literal(keyValuePairs, $K, $V) {
      return $K._eval$1("@<0>")._bind$1($V)._eval$1("LinkedHashMap<1,2>")._as(A.fillLiteralMap(keyValuePairs, new A.JsLinkedHashMap($K._eval$1("@<0>")._bind$1($V)._eval$1("JsLinkedHashMap<1,2>"))));
    },
    LinkedHashMap_LinkedHashMap$_empty($K, $V) {
      return new A.JsLinkedHashMap($K._eval$1("@<0>")._bind$1($V)._eval$1("JsLinkedHashMap<1,2>"));
    },
    LinkedHashSet_LinkedHashSet($E) {
      return new A._LinkedHashSet($E._eval$1("_LinkedHashSet<0>"));
    },
    _LinkedHashSet__newHashTable() {
      var table = Object.create(null);
      table["<non-identifier-key>"] = table;
      delete table["<non-identifier-key>"];
      return table;
    },
    _LinkedHashSetIterator$(_set, _modifications, $E) {
      var t1 = new A._LinkedHashSetIterator(_set, _modifications, $E._eval$1("_LinkedHashSetIterator<0>"));
      t1._collection$_cell = _set._collection$_first;
      return t1;
    },
    _defaultEquals(a, b) {
      return J.$eq$(a, b);
    },
    _defaultHashCode(a) {
      return J.get$hashCode$(a);
    },
    LinkedHashMap_LinkedHashMap$from(other, $K, $V) {
      var result = A.LinkedHashMap_LinkedHashMap($K, $V);
      other.forEach$1(0, new A.LinkedHashMap_LinkedHashMap$from_closure(result, $K, $V));
      return result;
    },
    LinkedHashSet_LinkedHashSet$from(elements, $E) {
      var t1, t2, element,
        result = A.LinkedHashSet_LinkedHashSet($E);
      for (t1 = A._LinkedHashSetIterator$(elements, elements._collection$_modifications, A._instanceType(elements)._precomputed1), t2 = t1.$ti._precomputed1; t1.moveNext$0();) {
        element = t1._collection$_current;
        result.add$1(0, $E._as(element == null ? t2._as(element) : element));
      }
      return result;
    },
    MapBase_mapToString(m) {
      var result, t1;
      if (A.isToStringVisiting(m))
        return "{...}";
      result = new A.StringBuffer("");
      try {
        t1 = {};
        B.JSArray_methods.add$1($.toStringVisiting, m);
        result._contents += "{";
        t1.first = true;
        m.forEach$1(0, new A.MapBase_mapToString_closure(t1, result));
        result._contents += "}";
      } finally {
        if (0 >= $.toStringVisiting.length)
          return A.ioore($.toStringVisiting, -1);
        $.toStringVisiting.pop();
      }
      t1 = result._contents;
      return t1.charCodeAt(0) == 0 ? t1 : t1;
    },
    SplayTreeMap$(compare, $K, $V) {
      return new A.SplayTreeMap(compare, $K._eval$1("@<0>")._bind$1($V)._eval$1("SplayTreeMap<1,2>"));
    },
    _HashMap: function _HashMap(t0) {
      var _ = this;
      _._collection$_length = 0;
      _._keys = _._collection$_rest = _._collection$_nums = _._collection$_strings = null;
      _.$ti = t0;
    },
    _HashMap_values_closure: function _HashMap_values_closure(t0) {
      this.$this = t0;
    },
    _IdentityHashMap: function _IdentityHashMap(t0) {
      var _ = this;
      _._collection$_length = 0;
      _._keys = _._collection$_rest = _._collection$_nums = _._collection$_strings = null;
      _.$ti = t0;
    },
    _CustomHashMap: function _CustomHashMap(t0, t1, t2, t3) {
      var _ = this;
      _._equals = t0;
      _._hashCode = t1;
      _._validKey = t2;
      _._collection$_length = 0;
      _._keys = _._collection$_rest = _._collection$_nums = _._collection$_strings = null;
      _.$ti = t3;
    },
    _CustomHashMap_closure: function _CustomHashMap_closure(t0) {
      this.K = t0;
    },
    _HashMapKeyIterable: function _HashMapKeyIterable(t0, t1) {
      this._collection$_map = t0;
      this.$ti = t1;
    },
    _HashMapKeyIterator: function _HashMapKeyIterator(t0, t1, t2) {
      var _ = this;
      _._collection$_map = t0;
      _._keys = t1;
      _._offset = 0;
      _._collection$_current = null;
      _.$ti = t2;
    },
    _LinkedHashSet: function _LinkedHashSet(t0) {
      var _ = this;
      _._collection$_length = 0;
      _._collection$_last = _._collection$_first = _._collection$_rest = _._collection$_nums = _._collection$_strings = null;
      _._collection$_modifications = 0;
      _.$ti = t0;
    },
    _LinkedHashSetCell: function _LinkedHashSetCell(t0) {
      this._element = t0;
      this._collection$_next = null;
    },
    _LinkedHashSetIterator: function _LinkedHashSetIterator(t0, t1, t2) {
      var _ = this;
      _._set = t0;
      _._collection$_modifications = t1;
      _._collection$_current = _._collection$_cell = null;
      _.$ti = t2;
    },
    LinkedHashMap_LinkedHashMap$from_closure: function LinkedHashMap_LinkedHashMap$from_closure(t0, t1, t2) {
      this.result = t0;
      this.K = t1;
      this.V = t2;
    },
    ListBase: function ListBase() {
    },
    MapBase: function MapBase() {
    },
    MapBase_mapToString_closure: function MapBase_mapToString_closure(t0, t1) {
      this._box_0 = t0;
      this.result = t1;
    },
    _MapBaseValueIterable: function _MapBaseValueIterable(t0, t1) {
      this._collection$_map = t0;
      this.$ti = t1;
    },
    _MapBaseValueIterator: function _MapBaseValueIterator(t0, t1, t2) {
      var _ = this;
      _._keys = t0;
      _._collection$_map = t1;
      _._collection$_current = null;
      _.$ti = t2;
    },
    SetBase: function SetBase() {
    },
    _SetBase: function _SetBase() {
    },
    _SplayTreeNode: function _SplayTreeNode() {
    },
    _SplayTreeMapNode: function _SplayTreeMapNode(t0, t1, t2) {
      var _ = this;
      _.value = t0;
      _.key = t1;
      _._right = _._left = null;
      _.$ti = t2;
    },
    _SplayTree: function _SplayTree() {
    },
    SplayTreeMap: function SplayTreeMap(t0, t1) {
      var _ = this;
      _._root = null;
      _._compare = t0;
      _._splayCount = _._modificationCount = _._count = 0;
      _.$ti = t1;
    },
    _SplayTreeIterator: function _SplayTreeIterator() {
    },
    _SplayTreeKeyIterable: function _SplayTreeKeyIterable(t0, t1) {
      this._tree = t0;
      this.$ti = t1;
    },
    _SplayTreeValueIterable: function _SplayTreeValueIterable(t0, t1) {
      this._collection$_map = t0;
      this.$ti = t1;
    },
    _SplayTreeKeyIterator: function _SplayTreeKeyIterator(t0, t1, t2, t3) {
      var _ = this;
      _._tree = t0;
      _._path = t1;
      _._modificationCount = null;
      _._splayCount = t2;
      _.$ti = t3;
    },
    _SplayTreeValueIterator: function _SplayTreeValueIterator(t0, t1, t2, t3) {
      var _ = this;
      _._collection$_current = null;
      _._tree = t0;
      _._path = t1;
      _._modificationCount = null;
      _._splayCount = t2;
      _.$ti = t3;
    },
    _SplayTreeMapEntryIterator: function _SplayTreeMapEntryIterator(t0, t1, t2, t3) {
      var _ = this;
      _._collection$_current = null;
      _._tree = t0;
      _._path = t1;
      _._modificationCount = null;
      _._splayCount = t2;
      _.$ti = t3;
    },
    _SplayTreeMap__SplayTree_MapMixin: function _SplayTreeMap__SplayTree_MapMixin() {
    },
    _Base64Encoder_encodeChunk(alphabet, bytes, start, end, isLast, output, outputIndex, state) {
      var t1, t2, t3, i, byteOr, byte, outputIndex0, t4, t5, outputIndex1,
        bits = state >>> 2,
        expectedChars = 3 - (state & 3);
      for (t1 = J.getInterceptor$asx(bytes), t2 = alphabet.length, t3 = output.$flags | 0, i = start, byteOr = 0; i < end; ++i) {
        byte = t1.$index(bytes, i);
        byteOr = (byteOr | byte) >>> 0;
        bits = (bits << 8 | byte) & 16777215;
        --expectedChars;
        if (expectedChars === 0) {
          outputIndex0 = outputIndex + 1;
          t4 = bits >>> 18 & 63;
          if (!(t4 < t2))
            return A.ioore(alphabet, t4);
          t3 & 2 && A.throwUnsupportedOperation(output);
          t5 = output.length;
          if (!(outputIndex < t5))
            return A.ioore(output, outputIndex);
          output[outputIndex] = alphabet.charCodeAt(t4);
          outputIndex = outputIndex0 + 1;
          t4 = bits >>> 12 & 63;
          if (!(t4 < t2))
            return A.ioore(alphabet, t4);
          if (!(outputIndex0 < t5))
            return A.ioore(output, outputIndex0);
          output[outputIndex0] = alphabet.charCodeAt(t4);
          outputIndex0 = outputIndex + 1;
          t4 = bits >>> 6 & 63;
          if (!(t4 < t2))
            return A.ioore(alphabet, t4);
          if (!(outputIndex < t5))
            return A.ioore(output, outputIndex);
          output[outputIndex] = alphabet.charCodeAt(t4);
          outputIndex = outputIndex0 + 1;
          t4 = bits & 63;
          if (!(t4 < t2))
            return A.ioore(alphabet, t4);
          if (!(outputIndex0 < t5))
            return A.ioore(output, outputIndex0);
          output[outputIndex0] = alphabet.charCodeAt(t4);
          bits = 0;
          expectedChars = 3;
        }
      }
      if (byteOr >= 0 && byteOr <= 255) {
        if (expectedChars < 3) {
          outputIndex0 = outputIndex + 1;
          outputIndex1 = outputIndex0 + 1;
          if (3 - expectedChars === 1) {
            t1 = bits >>> 2 & 63;
            if (!(t1 < t2))
              return A.ioore(alphabet, t1);
            t3 & 2 && A.throwUnsupportedOperation(output);
            t3 = output.length;
            if (!(outputIndex < t3))
              return A.ioore(output, outputIndex);
            output[outputIndex] = alphabet.charCodeAt(t1);
            t1 = bits << 4 & 63;
            if (!(t1 < t2))
              return A.ioore(alphabet, t1);
            if (!(outputIndex0 < t3))
              return A.ioore(output, outputIndex0);
            output[outputIndex0] = alphabet.charCodeAt(t1);
            outputIndex = outputIndex1 + 1;
            if (!(outputIndex1 < t3))
              return A.ioore(output, outputIndex1);
            output[outputIndex1] = 61;
            if (!(outputIndex < t3))
              return A.ioore(output, outputIndex);
            output[outputIndex] = 61;
          } else {
            t1 = bits >>> 10 & 63;
            if (!(t1 < t2))
              return A.ioore(alphabet, t1);
            t3 & 2 && A.throwUnsupportedOperation(output);
            t3 = output.length;
            if (!(outputIndex < t3))
              return A.ioore(output, outputIndex);
            output[outputIndex] = alphabet.charCodeAt(t1);
            t1 = bits >>> 4 & 63;
            if (!(t1 < t2))
              return A.ioore(alphabet, t1);
            if (!(outputIndex0 < t3))
              return A.ioore(output, outputIndex0);
            output[outputIndex0] = alphabet.charCodeAt(t1);
            outputIndex = outputIndex1 + 1;
            t1 = bits << 2 & 63;
            if (!(t1 < t2))
              return A.ioore(alphabet, t1);
            if (!(outputIndex1 < t3))
              return A.ioore(output, outputIndex1);
            output[outputIndex1] = alphabet.charCodeAt(t1);
            if (!(outputIndex < t3))
              return A.ioore(output, outputIndex);
            output[outputIndex] = 61;
          }
          return 0;
        }
        return (bits << 2 | 3 - expectedChars) >>> 0;
      }
      for (i = start; i < end;) {
        byte = t1.$index(bytes, i);
        if (byte < 0 || byte > 255)
          break;
        ++i;
      }
      throw A.wrapException(A.ArgumentError$value(bytes, "Not a byte value at index " + i + ": 0x" + B.JSInt_methods.toRadixString$1(t1.$index(bytes, i), 16), null));
    },
    _Base64Decoder_decodeChunk(input, start, end, output, outIndex, state) {
      var t1, t2, t3, i, charOr, char, t4, code, outIndex0, expectedPadding,
        _s31_ = "Invalid encoding before padding",
        _s17_ = "Invalid character",
        bits = B.JSInt_methods._shrOtherPositive$1(state, 2),
        count = state & 3,
        inverseAlphabet = $.$get$_Base64Decoder__inverseAlphabet();
      for (t1 = input.length, t2 = inverseAlphabet.length, t3 = output.$flags | 0, i = start, charOr = 0; i < end; ++i) {
        if (!(i < t1))
          return A.ioore(input, i);
        char = input.charCodeAt(i);
        charOr |= char;
        t4 = char & 127;
        if (!(t4 < t2))
          return A.ioore(inverseAlphabet, t4);
        code = inverseAlphabet[t4];
        if (code >= 0) {
          bits = (bits << 6 | code) & 16777215;
          count = count + 1 & 3;
          if (count === 0) {
            outIndex0 = outIndex + 1;
            t3 & 2 && A.throwUnsupportedOperation(output);
            t4 = output.length;
            if (!(outIndex < t4))
              return A.ioore(output, outIndex);
            output[outIndex] = bits >>> 16 & 255;
            outIndex = outIndex0 + 1;
            if (!(outIndex0 < t4))
              return A.ioore(output, outIndex0);
            output[outIndex0] = bits >>> 8 & 255;
            outIndex0 = outIndex + 1;
            if (!(outIndex < t4))
              return A.ioore(output, outIndex);
            output[outIndex] = bits & 255;
            outIndex = outIndex0;
            bits = 0;
          }
          continue;
        } else if (code === -1 && count > 1) {
          if (charOr > 127)
            break;
          if (count === 3) {
            if ((bits & 3) !== 0)
              throw A.wrapException(A.FormatException$(_s31_, input, i));
            outIndex0 = outIndex + 1;
            t3 & 2 && A.throwUnsupportedOperation(output);
            t1 = output.length;
            if (!(outIndex < t1))
              return A.ioore(output, outIndex);
            output[outIndex] = bits >>> 10;
            if (!(outIndex0 < t1))
              return A.ioore(output, outIndex0);
            output[outIndex0] = bits >>> 2;
          } else {
            if ((bits & 15) !== 0)
              throw A.wrapException(A.FormatException$(_s31_, input, i));
            t3 & 2 && A.throwUnsupportedOperation(output);
            if (!(outIndex < output.length))
              return A.ioore(output, outIndex);
            output[outIndex] = bits >>> 4;
          }
          expectedPadding = (3 - count) * 3;
          if (char === 37)
            expectedPadding += 2;
          return A._Base64Decoder__checkPadding(input, i + 1, end, -expectedPadding - 1);
        }
        throw A.wrapException(A.FormatException$(_s17_, input, i));
      }
      if (charOr >= 0 && charOr <= 127)
        return (bits << 2 | count) >>> 0;
      for (i = start; i < end; ++i) {
        if (!(i < t1))
          return A.ioore(input, i);
        if (input.charCodeAt(i) > 127)
          break;
      }
      throw A.wrapException(A.FormatException$(_s17_, input, i));
    },
    _Base64Decoder__allocateBuffer(input, start, end, state) {
      var paddingStart = A._Base64Decoder__trimPaddingChars(input, start, end),
        $length = (state & 3) + (paddingStart - start),
        bufferLength = B.JSInt_methods._shrOtherPositive$1($length, 2) * 3,
        remainderLength = $length & 3;
      if (remainderLength !== 0 && paddingStart < end)
        bufferLength += remainderLength - 1;
      if (bufferLength > 0)
        return new Uint8Array(bufferLength);
      return $.$get$_Base64Decoder__emptyBuffer();
    },
    _Base64Decoder__trimPaddingChars(input, start, end) {
      var char,
        t1 = input.length,
        newEnd = end,
        index = newEnd,
        padding = 0;
      while (true) {
        if (!(index > start && padding < 2))
          break;
        c$0: {
          --index;
          if (!(index >= 0 && index < t1))
            return A.ioore(input, index);
          char = input.charCodeAt(index);
          if (char === 61) {
            ++padding;
            newEnd = index;
            break c$0;
          }
          if ((char | 32) === 100) {
            if (index === start)
              break;
            --index;
            if (!(index >= 0 && index < t1))
              return A.ioore(input, index);
            char = input.charCodeAt(index);
          }
          if (char === 51) {
            if (index === start)
              break;
            --index;
            if (!(index >= 0 && index < t1))
              return A.ioore(input, index);
            char = input.charCodeAt(index);
          }
          if (char === 37) {
            ++padding;
            newEnd = index;
            break c$0;
          }
          break;
        }
      }
      return newEnd;
    },
    _Base64Decoder__checkPadding(input, start, end, state) {
      var expectedPadding, t1, char;
      if (start === end)
        return state;
      expectedPadding = -state - 1;
      for (t1 = input.length; expectedPadding > 0;) {
        if (!(start < t1))
          return A.ioore(input, start);
        char = input.charCodeAt(start);
        if (expectedPadding === 3) {
          if (char === 61) {
            expectedPadding -= 3;
            ++start;
            break;
          }
          if (char === 37) {
            --expectedPadding;
            ++start;
            if (start === end)
              break;
            if (!(start < t1))
              return A.ioore(input, start);
            char = input.charCodeAt(start);
          } else
            break;
        }
        if ((expectedPadding > 3 ? expectedPadding - 3 : expectedPadding) === 2) {
          if (char !== 51)
            break;
          ++start;
          --expectedPadding;
          if (start === end)
            break;
          if (!(start < t1))
            return A.ioore(input, start);
          char = input.charCodeAt(start);
        }
        if ((char | 32) !== 100)
          break;
        ++start;
        --expectedPadding;
        if (start === end)
          break;
      }
      if (start !== end)
        throw A.wrapException(A.FormatException$("Invalid padding character", input, start));
      return -expectedPadding - 1;
    },
    JsonUnsupportedObjectError$(unsupportedObject, cause, partialResult) {
      return new A.JsonUnsupportedObjectError(unsupportedObject, cause);
    },
    _defaultToEncodable(object) {
      return object.toJson$0();
    },
    _JsonStringStringifier$(_sink, _toEncodable) {
      return new A._JsonStringStringifier(_sink, [], A.convert___defaultToEncodable$closure());
    },
    _JsonStringStringifier_stringify(object, toEncodable, indent) {
      var t1,
        output = new A.StringBuffer(""),
        stringifier = A._JsonStringStringifier$(output, toEncodable);
      stringifier.writeObject$1(object);
      t1 = output._contents;
      return t1.charCodeAt(0) == 0 ? t1 : t1;
    },
    Base64Codec: function Base64Codec() {
    },
    Base64Encoder: function Base64Encoder() {
    },
    _Base64Encoder: function _Base64Encoder(t0) {
      this._convert$_state = 0;
      this._alphabet = t0;
    },
    Base64Decoder: function Base64Decoder() {
    },
    _Base64Decoder: function _Base64Decoder() {
      this._convert$_state = 0;
    },
    Codec: function Codec() {
    },
    Converter: function Converter() {
    },
    JsonUnsupportedObjectError: function JsonUnsupportedObjectError(t0, t1) {
      this.unsupportedObject = t0;
      this.cause = t1;
    },
    JsonCyclicError: function JsonCyclicError(t0, t1) {
      this.unsupportedObject = t0;
      this.cause = t1;
    },
    JsonCodec: function JsonCodec() {
    },
    JsonEncoder: function JsonEncoder(t0) {
      this._toEncodable = t0;
    },
    _JsonStringifier: function _JsonStringifier() {
    },
    _JsonStringifier_writeMap_closure: function _JsonStringifier_writeMap_closure(t0, t1) {
      this._box_0 = t0;
      this.keyValueList = t1;
    },
    _JsonStringStringifier: function _JsonStringStringifier(t0, t1, t2) {
      this._sink = t0;
      this._seen = t1;
      this._toEncodable = t2;
    },
    identityHashCode(object) {
      return A.objectHashCode(object);
    },
    int_parse(source, radix) {
      var value = A.Primitives_parseInt(source, radix);
      if (value != null)
        return value;
      throw A.wrapException(A.FormatException$(source, null, null));
    },
    Error__throw(error, stackTrace) {
      error = A.initializeExceptionWrapper(error, new Error());
      if (error == null)
        error = type$.Object._as(error);
      error.stack = stackTrace.toString$0(0);
      throw error;
    },
    List_List$filled($length, fill, growable, $E) {
      var i,
        result = growable ? J.JSArray_JSArray$growable($length, $E) : J.JSArray_JSArray$fixed($length, $E);
      if ($length !== 0 && fill != null)
        for (i = 0; i < result.length; ++i)
          result[i] = fill;
      return result;
    },
    List_List$from(elements, growable, $E) {
      var t1,
        list = A._setArrayType([], $E._eval$1("JSArray<0>"));
      for (t1 = J.get$iterator$ax(elements); t1.moveNext$0();)
        B.JSArray_methods.add$1(list, $E._as(t1.get$current()));
      if (growable)
        return list;
      list.$flags = 1;
      return list;
    },
    List_List$_of(elements, $E) {
      var list, t1;
      if (Array.isArray(elements))
        return A._setArrayType(elements.slice(0), $E._eval$1("JSArray<0>"));
      list = A._setArrayType([], $E._eval$1("JSArray<0>"));
      for (t1 = J.get$iterator$ax(elements); t1.moveNext$0();)
        B.JSArray_methods.add$1(list, t1.get$current());
      return list;
    },
    List_List$unmodifiable(elements, $E) {
      var result = A.List_List$from(elements, false, $E);
      result.$flags = 3;
      return result;
    },
    String_String$fromCharCodes(charCodes, start, end) {
      var t1, t2, maxLength, array, len;
      A.RangeError_checkNotNegative(start, "start");
      t1 = end == null;
      t2 = !t1;
      if (t2) {
        maxLength = end - start;
        if (maxLength < 0)
          throw A.wrapException(A.RangeError$range(end, start, null, "end", null));
        if (maxLength === 0)
          return "";
      }
      if (Array.isArray(charCodes)) {
        array = charCodes;
        len = array.length;
        if (t1)
          end = len;
        return A.Primitives_stringFromCharCodes(start > 0 || end < len ? array.slice(start, end) : array);
      }
      if (type$.NativeUint8List._is(charCodes))
        return A.String__stringFromUint8List(charCodes, start, end);
      if (t2)
        charCodes = J.take$1$ax(charCodes, end);
      if (start > 0)
        charCodes = J.skip$1$ax(charCodes, start);
      t1 = A.List_List$_of(charCodes, type$.int);
      return A.Primitives_stringFromCharCodes(t1);
    },
    String__stringFromUint8List(charCodes, start, endOrNull) {
      var len = charCodes.length;
      if (start >= len)
        return "";
      return A.Primitives_stringFromNativeUint8List(charCodes, start, endOrNull == null || endOrNull > len ? len : endOrNull);
    },
    RegExp_RegExp(source) {
      return new A.JSSyntaxRegExp(source, A.JSSyntaxRegExp_makeNative(source, false, true, false, false, ""));
    },
    identical(a, b) {
      return a == null ? b == null : a === b;
    },
    StringBuffer__writeAll(string, objects, separator) {
      var iterator = J.get$iterator$ax(objects);
      if (!iterator.moveNext$0())
        return string;
      if (separator.length === 0) {
        do
          string += A.S(iterator.get$current());
        while (iterator.moveNext$0());
      } else {
        string += A.S(iterator.get$current());
        for (; iterator.moveNext$0();)
          string = string + separator + A.S(iterator.get$current());
      }
      return string;
    },
    StackTrace_current() {
      return A.getTraceFromException(new Error());
    },
    DateTime$fromMicrosecondsSinceEpoch(microsecondsSinceEpoch, isUtc) {
      var t1 = B.JSInt_methods.$mod(microsecondsSinceEpoch, 1000),
        t2 = B.JSInt_methods._tdivFast$1(microsecondsSinceEpoch - t1, 1000);
      if (t2 < -864e13 || t2 > 864e13)
        A.throwExpression(A.RangeError$range(t2, -864e13, 864e13, "millisecondsSinceEpoch", null));
      if (t2 === 864e13 && t1 !== 0)
        A.throwExpression(A.ArgumentError$value(t1, "microsecond", string$.Time_i));
      A.checkNotNullable(isUtc, "isUtc", type$.bool);
      return new A.DateTime(t2, t1, isUtc);
    },
    DateTime__finishParse(year, month, day, hour, minute, second, millisecond, microsecond, isUtc) {
      var value = A.Primitives_valueFromDecomposedDate(year, month, day, hour, minute, second, millisecond, microsecond, isUtc);
      if (value == null)
        return null;
      return new A.DateTime(A.DateTime__validate(value, microsecond, isUtc), microsecond, isUtc);
    },
    DateTime_parse(formattedString) {
      var t1, t2, t3, years, month, day, hour, minute, second, milliAndMicroseconds, millisecond, isUtc, tzSign, sign, hourDifference, result, _null = null,
        match = $.$get$DateTime__parseFormat().firstMatch$1(formattedString);
      if (match != null) {
        t1 = new A.DateTime_parse_parseIntOrZero();
        t2 = match._match;
        if (1 >= t2.length)
          return A.ioore(t2, 1);
        t3 = t2[1];
        t3.toString;
        years = A.int_parse(t3, _null);
        if (2 >= t2.length)
          return A.ioore(t2, 2);
        t3 = t2[2];
        t3.toString;
        month = A.int_parse(t3, _null);
        if (3 >= t2.length)
          return A.ioore(t2, 3);
        t3 = t2[3];
        t3.toString;
        day = A.int_parse(t3, _null);
        if (4 >= t2.length)
          return A.ioore(t2, 4);
        hour = t1.call$1(t2[4]);
        if (5 >= t2.length)
          return A.ioore(t2, 5);
        minute = t1.call$1(t2[5]);
        if (6 >= t2.length)
          return A.ioore(t2, 6);
        second = t1.call$1(t2[6]);
        if (7 >= t2.length)
          return A.ioore(t2, 7);
        milliAndMicroseconds = new A.DateTime_parse_parseMilliAndMicroseconds().call$1(t2[7]);
        millisecond = B.JSInt_methods._tdivFast$1(milliAndMicroseconds, 1000);
        t3 = t2.length;
        if (8 >= t3)
          return A.ioore(t2, 8);
        isUtc = t2[8] != null;
        if (isUtc) {
          if (9 >= t3)
            return A.ioore(t2, 9);
          tzSign = t2[9];
          if (tzSign != null) {
            sign = tzSign === "-" ? -1 : 1;
            if (10 >= t3)
              return A.ioore(t2, 10);
            t3 = t2[10];
            t3.toString;
            hourDifference = A.int_parse(t3, _null);
            if (11 >= t2.length)
              return A.ioore(t2, 11);
            minute -= sign * (t1.call$1(t2[11]) + 60 * hourDifference);
          }
        }
        result = A.DateTime__finishParse(years, month, day, hour, minute, second, millisecond, milliAndMicroseconds % 1000, isUtc);
        if (result == null)
          throw A.wrapException(A.FormatException$("Time out of range", formattedString, _null));
        return result;
      } else
        throw A.wrapException(A.FormatException$("Invalid date format", formattedString, _null));
    },
    DateTime_tryParse(formattedString) {
      var t1, exception;
      try {
        t1 = A.DateTime_parse(formattedString);
        return t1;
      } catch (exception) {
        if (A.unwrapException(exception) instanceof A.FormatException)
          return null;
        else
          throw exception;
      }
    },
    DateTime__validate(millisecondsSinceEpoch, microsecond, isUtc) {
      var _s11_ = "microsecond";
      if (microsecond < 0 || microsecond > 999)
        throw A.wrapException(A.RangeError$range(microsecond, 0, 999, _s11_, null));
      if (millisecondsSinceEpoch < -864e13 || millisecondsSinceEpoch > 864e13)
        throw A.wrapException(A.RangeError$range(millisecondsSinceEpoch, -864e13, 864e13, "millisecondsSinceEpoch", null));
      if (millisecondsSinceEpoch === 864e13 && microsecond !== 0)
        throw A.wrapException(A.ArgumentError$value(microsecond, _s11_, string$.Time_i));
      A.checkNotNullable(isUtc, "isUtc", type$.bool);
      return millisecondsSinceEpoch;
    },
    DateTime__fourDigits(n) {
      var absN = Math.abs(n),
        sign = n < 0 ? "-" : "";
      if (absN >= 1000)
        return "" + n;
      if (absN >= 100)
        return sign + "0" + absN;
      if (absN >= 10)
        return sign + "00" + absN;
      return sign + "000" + absN;
    },
    DateTime__sixDigits(n) {
      var absN = Math.abs(n),
        sign = n < 0 ? "-" : "+";
      if (absN >= 100000)
        return sign + absN;
      return sign + "0" + absN;
    },
    DateTime__threeDigits(n) {
      if (n >= 100)
        return "" + n;
      if (n >= 10)
        return "0" + n;
      return "00" + n;
    },
    DateTime__twoDigits(n) {
      if (n >= 10)
        return "" + n;
      return "0" + n;
    },
    Duration$(microseconds, seconds) {
      return new A.Duration(microseconds + 1000000 * seconds);
    },
    Error_safeToString(object) {
      if (typeof object == "number" || A._isBool(object) || object == null)
        return J.toString$0$(object);
      if (typeof object == "string")
        return JSON.stringify(object);
      return A.Primitives_safeToString(object);
    },
    Error_throwWithStackTrace(error, stackTrace) {
      A.checkNotNullable(error, "error", type$.Object);
      A.checkNotNullable(stackTrace, "stackTrace", type$.StackTrace);
      A.Error__throw(error, stackTrace);
    },
    AssertionError$(message) {
      return new A.AssertionError(message);
    },
    ArgumentError$(message, $name) {
      return new A.ArgumentError(false, null, $name, message);
    },
    ArgumentError$value(value, $name, message) {
      return new A.ArgumentError(true, value, $name, message);
    },
    ArgumentError_checkNotNull(argument, $name, $T) {
      return argument;
    },
    RangeError$(message) {
      var _null = null;
      return new A.RangeError(_null, _null, false, _null, _null, message);
    },
    RangeError$value(value, $name) {
      return new A.RangeError(null, null, true, value, $name, "Value not in range");
    },
    RangeError$range(invalidValue, minValue, maxValue, $name, message) {
      return new A.RangeError(minValue, maxValue, true, invalidValue, $name, "Invalid value");
    },
    RangeError_checkValidRange(start, end, $length) {
      if (0 > start || start > $length)
        throw A.wrapException(A.RangeError$range(start, 0, $length, "start", null));
      if (end != null) {
        if (start > end || end > $length)
          throw A.wrapException(A.RangeError$range(end, start, $length, "end", null));
        return end;
      }
      return $length;
    },
    RangeError_checkNotNegative(value, $name) {
      if (value < 0)
        throw A.wrapException(A.RangeError$range(value, 0, null, $name, null));
      return value;
    },
    IndexError$withLength(invalidValue, $length, indexable, message, $name) {
      return new A.IndexError($length, true, invalidValue, $name, "Index out of range");
    },
    UnsupportedError$(message) {
      return new A.UnsupportedError(message);
    },
    UnimplementedError$(message) {
      return new A.UnimplementedError(message);
    },
    StateError$(message) {
      return new A.StateError(message);
    },
    ConcurrentModificationError$(modifiedObject) {
      return new A.ConcurrentModificationError(modifiedObject);
    },
    FormatException$(message, source, offset) {
      return new A.FormatException(message, source, offset);
    },
    Iterable_Iterable$generate(count, generator, $E) {
      if (count <= 0)
        return new A.EmptyIterable($E._eval$1("EmptyIterable<0>"));
      return new A._GeneratorIterable(count, generator, $E._eval$1("_GeneratorIterable<0>"));
    },
    Iterable_iterableToShortString(iterable, leftDelimiter, rightDelimiter) {
      var parts, t1;
      if (A.isToStringVisiting(iterable)) {
        if (leftDelimiter === "(" && rightDelimiter === ")")
          return "(...)";
        return leftDelimiter + "..." + rightDelimiter;
      }
      parts = A._setArrayType([], type$.JSArray_String);
      B.JSArray_methods.add$1($.toStringVisiting, iterable);
      try {
        A._iterablePartsToStrings(iterable, parts);
      } finally {
        if (0 >= $.toStringVisiting.length)
          return A.ioore($.toStringVisiting, -1);
        $.toStringVisiting.pop();
      }
      t1 = A.StringBuffer__writeAll(leftDelimiter, type$.Iterable_dynamic._as(parts), ", ") + rightDelimiter;
      return t1.charCodeAt(0) == 0 ? t1 : t1;
    },
    Iterable_iterableToFullString(iterable, leftDelimiter, rightDelimiter) {
      var buffer, t1;
      if (A.isToStringVisiting(iterable))
        return leftDelimiter + "..." + rightDelimiter;
      buffer = new A.StringBuffer(leftDelimiter);
      B.JSArray_methods.add$1($.toStringVisiting, iterable);
      try {
        t1 = buffer;
        t1._contents = A.StringBuffer__writeAll(t1._contents, iterable, ", ");
      } finally {
        if (0 >= $.toStringVisiting.length)
          return A.ioore($.toStringVisiting, -1);
        $.toStringVisiting.pop();
      }
      buffer._contents += rightDelimiter;
      t1 = buffer._contents;
      return t1.charCodeAt(0) == 0 ? t1 : t1;
    },
    _iterablePartsToStrings(iterable, parts) {
      var next, ultimateString, penultimateString, penultimate, ultimate, ultimate0, elision,
        it = iterable.get$iterator(iterable),
        $length = 0, count = 0;
      while (true) {
        if (!($length < 80 || count < 3))
          break;
        if (!it.moveNext$0())
          return;
        next = A.S(it.get$current());
        B.JSArray_methods.add$1(parts, next);
        $length += next.length + 2;
        ++count;
      }
      if (!it.moveNext$0()) {
        if (count <= 5)
          return;
        if (0 >= parts.length)
          return A.ioore(parts, -1);
        ultimateString = parts.pop();
        if (0 >= parts.length)
          return A.ioore(parts, -1);
        penultimateString = parts.pop();
      } else {
        penultimate = it.get$current();
        ++count;
        if (!it.moveNext$0()) {
          if (count <= 4) {
            B.JSArray_methods.add$1(parts, A.S(penultimate));
            return;
          }
          ultimateString = A.S(penultimate);
          if (0 >= parts.length)
            return A.ioore(parts, -1);
          penultimateString = parts.pop();
          $length += ultimateString.length + 2;
        } else {
          ultimate = it.get$current();
          ++count;
          for (; it.moveNext$0(); penultimate = ultimate, ultimate = ultimate0) {
            ultimate0 = it.get$current();
            ++count;
            if (count > 100) {
              while (true) {
                if (!($length > 75 && count > 3))
                  break;
                if (0 >= parts.length)
                  return A.ioore(parts, -1);
                $length -= parts.pop().length + 2;
                --count;
              }
              B.JSArray_methods.add$1(parts, "...");
              return;
            }
          }
          penultimateString = A.S(penultimate);
          ultimateString = A.S(ultimate);
          $length += ultimateString.length + penultimateString.length + 4;
        }
      }
      if (count > parts.length + 2) {
        $length += 5;
        elision = "...";
      } else
        elision = null;
      while (true) {
        if (!($length > 80 && parts.length > 3))
          break;
        if (0 >= parts.length)
          return A.ioore(parts, -1);
        $length -= parts.pop().length + 2;
        if (elision == null) {
          $length += 5;
          elision = "...";
        }
      }
      if (elision != null)
        B.JSArray_methods.add$1(parts, elision);
      B.JSArray_methods.add$1(parts, penultimateString);
      B.JSArray_methods.add$1(parts, ultimateString);
    },
    Object_hash(object1, object2, object3, object4) {
      var t1;
      if (B.C_SentinelValue === object3) {
        t1 = B.JSInt_methods.get$hashCode(object1);
        object2 = J.get$hashCode$(object2);
        return A.SystemHash_finish(A.SystemHash_combine(A.SystemHash_combine($.$get$_hashSeed(), t1), object2));
      }
      if (B.C_SentinelValue === object4) {
        t1 = B.JSInt_methods.get$hashCode(object1);
        object2 = J.get$hashCode$(object2);
        object3 = J.get$hashCode$(object3);
        return A.SystemHash_finish(A.SystemHash_combine(A.SystemHash_combine(A.SystemHash_combine($.$get$_hashSeed(), t1), object2), object3));
      }
      t1 = B.JSInt_methods.get$hashCode(object1);
      object2 = J.get$hashCode$(object2);
      object3 = J.get$hashCode$(object3);
      object4 = J.get$hashCode$(object4);
      object4 = A.SystemHash_finish(A.SystemHash_combine(A.SystemHash_combine(A.SystemHash_combine(A.SystemHash_combine($.$get$_hashSeed(), t1), object2), object3), object4));
      return object4;
    },
    print(object) {
      var line = A.S(object),
        toZone = $.printToZone;
      if (toZone == null)
        A.printString(line);
      else
        toZone.call$1(line);
    },
    Set_castFrom(source, newSet, $S, $T) {
      return new A.CastSet(source, newSet, $S._eval$1("@<0>")._bind$1($T)._eval$1("CastSet<1,2>"));
    },
    DateTime: function DateTime(t0, t1, t2) {
      this._core$_value = t0;
      this._microsecond = t1;
      this.isUtc = t2;
    },
    DateTime_parse_parseIntOrZero: function DateTime_parse_parseIntOrZero() {
    },
    DateTime_parse_parseMilliAndMicroseconds: function DateTime_parse_parseMilliAndMicroseconds() {
    },
    Duration: function Duration(t0) {
      this._duration = t0;
    },
    Error: function Error() {
    },
    AssertionError: function AssertionError(t0) {
      this.message = t0;
    },
    TypeError: function TypeError() {
    },
    ArgumentError: function ArgumentError(t0, t1, t2, t3) {
      var _ = this;
      _._hasValue = t0;
      _.invalidValue = t1;
      _.name = t2;
      _.message = t3;
    },
    RangeError: function RangeError(t0, t1, t2, t3, t4, t5) {
      var _ = this;
      _.start = t0;
      _.end = t1;
      _._hasValue = t2;
      _.invalidValue = t3;
      _.name = t4;
      _.message = t5;
    },
    IndexError: function IndexError(t0, t1, t2, t3, t4) {
      var _ = this;
      _.length = t0;
      _._hasValue = t1;
      _.invalidValue = t2;
      _.name = t3;
      _.message = t4;
    },
    UnsupportedError: function UnsupportedError(t0) {
      this.message = t0;
    },
    UnimplementedError: function UnimplementedError(t0) {
      this.message = t0;
    },
    StateError: function StateError(t0) {
      this.message = t0;
    },
    ConcurrentModificationError: function ConcurrentModificationError(t0) {
      this.modifiedObject = t0;
    },
    OutOfMemoryError: function OutOfMemoryError() {
    },
    StackOverflowError: function StackOverflowError() {
    },
    _Exception: function _Exception(t0) {
      this.message = t0;
    },
    FormatException: function FormatException(t0, t1, t2) {
      this.message = t0;
      this.source = t1;
      this.offset = t2;
    },
    Iterable: function Iterable() {
    },
    _GeneratorIterable: function _GeneratorIterable(t0, t1, t2) {
      this.length = t0;
      this._generator = t1;
      this.$ti = t2;
    },
    MapEntry: function MapEntry(t0, t1, t2) {
      this.key = t0;
      this.value = t1;
      this.$ti = t2;
    },
    Null: function Null() {
    },
    Object: function Object() {
    },
    _StringStackTrace: function _StringStackTrace() {
    },
    Stopwatch: function Stopwatch() {
      this._stop = this._core$_start = 0;
    },
    StringBuffer: function StringBuffer(t0) {
      this._contents = t0;
    },
    _functionToJS0(f) {
      var result;
      if (typeof f == "function")
        throw A.wrapException(A.ArgumentError$("Attempting to rewrap a JS function.", null));
      result = function(_call, f) {
        return function() {
          return _call(f);
        };
      }(A._callDartFunctionFast0, f);
      result[$.$get$DART_CLOSURE_PROPERTY_NAME()] = f;
      return result;
    },
    _functionToJS1(f) {
      var result;
      if (typeof f == "function")
        throw A.wrapException(A.ArgumentError$("Attempting to rewrap a JS function.", null));
      result = function(_call, f) {
        return function(arg1) {
          return _call(f, arg1, arguments.length);
        };
      }(A._callDartFunctionFast1, f);
      result[$.$get$DART_CLOSURE_PROPERTY_NAME()] = f;
      return result;
    },
    _callDartFunctionFast0(callback) {
      return type$.Function._as(callback).call$0();
    },
    _callDartFunctionFast1(callback, arg1, $length) {
      type$.Function._as(callback);
      if (A._asInt($length) >= 1)
        return callback.call$1(arg1);
      return callback.call$0();
    },
    _noJsifyRequired(o) {
      return o == null || A._isBool(o) || typeof o == "number" || typeof o == "string" || type$.Int8List._is(o) || type$.Uint8List._is(o) || type$.Uint8ClampedList._is(o) || type$.Int16List._is(o) || type$.Uint16List._is(o) || type$.Int32List._is(o) || type$.Uint32List._is(o) || type$.Float32List._is(o) || type$.Float64List._is(o) || type$.ByteBuffer._is(o) || type$.ByteData._is(o);
    },
    jsify(object) {
      if (A._noJsifyRequired(object))
        return object;
      return new A.jsify__convert(new A._IdentityHashMap(type$._IdentityHashMap_of_nullable_Object_and_nullable_Object)).call$1(object);
    },
    getProperty(o, $name, $T) {
      return $T._as(o[$name]);
    },
    jsify__convert: function jsify__convert(t0) {
      this._convertedObjects = t0;
    },
    _JSRandom: function _JSRandom() {
    },
    DefaultEquality: function DefaultEquality(t0) {
      this.$ti = t0;
    },
    IterableEquality: function IterableEquality(t0, t1) {
      this._elementEquality = t0;
      this.$ti = t1;
    },
    ListEquality: function ListEquality(t0, t1) {
      this._elementEquality = t0;
      this.$ti = t1;
    },
    _UnorderedEquality: function _UnorderedEquality() {
    },
    SetEquality: function SetEquality(t0, t1) {
      this._elementEquality = t0;
      this.$ti = t1;
    },
    _MapEntry: function _MapEntry(t0, t1, t2) {
      this.equality = t0;
      this.key = t1;
      this.value = t2;
    },
    MapEquality: function MapEquality(t0, t1, t2) {
      this._keyEquality = t0;
      this._valueEquality = t1;
      this.$ti = t2;
    },
    DeepCollectionEquality: function DeepCollectionEquality() {
    },
    DatabaseError$(_message) {
      return new A.DatabaseError(_message);
    },
    ObjectStore: function ObjectStore() {
    },
    Request: function Request() {
    },
    OpenDBRequest: function OpenDBRequest(t0) {
      this.result = t0;
    },
    DatabaseError: function DatabaseError(t0) {
      this._idb$_message = t0;
    },
    DatabaseStoreNotFoundError_storeMessage(storeOrStores) {
      return "NotFoundError: One of the specified object stores '" + storeOrStores + "' was not found.";
    },
    DatabaseStoreNotFoundError$(message) {
      return new A.DatabaseStoreNotFoundError(message);
    },
    DatabaseReadOnlyError: function DatabaseReadOnlyError(t0) {
      this._idb$_message = t0;
    },
    DatabaseStoreNotFoundError: function DatabaseStoreNotFoundError(t0) {
      this._idb$_message = t0;
    },
    DatabaseTransactionStoreNotFoundError: function DatabaseTransactionStoreNotFoundError(t0) {
      this._idb$_message = t0;
    },
    IdbDatabaseBase: function IdbDatabaseBase() {
    },
    IdbVersionChangeEventBase: function IdbVersionChangeEventBase() {
    },
    IdbFactoryBase: function IdbFactoryBase() {
    },
    IdbObjectStoreMeta$($name, keyPath, autoIncrement, indecies) {
      var t1 = new A.IdbObjectStoreMeta($name, keyPath, autoIncrement === true, A.LinkedHashMap_LinkedHashMap$_empty(type$.nullable_String, type$.IdbIndexMeta));
      t1.IdbObjectStoreMeta$4($name, keyPath, autoIncrement, indecies);
      return t1;
    },
    IdbObjectStoreMeta__keyPathAsStringOrList(keyPath) {
      var t1;
      if (type$.Iterable_dynamic._is(keyPath)) {
        t1 = J.cast$1$0$ax(keyPath, type$.String);
        return t1.toList$0(t1);
      } else
        return keyPath == null ? null : J.toString$0$(keyPath);
    },
    IdbIndexMeta_fromMapList(list) {
      var metas, t1, t2, t3, t4, t5, t6, t7, t8, t9;
      if (list == null)
        return null;
      metas = A._setArrayType([], type$.JSArray_IdbIndexMeta);
      for (t1 = list.$ti, t2 = new A.ListIterator(list, list.get$length(0), t1._eval$1("ListIterator<ListBase.E>")), t3 = type$.String, t4 = type$.nullable_Object, t1 = t1._eval$1("ListBase.E"), t5 = type$.Object; t2.moveNext$0();) {
        t6 = t2.__internal$_current;
        t6 = (t6 == null ? t1._as(t6) : t6).cast$2$0(0, t3, t4);
        t7 = t6._source;
        t6 = t6.$ti._eval$1("4?");
        t8 = A._asString(t6._as(t7.$index(0, "name")));
        t9 = t6._as(t7.$index(0, "keyPath"));
        t9 = A._keyPathAsStringOrListOrNull(t9 == null ? t5._as(t9) : t9);
        t9.toString;
        B.JSArray_methods.add$1(metas, new A.IdbIndexMeta(t8, t9, A._asBoolQ(t6._as(t7.$index(0, "unique"))) === true, A._asBoolQ(t6._as(t7.$index(0, "multiEntry"))) === true));
      }
      return metas;
    },
    _keyPathAsStringOrListOrNull(keyPath) {
      var t1;
      if (type$.Iterable_dynamic._is(keyPath)) {
        t1 = J.cast$1$0$ax(keyPath, type$.String);
        return t1.toList$0(t1);
      } else {
        t1 = J.toString$0$(keyPath);
        return t1;
      }
    },
    TransactionWithMetaMixin: function TransactionWithMetaMixin() {
    },
    IdbTransactionMeta: function IdbTransactionMeta(t0, t1) {
      this.mode = t0;
      this.storeNames = t1;
    },
    IdbVersionChangeTransactionMeta: function IdbVersionChangeTransactionMeta(t0, t1, t2, t3, t4, t5, t6) {
      var _ = this;
      _.createdIndexes = t0;
      _.deletedIndexes = t1;
      _.createdStores = t2;
      _.deletedStores = t3;
      _.updatedStores = t4;
      _.mode = t5;
      _.storeNames = t6;
    },
    DatabaseWithMetaMixin: function DatabaseWithMetaMixin() {
    },
    IdbDatabaseMeta: function IdbDatabaseMeta(t0) {
      var _ = this;
      _.__IdbDatabaseMeta_name_A = $;
      _._versionChangeTransaction = _.version = null;
      _._stores = t0;
    },
    ObjectStoreWithMetaMixin: function ObjectStoreWithMetaMixin() {
    },
    IdbObjectStoreMeta: function IdbObjectStoreMeta(t0, t1, t2, t3) {
      var _ = this;
      _.name = t0;
      _.keyPath = t1;
      _.autoIncrement = t2;
      _._indecies = t3;
    },
    IdbObjectStoreMeta_toMap_closure: function IdbObjectStoreMeta_toMap_closure() {
    },
    IdbCursorMeta: function IdbCursorMeta(t0, t1, t2) {
      var _ = this;
      _.key = t0;
      _.autoAdvance = t1;
      _.range = t2;
      _.__IdbCursorMeta__ascending_A = $;
    },
    IdbIndexMeta: function IdbIndexMeta(t0, t1, t2, t3) {
      var _ = this;
      _.name = t0;
      _.keyPath = t1;
      _.unique = t2;
      _.multiEntry = t3;
    },
    IdbTransactionBase: function IdbTransactionBase() {
    },
    IdbTransactionMixin: function IdbTransactionMixin() {
    },
    _IdbTransactionBase_Object_IdbTransactionMixin: function _IdbTransactionBase_Object_IdbTransactionMixin() {
    },
    _cloneList(original, $T) {
      var t1,
        list = A._setArrayType([], $T._eval$1("JSArray<0>"));
      for (t1 = J.get$iterator$ax(original); t1.moveNext$0();)
        B.JSArray_methods.add$1(list, $T._as(A._cloneValue(t1.get$current())));
      return list;
    },
    _cloneMap(original) {
      var map = A.LinkedHashMap_LinkedHashMap$_empty(type$.String, type$.nullable_Object);
      original.forEach$1(0, new A._cloneMap_closure(map));
      return map;
    },
    _cloneValue(original) {
      if (type$.Map_dynamic_dynamic._is(original))
        return A._cloneMap(original);
      else if (type$.List_dynamic._is(original))
        return A._cloneList(original, type$.dynamic);
      return original;
    },
    getPartsMapValue0(map, parts, $T) {
      var t1, t2, value, _i, part;
      for (t1 = parts.length, t2 = type$.Map_dynamic_dynamic, value = map, _i = 0; _i < parts.length; parts.length === t1 || (0, A.throwConcurrentModificationError)(parts), ++_i) {
        part = parts[_i];
        if (t2._is(value))
          value = value.$index(0, part);
        else
          return null;
      }
      return $T._eval$1("0?")._as(value);
    },
    setPartsMapValue(map, parts, value) {
      var t1, t2, t3, i, part, sub;
      for (t1 = type$.Map_dynamic_dynamic, t2 = type$.String, t3 = type$.nullable_Object, i = 0; i < parts.length - 1; ++i, map = sub) {
        part = parts[i];
        sub = map.$index(0, part);
        if (!t1._is(sub)) {
          sub = A.LinkedHashMap_LinkedHashMap$_empty(t2, t3);
          map.$indexSet(0, part, sub);
        }
      }
      map.$indexSet(0, B.JSArray_methods.get$last(parts), value);
    },
    IdbValueMapExt_getKeyValue(_this, keyPath) {
      var _length, keys, t1, t2, i;
      if (typeof keyPath == "string")
        return A.getPartsMapValue0(_this, A._setArrayType(keyPath.split("."), type$.JSArray_String), type$.Object);
      else if (type$.List_dynamic._is(keyPath)) {
        _length = keyPath.length;
        keys = J.JSArray_JSArray$allocateGrowable(_length, type$.nullable_Object);
        for (t1 = type$.Object, t2 = type$.JSArray_String, i = 0; i < _length; ++i) {
          if (!(i < keyPath.length))
            return A.ioore(keyPath, i);
          keys[i] = A.getPartsMapValue0(_this, A._setArrayType(A._asString(keyPath[i]).split("."), t2), t1);
        }
        t1 = A._arrayInstanceType(keys);
        if (!new A.WhereIterable(keys, t1._eval$1("bool(1)")._as(new A.IdbValueMapExt_getKeyValue_closure()), t1._eval$1("WhereIterable<1>")).get$isEmpty(0))
          return null;
        return keys;
      }
      throw A.wrapException("keyPath " + A.S(keyPath) + " not supported");
    },
    _cloneMap_closure: function _cloneMap_closure(t0) {
      this.map = t0;
    },
    IdbValueMapExt_getKeyValue_closure: function IdbValueMapExt_getKeyValue_closure() {
    },
    IdbCursor: function IdbCursor() {
    },
    IdbCursorWithValue: function IdbCursorWithValue() {
    },
    DatabaseException0: function DatabaseException0(t0) {
      this._database_exception$_message = t0;
    },
    DOMStringListExt_toStringIterable(_this) {
      return A.Iterable_Iterable$generate(A._asInt(_this.length), new A.DOMStringListExt_toStringIterable_closure(_this), type$.String);
    },
    IDBRequestExt_handleOnError(_this, completer) {
      _this.onerror = A._functionToJS1(new A.IDBRequestExt_handleOnError_closure(completer, _this));
    },
    IDBRequestExt_handleOnSuccess(_this, completer) {
      _this.onsuccess = A._functionToJS1(new A.IDBRequestExt_handleOnSuccess_closure(completer, _this));
    },
    IDBRequestExt_get_future(_this) {
      var t1 = new A._Future($.Zone__current, type$._Future_nullable_Object),
        completer = new A._SyncCompleter(t1, type$._SyncCompleter_nullable_Object);
      A.IDBRequestExt_handleOnSuccess(_this, completer);
      A.IDBRequestExt_handleOnError(_this, completer);
      return t1;
    },
    IDBRequestExt_dartFutureNullable(_this, $T) {
      return A.IDBRequestExt_get_future(_this).then$1$1(new A.IDBRequestExt_dartFutureNullable_closure($T), $T);
    },
    IDBRequestExt_dartFuture(_this, $T) {
      return A.IDBRequestExt_get_future(_this).then$1$1(new A.IDBRequestExt_dartFuture_closure($T), $T);
    },
    DOMStringListExt_toStringIterable_closure: function DOMStringListExt_toStringIterable_closure(t0) {
      this._this = t0;
    },
    IDBRequestExt_handleOnError_closure: function IDBRequestExt_handleOnError_closure(t0, t1) {
      this.completer = t0;
      this._this = t1;
    },
    IDBRequestExt_handleOnSuccess_closure: function IDBRequestExt_handleOnSuccess_closure(t0, t1) {
      this.completer = t0;
      this._this = t1;
    },
    IDBRequestExt_dartFutureNullable_closure: function IDBRequestExt_dartFutureNullable_closure(t0) {
      this.T = t0;
    },
    IDBRequestExt_dartFuture_closure: function IDBRequestExt_dartFuture_closure(t0) {
      this.T = t0;
    },
    IDBJsifyExtension_jsifyValueStrict(_this) {
      var _this0, jsArray, t1, t2, t3, t4, item, t5;
      if (typeof _this == "string")
        return _this;
      else if (typeof _this == "number")
        return _this;
      else if (type$.Map_dynamic_dynamic._is(_this)) {
        _this0 = {};
        _this.forEach$1(0, new A.IDBJsifyExtension_jsifyValueStrict_closure(_this0));
        return _this0;
      } else if (type$.List_dynamic._is(_this)) {
        if (type$.Uint8List._is(_this))
          return _this;
        jsArray = type$.JSArray_nullable_Object._as(new init.G.Array(J.get$length$asx(_this)));
        for (t1 = A.IndexedIterable_IndexedIterable(_this, 0, type$.dynamic), t2 = J.get$iterator$ax(t1._source), t3 = t1._start, t1 = new A.IndexedIterator(t2, t3, A._instanceType(t1)._eval$1("IndexedIterator<1>")); t1.moveNext$0();) {
          t4 = t1.__internal$_index;
          t4 = t4 >= 0 ? new A._Record_2(t3 + t4, t2.get$current()) : A.throwExpression(A.IterableElementError_noElement());
          item = t4._1;
          t5 = item == null ? null : A.IDBJsifyExtension_jsifyValueStrict(item);
          jsArray[t4._0] = t5;
        }
        return jsArray;
      } else if (_this instanceof A.DateTime)
        return type$.JSObject._as(new init.G.Date(_this._core$_value));
      else if (A._isBool(_this))
        return _this;
      throw A.wrapException(A.UnsupportedError$("Unsupported value: " + A.S(_this) + " (type: " + J.get$runtimeType$(_this).toString$0(0) + ")"));
    },
    IDBDartifyExtension_dartifyStringOrStringList(_this) {
      var t1;
      if (typeof _this === "string")
        return A._asString(_this);
      else if (A.JSAnyUtilityExtension_instanceOfString(_this, "Array")) {
        type$.JSArray_nullable_Object._as(_this);
        t1 = B.JSArray_methods.map$1$1(_this, new A.IDBDartifyExtension_dartifyStringOrStringList_closure(), type$.Object);
        t1 = A.List_List$_of(t1, t1.$ti._eval$1("ListIterable.E"));
        return t1;
      }
      throw A.wrapException(A.UnsupportedError$("Unsupported keyPath: " + A.S(_this) + " (type: " + J.get$runtimeType$(_this).toString$0(0) + ")"));
    },
    IDBDartifyExtension_dartifyValueStrict(_this) {
      var jsObject, object, keys, key, jsArray, _length, list, index, t1, t2, t3, exception,
        value = _this;
      if (value != null && typeof value === "string")
        return A._asString(value);
      else if (value != null && typeof value === "number")
        return A._asDouble(value);
      else if (value != null && typeof value === "boolean")
        return A._asBool(value);
      else if (typeof value === "object") {
        if (value != null && A.JSAnyUtilityExtension_instanceOfString(value, "Array")) {
          jsArray = type$.JSArray_nullable_Object._as(value);
          _length = A._asInt(jsArray.length);
          list = J.JSArray_JSArray$allocateGrowable(_length, type$.nullable_Object);
          for (index = 0; index < _length; ++index) {
            t1 = jsArray[index];
            list[index] = t1 == null ? null : A.IDBDartifyExtension_dartifyValueStrict(t1);
          }
          return list;
        } else if (value != null && A.JSAnyUtilityExtension_instanceOfString(value, "Date")) {
          t1 = A._asInt(type$.JSObject._as(value).getTime());
          if (t1 < -864e13 || t1 > 864e13)
            A.throwExpression(A.RangeError$range(t1, -864e13, 864e13, "millisecondsSinceEpoch", null));
          A.checkNotNullable(true, "isUtc", type$.bool);
          return new A.DateTime(t1, 0, true);
        } else if (value != null && A.JSAnyUtilityExtension_instanceOfString(value, "ArrayBuffer")) {
          t1 = type$.NativeByteBuffer._as(value);
          t1 = new Uint8Array(t1, 0);
          return t1;
        } else if (value != null && A.JSAnyUtilityExtension_instanceOfString(value, "Uint8Array"))
          return type$.NativeUint8List._as(value);
        try {
          jsObject = type$.JSObject._as(value);
          object = A.LinkedHashMap_LinkedHashMap$_empty(type$.String, type$.nullable_Object);
          t1 = type$.JSArray_nullable_Object._as(init.G.Object.keys(jsObject));
          keys = t1;
          for (t1 = J.get$iterator$ax(keys); t1.moveNext$0();) {
            key = t1.get$current();
            t2 = A._asString(key);
            t3 = jsObject[key];
            t3 = t3 == null ? null : A.IDBDartifyExtension_dartifyValueStrict(t3);
            J.$indexSet$ax(object, t2, t3);
          }
          return object;
        } catch (exception) {
          if (value instanceof A.DateTime)
            return value;
        }
      }
      throw A.wrapException(A.UnsupportedError$("Unsupported value: " + A.S(value) + " (type: " + J.get$runtimeType$(value).toString$0(0) + ")"));
    },
    IDBJsifyExtension_jsifyValueStrict_closure: function IDBJsifyExtension_jsifyValueStrict_closure(t0) {
      this.jsObject = t0;
    },
    IDBDartifyExtension_dartifyStringOrStringList_closure: function IDBDartifyExtension_dartifyStringOrStringList_closure() {
    },
    CursorWithValueNative: function CursorWithValueNative(t0) {
      this._cwv = t0;
    },
    VersionChangeEventNative: function VersionChangeEventNative(t0, t1) {
      var _ = this;
      _.factory = t0;
      _.idbVersionChangeEvent = t1;
      _.__VersionChangeEventNative_database_AI = _.__VersionChangeEventNative_transaction_AI = _.__VersionChangeEventNative_request_AI = $;
    },
    DatabaseNative: function DatabaseNative(t0, t1) {
      this.idbDatabase = t0;
      this._factory = t1;
    },
    DatabaseNative_createObjectStore_closure: function DatabaseNative_createObjectStore_closure(t0, t1, t2, t3) {
      var _ = this;
      _.$this = t0;
      _.name = t1;
      _.keyPath = t2;
      _.autoIncrement = t3;
    },
    DatabaseNative_transaction_closure: function DatabaseNative_transaction_closure(t0, t1, t2) {
      this.$this = t0;
      this.storeNameOrStoreNames = t1;
      this.mode = t2;
    },
    DatabaseNative_objectStoreNames_closure: function DatabaseNative_objectStoreNames_closure(t0) {
      this.$this = t0;
    },
    DatabaseNative_name_closure: function DatabaseNative_name_closure(t0) {
      this.$this = t0;
    },
    catchNativeError(action, $T) {
      var e, t1, exception;
      try {
        t1 = action.call$0();
        return t1;
      } catch (exception) {
        e = A.unwrapException(exception);
        A._handleError(e);
        throw exception;
      }
    },
    _handleError(e) {
      var error, t1, t2, exception;
      if (e instanceof A.DatabaseError)
        return false;
      else if (e instanceof A.DatabaseException0)
        return false;
      else if (type$.Error._is(e))
        throw A.wrapException(A.DatabaseError$(e.toString$0(0)));
      else
        try {
          type$.JSObject._as(e);
          error = e;
          t1 = type$.nullable_String;
          t2 = A.getProperty(error, "name", t1);
          if (t2 == null)
            t2 = "IDBError";
          t1 = A.getProperty(error, "message", t1);
          t1 = A.DatabaseErrorNative$(t2, t1 == null ? J.toString$0$(e) : t1);
          throw A.wrapException(t1);
        } catch (exception) {
          t1 = A.DatabaseError$(J.toString$0$(e));
          throw A.wrapException(t1);
        }
    },
    catchAsyncNativeError(action, $T) {
      return A.catchAsyncNativeError$body(action, $T, $T);
    },
    catchAsyncNativeError$body(action, $T, $async$type) {
      var $async$goto = 0,
        $async$completer = A._makeAsyncAwaitCompleter($async$type),
        $async$returnValue, $async$handler = 2, $async$errorStack = [], e, t1, exception, $async$exception;
      var $async$catchAsyncNativeError = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1) {
          $async$errorStack.push($async$result);
          $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$handler = 4;
              $async$goto = 7;
              return A._asyncAwait(action.call$0(), $async$catchAsyncNativeError);
            case 7:
              // returning from await.
              t1 = $async$result;
              $async$returnValue = t1;
              // goto return
              $async$goto = 1;
              break;
              $async$handler = 2;
              // goto after finally
              $async$goto = 6;
              break;
            case 4:
              // catch
              $async$handler = 3;
              $async$exception = $async$errorStack.pop();
              e = A.unwrapException($async$exception);
              A._handleError(e);
              throw $async$exception;
              // goto after finally
              $async$goto = 6;
              break;
            case 3:
              // uncaught
              // goto rethrow
              $async$goto = 2;
              break;
            case 6:
              // after finally
            case 1:
              // return
              return A._asyncReturn($async$returnValue, $async$completer);
            case 2:
              // rethrow
              return A._asyncRethrow($async$errorStack.at(-1), $async$completer);
          }
      });
      return A._asyncStartSync($async$catchAsyncNativeError, $async$completer);
    },
    DatabaseErrorNative$($name, message) {
      return new A.DatabaseErrorNative($name, message);
    },
    DatabaseErrorNative: function DatabaseErrorNative(t0, t1) {
      this.name = t0;
      this._idb$_message = t1;
    },
    IdbFactoryNativeBrowserWrapperImpl: function IdbFactoryNativeBrowserWrapperImpl(t0) {
      this.nativeFactory = t0;
    },
    IdbFactoryNativeWrapperImpl: function IdbFactoryNativeWrapperImpl() {
    },
    IdbFactoryNativeWrapperImpl_open_closure: function IdbFactoryNativeWrapperImpl_open_closure(t0, t1, t2) {
      this._box_0 = t0;
      this.$this = t1;
      this.onUpgradeNeeded = t2;
    },
    IdbFactoryNativeWrapperImpl_deleteDatabase_closure: function IdbFactoryNativeWrapperImpl_deleteDatabase_closure(t0) {
      this.$this = t0;
    },
    cursorWithValueStreamFromResult(request, autoAdvance) {
      var controller = A.StreamController_StreamController(true, type$.IdbCursorWithValue);
      request.onerror = A._functionToJS1(new A.cursorWithValueStreamFromResult_closure(controller, request));
      request.onsuccess = A._functionToJS1(new A.cursorWithValueStreamFromResult_closure0(request, controller, autoAdvance));
      return new A._ControllerStream(controller, A._instanceType(controller)._eval$1("_ControllerStream<1>"));
    },
    cursorWithValueStreamFromResult_closure: function cursorWithValueStreamFromResult_closure(t0, t1) {
      this.controller = t0;
      this.request = t1;
    },
    cursorWithValueStreamFromResult_closure0: function cursorWithValueStreamFromResult_closure0(t0, t1, t2) {
      this.request = t0;
      this.controller = t1;
      this.autoAdvance = t2;
    },
    ObjectStoreNative: function ObjectStoreNative(t0) {
      this.idbObjectStore = t0;
    },
    ObjectStoreNative_getObject_closure: function ObjectStoreNative_getObject_closure(t0, t1) {
      this.$this = t0;
      this.key = t1;
    },
    ObjectStoreNative_clear_closure: function ObjectStoreNative_clear_closure(t0) {
      this.$this = t0;
    },
    ObjectStoreNative_put_closure: function ObjectStoreNative_put_closure(t0, t1, t2) {
      this.$this = t0;
      this.key = t1;
      this.value = t2;
    },
    ObjectStoreNative_delete_closure: function ObjectStoreNative_delete_closure(t0, t1) {
      this.$this = t0;
      this.keyOrRange = t1;
    },
    TransactionNativeBase: function TransactionNativeBase() {
    },
    TransactionNative: function TransactionNative(t0, t1) {
      this.idbTransaction = t0;
      this.__TransactionNative__completer_FI = $;
      this.database = t1;
    },
    TransactionNative__completer_closure: function TransactionNative__completer_closure(t0) {
      this.$this = t0;
    },
    TransactionNative__completer__closure: function TransactionNative__completer__closure(t0, t1) {
      this.$this = t0;
      this.completer = t1;
    },
    TransactionNative__completer__closure0: function TransactionNative__completer__closure0(t0) {
      this.completer = t0;
    },
    TransactionNative__completer__closure1: function TransactionNative__completer__closure1(t0) {
      this.completer = t0;
    },
    TransactionNative_objectStore_closure: function TransactionNative_objectStore_closure(t0, t1) {
      this.$this = t0;
      this.name = t1;
    },
    TransactionNative_completed_closure: function TransactionNative_completed_closure(t0) {
      this.$this = t0;
    },
    keyPathSortOrders(keyPath, ascending) {
      var _length, _list, t1, t2, i, t3;
      if (typeof keyPath == "string")
        return A._setArrayType([A.SembastSortOrder$(keyPath, ascending, false, type$.nullable_Object)], type$.JSArray_SortOrder_nullable_Object);
      else if (type$.List_dynamic._is(keyPath)) {
        _length = keyPath.length;
        _list = J.JSArray_JSArray$allocateGrowable(_length, type$.SortOrder_nullable_Object);
        for (t1 = type$.SembastSortOrder_nullable_Object, t2 = keyPath.length, i = 0; i < _length; ++i) {
          if (!(i < t2))
            return A.ioore(keyPath, i);
          t3 = A._asString(keyPath[i]);
          _list[i] = new A.SembastSortOrder(t3, ascending, false, t1);
        }
        return _list;
      }
      throw A.wrapException("invalid keyPath " + A.S(keyPath));
    },
    KeyCursorSembastMixin: function KeyCursorSembastMixin() {
    },
    CursorWithValueSembastMixin: function CursorWithValueSembastMixin() {
    },
    StoreCursorWithValueSembast: function StoreCursorWithValueSembast(t0, t1) {
      this.KeyCursorSembastMixin___KeyCursorSembastMixin_recordIndex_A = t0;
      this.KeyCursorSembastMixin___KeyCursorSembastMixin_ctlr_A = t1;
    },
    RecordSnapshotSembast: function RecordSnapshotSembast(t0, t1) {
      this.idbStore = t0;
      this.snapshot = t1;
    },
    StoreCursorControllerSembastMixin: function StoreCursorControllerSembastMixin() {
    },
    BaseCursorControllerSembastMixin: function BaseCursorControllerSembastMixin() {
    },
    BaseCursorControllerSembastMixin_setRecords_closure: function BaseCursorControllerSembastMixin_setRecords_closure(t0) {
      this.$this = t0;
    },
    CursorWithValueControllerSembastMixin: function CursorWithValueControllerSembastMixin() {
    },
    StoreCursorWithValueControllerSembast: function StoreCursorWithValueControllerSembast(t0, t1, t2, t3, t4) {
      var _ = this;
      _.store = t0;
      _.BaseCursorControllerSembastMixin___BaseCursorControllerSembastMixin_meta_A = t1;
      _.BaseCursorControllerSembastMixin_records = t2;
      _.BaseCursorControllerSembastMixin_currentIndex = t3;
      _.BaseCursorControllerSembastMixin___BaseCursorControllerSembastMixin_ctlr_A = t4;
    },
    _StoreCursorWithValueControllerSembast_Object_CursorWithValueControllerSembastMixin: function _StoreCursorWithValueControllerSembast_Object_CursorWithValueControllerSembastMixin() {
    },
    _StoreCursorWithValueControllerSembast_Object_CursorWithValueControllerSembastMixin_BaseCursorControllerSembastMixin: function _StoreCursorWithValueControllerSembast_Object_CursorWithValueControllerSembastMixin_BaseCursorControllerSembastMixin() {
    },
    _StoreCursorWithValueControllerSembast_Object_CursorWithValueControllerSembastMixin_BaseCursorControllerSembastMixin_StoreCursorControllerSembastMixin: function _StoreCursorWithValueControllerSembast_Object_CursorWithValueControllerSembastMixin_BaseCursorControllerSembastMixin_StoreCursorControllerSembastMixin() {
    },
    _StoreCursorWithValueSembast_Object_KeyCursorSembastMixin: function _StoreCursorWithValueSembast_Object_KeyCursorSembastMixin() {
    },
    _StoreCursorWithValueSembast_Object_KeyCursorSembastMixin_CursorWithValueSembastMixin: function _StoreCursorWithValueSembast_Object_KeyCursorSembastMixin_CursorWithValueSembastMixin() {
    },
    _SembastVersionChangeEvent: function _SembastVersionChangeEvent(t0, t1) {
      this.oldVersion = t0;
      this.newVersion = t1;
      this.___SembastVersionChangeEvent_request_A = $;
    },
    DatabaseSembast: function DatabaseSembast(t0, t1, t2) {
      var _ = this;
      _.versionChangeTransaction = null;
      _.meta = t0;
      _.db = null;
      _.mainStore = t1;
      _._factory = t2;
    },
    DatabaseSembast__loadStoresMeta_closure: function DatabaseSembast__loadStoresMeta_closure(t0) {
      this.keys = t0;
    },
    DatabaseSembast__loadStoresMeta_closure0: function DatabaseSembast__loadStoresMeta_closure0() {
    },
    DatabaseSembast__loadStoresMeta__closure: function DatabaseSembast__loadStoresMeta__closure(t0) {
      this.list = t0;
    },
    DatabaseSembast__readMetaVersion_closure: function DatabaseSembast__readMetaVersion_closure(t0) {
      this.$this = t0;
    },
    DatabaseSembast__readMetaVersion__closure: function DatabaseSembast__readMetaVersion__closure(t0) {
      this.$this = t0;
    },
    DatabaseSembast__readMetaVersion___closure: function DatabaseSembast__readMetaVersion___closure(t0) {
      this.$this = t0;
    },
    DatabaseSembast_open_closure: function DatabaseSembast_open_closure() {
    },
    DatabaseSembast_open_closure0: function DatabaseSembast_open_closure0(t0, t1, t2, t3, t4, t5) {
      var _ = this;
      _._box_0 = t0;
      _.$this = t1;
      _.onUpgradeNeeded = t2;
      _.previousVersion = t3;
      _.changedStores = t4;
      _.deletedStores = t5;
    },
    DatabaseSembast_open_closure1: function DatabaseSembast_open_closure1(t0, t1, t2, t3) {
      var _ = this;
      _._box_0 = t0;
      _.$this = t1;
      _.deletedStores = t2;
      _.changedStores = t3;
    },
    _DatabaseSembast_IdbDatabaseBase_DatabaseWithMetaMixin: function _DatabaseSembast_IdbDatabaseBase_DatabaseWithMetaMixin() {
    },
    IdbFactorySembastImpl: function IdbFactorySembastImpl(t0, t1) {
      this._databaseFactory = t0;
      this._sembast_factory$_path = t1;
    },
    _singleFieldKeyNotNullFilter(keyPath) {
      var t1 = new A.SembastNotEqualsFilter($, $, null);
      t1.FilterFieldMixin___FilterFieldMixin_field_A = keyPath;
      t1.FilterValueMixin___FilterValueMixin_value_A = null;
      t1.FilterAnyInListMixin_anyInList = false;
      return t1;
    },
    _singleFieldKeyEqualsFilter(keyPath, key) {
      return A.SembastEqualsFilter$(keyPath, key, null);
    },
    keyFilter(keyPath, key, multiEntry) {
      var t1, _length, _list, i, t2;
      if (typeof keyPath == "string") {
        if (key == null)
          return A._singleFieldKeyNotNullFilter(keyPath);
        return A._singleFieldKeyEqualsFilter(keyPath, key);
      } else {
        t1 = type$.List_dynamic;
        if (t1._is(keyPath))
          if (key == null) {
            t1 = J.getInterceptor$asx(keyPath);
            _length = t1.get$length(keyPath);
            _list = J.JSArray_JSArray$allocateGrowable(_length, type$.Filter);
            for (i = 0; i < _length; ++i)
              _list[i] = A.keyFilter(t1.$index(keyPath, i), null, false);
            return new A.SembastCompositeFilter(_list);
          } else if (t1._is(key)) {
            t1 = J.getInterceptor$asx(keyPath);
            _length = t1.get$length(keyPath);
            _list = J.JSArray_JSArray$allocateGrowable(_length, type$.Filter);
            for (t2 = J.getInterceptor$asx(key), i = 0; i < _length; ++i)
              _list[i] = A.keyFilter(t1.$index(keyPath, i), t2.$index(key, i), false);
            return new A.SembastCompositeFilter(_list);
          } else
            return new A.SembastCustomFilter(new A.keyFilter_closure());
      }
      throw A.wrapException("keyPath " + A.S(keyPath) + " not supported");
    },
    keyFilter_closure: function keyFilter_closure() {
    },
    ObjectStoreSembast: function ObjectStoreSembast(t0, t1) {
      var _ = this;
      _.meta = t0;
      _.transaction = t1;
      _._sembastStore = _._sembastClient = null;
    },
    ObjectStoreSembast_putImpl_closure: function ObjectStoreSembast_putImpl_closure(t0, t1, t2) {
      this.key = t0;
      this.indexMeta = t1;
      this.fieldValue = t2;
    },
    ObjectStoreSembast_putImpl_closure0: function ObjectStoreSembast_putImpl_closure0(t0, t1, t2) {
      this.$this = t0;
      this.key = t1;
      this.value = t2;
    },
    ObjectStoreSembast_putImpl__closure: function ObjectStoreSembast_putImpl__closure(t0) {
      this.key = t0;
    },
    ObjectStoreSembast_clear_closure: function ObjectStoreSembast_clear_closure(t0) {
      this.$this = t0;
    },
    ObjectStoreSembast_clear_closure0: function ObjectStoreSembast_clear_closure0() {
    },
    ObjectStoreSembast_delete_closure: function ObjectStoreSembast_delete_closure(t0, t1) {
      this.$this = t0;
      this.keyOrRange = t1;
    },
    ObjectStoreSembast_getObject_closure: function ObjectStoreSembast_getObject_closure(t0, t1) {
      this.$this = t0;
      this.key = t1;
    },
    ObjectStoreSembast_openCursor_closure: function ObjectStoreSembast_openCursor_closure(t0) {
      this.ctlr = t0;
    },
    ObjectStoreSembast_put_closure: function ObjectStoreSembast_put_closure(t0, t1, t2) {
      this.$this = t0;
      this.value = t1;
      this.key = t2;
    },
    _ObjectStoreSembast_ObjectStore_ObjectStoreWithMetaMixin: function _ObjectStoreSembast_ObjectStore_ObjectStoreWithMetaMixin() {
    },
    _delayedInit() {
      var $async$goto = 0,
        $async$completer = A._makeAsyncAwaitCompleter(type$.void);
      var $async$_delayedInit = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return A._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$goto = 2;
              return A._asyncAwait(A.Future_Future$delayed(B.Duration_0, null, type$.void), $async$_delayedInit);
            case 2:
              // returning from await.
              // implicit return
              return A._asyncReturn(null, $async$completer);
          }
      });
      return A._asyncStartSync($async$_delayedInit, $async$completer);
    },
    TransactionSembast$(database, meta) {
      var t1 = $.Zone__current;
      t1 = new A.TransactionSembast(new A._SyncCompleter(new A._Future(t1, type$._Future_Database), type$._SyncCompleter_Database), new A._AsyncCompleter(new A._Future(t1, type$._Future_void), type$._AsyncCompleter_void), A._setArrayType([], type$.JSArray_Completer_dynamic), A._setArrayType([], type$.JSArray_Function), A._setArrayType([], type$.JSArray_Future_dynamic), meta, database);
      t1.TransactionSembast$2(database, meta);
      return t1;
    },
    TransactionSembast: function TransactionSembast(t0, t1, t2, t3, t4, t5, t6) {
      var _ = this;
      _._debugId = _.sembastTransaction = null;
      _._sembast_transaction$_index = 0;
      _._inactive = false;
      _._endException = null;
      _._completedCompleter = t0;
      _._lazyExecution = null;
      _._transactionCompleter = t1;
      _._completers = t2;
      _._actions = t3;
      _._futures = t4;
      _.meta = t5;
      _.database = t6;
    },
    TransactionSembast__execute_closure: function TransactionSembast__execute_closure(t0, t1) {
      this.i = t0;
      this.completer = t1;
    },
    TransactionSembast__execute_closure0: function TransactionSembast__execute_closure0(t0, t1) {
      this.i = t0;
      this.completer = t1;
    },
    TransactionSembast__next_closure: function TransactionSembast__next_closure(t0) {
      this.$this = t0;
    },
    TransactionSembast__next_checkNextAction: function TransactionSembast__next_checkNextAction(t0) {
      this.$this = t0;
    },
    TransactionSembast_execute_sembastAction: function TransactionSembast_execute_sembastAction(t0) {
      this.$this = t0;
    },
    TransactionSembast_execute_sembastAction_closure: function TransactionSembast_execute_sembastAction_closure(t0) {
      this.$this = t0;
    },
    TransactionSembast_execute_sembastAction_closure0: function TransactionSembast_execute_sembastAction_closure0(t0) {
      this.$this = t0;
    },
    TransactionSembast_execute_sembastAction_closure1: function TransactionSembast_execute_sembastAction_closure1(t0) {
      this.$this = t0;
    },
    TransactionSembast__enqueue_closure: function TransactionSembast__enqueue_closure(t0) {
      this.T = t0;
    },
    TransactionSembast_closure: function TransactionSembast_closure(t0) {
      this.$this = t0;
    },
    TransactionSembast__completed_closure: function TransactionSembast__completed_closure(t0) {
      this.$this = t0;
    },
    _TransactionSembast_IdbTransactionBase_TransactionWithMetaMixin: function _TransactionSembast_IdbTransactionBase_TransactionWithMetaMixin() {
    },
    isBasicTypeOrNull0(value) {
      if (value == null)
        return true;
      else if (typeof value == "number" || typeof value == "string" || A._isBool(value))
        return true;
      return false;
    },
    _toSembastValue(value) {
      var t1, t2, clone, i, item, converted;
      if (A.isBasicTypeOrNull0(value))
        return value;
      else if (type$.Map_dynamic_dynamic._is(value)) {
        t1 = {};
        t1.clone = null;
        value.forEach$1(0, new A._toSembastValue_closure(t1, value));
        t1 = t1.clone;
        return t1 == null ? value : t1;
      } else if (type$.Uint8List._is(value))
        return new A.Blob(value);
      else if (type$.List_dynamic._is(value)) {
        for (t1 = J.getInterceptor$asx(value), t2 = type$.dynamic, clone = null, i = 0; i < t1.get$length(value); ++i) {
          item = t1.$index(value, i);
          converted = A._toSembastValue(item);
          if (converted == null ? item != null : converted !== item) {
            if (clone == null)
              clone = A.List_List$from(value, true, t2);
            B.JSArray_methods.$indexSet(clone, i, converted);
          }
        }
        return clone == null ? value : clone;
      } else if (value instanceof A.DateTime)
        return A.Timestamp_Timestamp$fromDateTime(value);
      else
        throw A.wrapException(A.ArgumentError$value(value, null, null));
    },
    toSembastValue(value) {
      var e, t1, exception, t2, converted = null;
      try {
        t1 = A._toSembastValue(value);
        t1.toString;
        converted = t1;
      } catch (exception) {
        t1 = A.unwrapException(exception);
        if (t1 instanceof A.ArgumentError) {
          e = t1;
          t1 = e.get$invalidValue();
          t2 = e.get$invalidValue();
          throw A.wrapException(A.ArgumentError$value(t1, J.get$runtimeType$(t2 == null ? type$.Object._as(t2) : t2).toString$0(0) + " in " + value.toString$0(0), "not supported"));
        } else
          throw exception;
      }
      if (type$.Map_dynamic_dynamic._is(converted) && !type$.Map_of_String_and_nullable_Object._is(converted))
        converted = converted.cast$2$0(0, type$.String, type$.nullable_Object);
      return converted;
    },
    _fromSembastValue(value) {
      var t1, t2, clone, i, item, converted;
      if (A.isBasicTypeOrNull0(value))
        return value;
      else if (type$.Map_dynamic_dynamic._is(value)) {
        t1 = {};
        t1.clone = null;
        value.forEach$1(0, new A._fromSembastValue_closure(t1, value));
        t1 = t1.clone;
        return t1 == null ? value : t1;
      } else if (type$.List_dynamic._is(value)) {
        for (t1 = J.getInterceptor$asx(value), t2 = type$.dynamic, clone = null, i = 0; i < t1.get$length(value); ++i) {
          item = t1.$index(value, i);
          converted = A._fromSembastValue(item);
          if (converted == null ? item != null : converted !== item) {
            if (clone == null)
              clone = A.List_List$from(value, true, t2);
            B.JSArray_methods.$indexSet(clone, i, converted);
          }
        }
        return clone == null ? value : clone;
      } else if (value instanceof A.Timestamp)
        return A.DateTime$fromMicrosecondsSinceEpoch(value.get$microsecondsSinceEpoch(), true);
      else if (value instanceof A.Blob)
        return value.bytes;
      else
        throw A.wrapException(A.ArgumentError$value(value, null, null));
    },
    fromSembastValue(value) {
      var e, t1, exception, t2, converted = null;
      try {
        t1 = A._fromSembastValue(value);
        t1.toString;
        converted = t1;
      } catch (exception) {
        t1 = A.unwrapException(exception);
        if (t1 instanceof A.ArgumentError) {
          e = t1;
          t1 = e.get$invalidValue();
          t2 = e.get$invalidValue();
          throw A.wrapException(A.ArgumentError$value(t1, J.get$runtimeType$(t2 == null ? type$.Object._as(t2) : t2).toString$0(0) + " in " + A.S(value), "not supported"));
        } else
          throw exception;
      }
      if (type$.Map_dynamic_dynamic._is(converted) && !type$.Map_of_String_and_nullable_Object._is(converted))
        converted = converted.cast$2$0(0, type$.String, type$.nullable_Object);
      return converted;
    },
    _toSembastValue_closure: function _toSembastValue_closure(t0, t1) {
      this._box_0 = t0;
      this.map = t1;
    },
    _fromSembastValue_closure: function _fromSembastValue_closure(t0, t1) {
      this._box_0 = t0;
      this.map = t1;
    },
    DatabaseMode: function DatabaseMode(t0) {
      this._mode = t0;
    },
    DatabaseException$closed() {
      return new A.DatabaseException(3, "database is closed");
    },
    DatabaseException: function DatabaseException(t0, t1) {
      this._code = t0;
      this._exception$_message = t1;
    },
    SortOrder: function SortOrder(t0) {
      this.$ti = t0;
    },
    Blob: function Blob(t0) {
      this.bytes = t0;
    },
    Blob_operator$eq_closure: function Blob_operator$eq_closure(t0, t1) {
      this.$this = t0;
      this.other = t1;
    },
    DatabaseChangesListener: function DatabaseChangesListener(t0) {
      this._changes_listener$_stores = t0;
    },
    cooperateNeeded(cooperator) {
      var t1 = cooperator == null ? null : cooperator.get$needCooperate();
      return t1 === true;
    },
    Cooperator: function Cooperator(t0) {
      this._cooperateStopWatch = t0;
      this._paused = false;
    },
    Cooperator_cooperate_closure: function Cooperator_cooperate_closure(t0) {
      this.$this = t0;
    },
    StoreContent: function StoreContent(t0, t1) {
      this.store = t0;
      this._database_content$_map = t1;
    },
    DatabaseContent: function DatabaseContent() {
    },
    DatabaseListenerContent: function DatabaseListenerContent(t0) {
      this._database_content$_map = t0;
    },
    TxnDatabaseContent: function TxnDatabaseContent(t0, t1) {
      this._records = t0;
      this._database_content$_map = t1;
    },
    TxnDatabaseContent_addTxnStoreRecords_closure: function TxnDatabaseContent_addTxnStoreRecords_closure() {
    },
    SembastDatabaseFactory: function SembastDatabaseFactory() {
    },
    SembastDatabaseFactoryMixin: function SembastDatabaseFactoryMixin() {
    },
    SembastDatabaseFactoryMixin_deleteDatabase_closure: function SembastDatabaseFactoryMixin_deleteDatabase_closure(t0) {
      this.helper = t0;
    },
    CommitEntries: function CommitEntries() {
    },
    CommitData: function CommitData() {
      var _ = this;
      _.txnRecords = _.revision = null;
      _.__CommitEntries_upgrading_A = $;
      _.upgradingMeta = null;
    },
    SembastDatabaseMixin: function SembastDatabaseMixin() {
    },
    SembastDatabase: function SembastDatabase(t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13) {
      var _ = this;
      _.openHelper = t0;
      _.logV = t1;
      _._storageBase = t2;
      _._jdbRevision = _._storageJdbRevisionUpdateSubscription = _._storageJdb = _._storageFs = null;
      _.databaseLock = t3;
      _.transactionLock = t4;
      _.notificationLock = t5;
      _.listener = t6;
      _.changesListener = t7;
      _._txnId = 0;
      _._meta = null;
      _._upgrading = false;
      _._upgradingMeta = null;
      _._closed = _._opened = false;
      _._mainStore = _._openTransaction = null;
      _._database_impl$_stores = t8;
      _._txnDroppedStores = t9;
      _._txnStoreLastIntKeys = t10;
      _._transaction = null;
      _._pendingListenerContent = t11;
      _.lazyStorageOperations = t12;
      _._exportStat = null;
      _.cooperator = t13;
    },
    SembastDatabase_txnCompact_writeCurrent: function SembastDatabase_txnCompact_writeCurrent(t0, t1, t2) {
      this._box_0 = t0;
      this.lines = t1;
      this.sink = t2;
    },
    SembastDatabase_txnCompact_addStringLine: function SembastDatabase_txnCompact_addStringLine(t0, t1, t2, t3, t4) {
      var _ = this;
      _._box_0 = t0;
      _.$this = t1;
      _.exportStat = t2;
      _.lines = t3;
      _.writeCurrent = t4;
    },
    SembastDatabase_txnCompact_addLine: function SembastDatabase_txnCompact_addLine(t0, t1, t2) {
      this.$this = t0;
      this.hasAsyncCodec = t1;
      this.addStringLine = t2;
    },
    SembastDatabase_commitInMemory_saveInMemory: function SembastDatabase_commitInMemory_saveInMemory(t0, t1) {
      this.$this = t0;
      this.txnRecords = t1;
    },
    SembastDatabase_flush_closure: function SembastDatabase_flush_closure() {
    },
    SembastDatabase_open_closure: function SembastDatabase_open_closure(t0, t1, t2, t3) {
      var _ = this;
      _._box_2 = t0;
      _.$this = t1;
      _.options = t2;
      _.mode = t3;
    },
    SembastDatabase_open_closure_handleVersionChanged: function SembastDatabase_open_closure_handleVersionChanged(t0, t1, t2) {
      this._box_1 = t0;
      this.$this = t1;
      this.options = t2;
    },
    SembastDatabase_open__handleVersionChanged_closure: function SembastDatabase_open__handleVersionChanged_closure(t0, t1, t2, t3, t4) {
      var _ = this;
      _._box_1 = t0;
      _.$this = t1;
      _.newVersion = t2;
      _.options = t3;
      _.oldVersion = t4;
    },
    SembastDatabase_open_closure_openDone: function SembastDatabase_open_closure_openDone(t0, t1, t2, t3, t4) {
      var _ = this;
      _._box_1 = t0;
      _._box_2 = t1;
      _.$this = t2;
      _.options = t3;
      _.handleVersionChanged = t4;
    },
    SembastDatabase_open_closure_findOrCreate: function SembastDatabase_open_closure_findOrCreate(t0, t1) {
      this.$this = t0;
      this.mode = t1;
    },
    SembastDatabase_close_closure: function SembastDatabase_close_closure(t0) {
      this.$this = t0;
    },
    SembastDatabase_databaseOperation_closure: function SembastDatabase_databaseOperation_closure(t0, t1) {
      this.$this = t0;
      this.action = t1;
    },
    SembastDatabase__runTransaction_closure: function SembastDatabase__runTransaction_closure(t0, t1) {
      this.$this = t0;
      this.jdbIncrementRevisionStatus = t1;
    },
    SembastDatabase__runTransaction_closure0: function SembastDatabase__runTransaction_closure0(t0, t1, t2, t3, t4) {
      var _ = this;
      _._box_0 = t0;
      _.$this = t1;
      _.action = t2;
      _.jdbIncrementRevisionStatus = t3;
      _.T = t4;
    },
    SembastDatabase__runTransaction_closure_transactionCleanUp: function SembastDatabase__runTransaction_closure_transactionCleanUp(t0, t1) {
      this._box_0 = t0;
      this.$this = t1;
    },
    SembastDatabase__runTransaction__closure: function SembastDatabase__runTransaction__closure(t0, t1, t2) {
      this.$this = t0;
      this.action = t1;
      this.T = t2;
    },
    SembastDatabase__runTransaction_closure_postTransaction: function SembastDatabase__runTransaction_closure_postTransaction(t0, t1) {
      this._box_0 = t0;
      this.$this = t1;
    },
    SembastDatabase__runTransaction_closure1: function SembastDatabase__runTransaction_closure1(t0, t1) {
      this._box_0 = t0;
      this.$this = t1;
    },
    SembastDatabase_inTransaction_closure: function SembastDatabase_inTransaction_closure(t0, t1) {
      this.action = t0;
      this.T = t1;
    },
    DatabaseExportStat: function DatabaseExportStat() {
      this.compactCount = this.obsoleteLineCount = this.lineCount = 0;
    },
    JdbImportResult: function JdbImportResult(t0) {
      this.delta = t0;
    },
    _SembastDatabase_Object_SembastDatabaseMixin: function _SembastDatabase_Object_SembastDatabaseMixin() {
    },
    DatabaseOpenHelper$(factory, path, options) {
      var t1 = new A.DatabaseOpenHelper(factory, path, options, A.Lock_Lock());
      t1.openMode = B.DatabaseMode_3;
      return t1;
    },
    DatabaseOpenHelper: function DatabaseOpenHelper(t0, t1, t2, t3) {
      var _ = this;
      _.factory = t0;
      _.path = t1;
      _.openMode = null;
      _.options = t2;
      _.lock = t3;
      _.database = null;
    },
    DatabaseOpenHelper_openDatabase_closure: function DatabaseOpenHelper_openDatabase_closure(t0) {
      this.$this = t0;
    },
    DatabaseOpenOptions: function DatabaseOpenOptions(t0, t1, t2, t3) {
      var _ = this;
      _.version = t0;
      _.onVersionChanged = t1;
      _.mode = t2;
      _.codec = t3;
    },
    filterMatchesRecord(filter, record) {
      if (filter == null)
        return true;
      return filter.matchesRecord$1(new A.SembastRecordRawSnapshot(record, type$.SembastRecordRawSnapshot_of_nullable_Object_and_nullable_Object));
    },
    SembastEqualsFilter$(field, value, anyInList) {
      var t1 = new A.SembastEqualsFilter($, $, null);
      t1.FilterFieldMixin___FilterFieldMixin_field_A = field;
      t1.FilterValueMixin___FilterValueMixin_value_A = value;
      t1.FilterAnyInListMixin_anyInList = anyInList;
      return t1;
    },
    SembastFilterBase: function SembastFilterBase() {
    },
    SembastCustomFilter: function SembastCustomFilter(t0) {
      this.matches = t0;
    },
    FilterAnyInListMixin: function FilterAnyInListMixin() {
    },
    FilterValueMixin: function FilterValueMixin() {
    },
    FilterFieldMixin: function FilterFieldMixin() {
    },
    _FilterSmartMatchMixin: function _FilterSmartMatchMixin() {
    },
    _FilterSmartMatchMixin_smartMatchesRecord_matchValue: function _FilterSmartMatchMixin_smartMatchesRecord_matchValue(t0, t1) {
      this.$this = t0;
      this.match = t1;
    },
    SembastEqualsFilter: function SembastEqualsFilter(t0, t1, t2) {
      this.FilterFieldMixin___FilterFieldMixin_field_A = t0;
      this.FilterValueMixin___FilterValueMixin_value_A = t1;
      this.FilterAnyInListMixin_anyInList = t2;
    },
    SembastEqualsFilter_matchesRecord_match: function SembastEqualsFilter_matchesRecord_match(t0) {
      this.$this = t0;
    },
    SembastNotEqualsFilter: function SembastNotEqualsFilter(t0, t1, t2) {
      this.FilterFieldMixin___FilterFieldMixin_field_A = t0;
      this.FilterValueMixin___FilterValueMixin_value_A = t1;
      this.FilterAnyInListMixin_anyInList = t2;
    },
    SembastCompositeFilter: function SembastCompositeFilter(t0) {
      this.filters = t0;
    },
    _SembastEqualsFilter_SembastFilterBase_FilterAnyInListMixin: function _SembastEqualsFilter_SembastFilterBase_FilterAnyInListMixin() {
    },
    _SembastEqualsFilter_SembastFilterBase_FilterAnyInListMixin_FilterValueMixin: function _SembastEqualsFilter_SembastFilterBase_FilterAnyInListMixin_FilterValueMixin() {
    },
    _SembastEqualsFilter_SembastFilterBase_FilterAnyInListMixin_FilterValueMixin_FilterFieldMixin: function _SembastEqualsFilter_SembastFilterBase_FilterAnyInListMixin_FilterValueMixin_FilterFieldMixin() {
    },
    _SembastEqualsFilter_SembastFilterBase_FilterAnyInListMixin_FilterValueMixin_FilterFieldMixin__FilterSmartMatchMixin: function _SembastEqualsFilter_SembastFilterBase_FilterAnyInListMixin_FilterValueMixin_FilterFieldMixin__FilterSmartMatchMixin() {
    },
    finderMatchesFilterAndBoundaries(finder, record) {
      if (!A.finderRecordMatchBoundaries(finder, record))
        return false;
      if (!A.filterMatchesRecord(finder.filter, record))
        return false;
      return true;
    },
    recordsLimit(results, finder) {
      var t1 = finder.limit;
      if (t1 != null)
        results = B.JSArray_methods.sublist$2(results, 0, Math.min(t1, results.length));
      return results;
    },
    SembastFinder: function SembastFinder(t0, t1, t2, t3, t4, t5) {
      var _ = this;
      _.filter = t0;
      _.offset = t1;
      _.limit = t2;
      _.start = t3;
      _.end = t4;
      _.sortOrders = t5;
    },
    immutableValueOrNull(value) {
      if (type$.Map_dynamic_dynamic._is(value))
        return new A.ImmutableMap(value.cast$2$0(0, type$.String, type$.nullable_Object), type$.ImmutableMap_of_String_and_nullable_Object);
      else if (type$.Iterable_dynamic._is(value))
        return new A.ImmutableList(J.toList$1$growable$ax(value, false), type$.ImmutableList_nullable_Object);
      return value;
    },
    ImmutableList: function ImmutableList(t0, t1) {
      this._list = t0;
      this.$ti = t1;
    },
    ImmutableMap: function ImmutableMap(t0, t1) {
      this._immutable_utils$_map = t0;
      this.$ti = t1;
    },
    sembastTypeAdaptersToMap(adapters) {
      var _i, adapter,
        adaptersMap = A.LinkedHashMap_LinkedHashMap$_empty(type$.String, type$.SembastTypeAdapter_dynamic_dynamic);
      for (_i = 0; _i < 2; ++_i) {
        adapter = adapters[_i];
        adaptersMap.$indexSet(0, adapter.get$name(), adapter);
      }
      return adaptersMap;
    },
    _looksLikeCustomType(map) {
      var t1, key;
      if (map.get$length(map) === 1) {
        t1 = map.get$keys();
        key = t1.get$first(t1);
        if (typeof key == "string")
          return B.JSString_methods.startsWith$1(key, "@");
        throw A.wrapException(A.ArgumentError$value(key, null, null));
      }
      return false;
    },
    _toJsonEncodable(value, adapters) {
      var t1, t2, clone, i, item, converted;
      if (A.isBasicTypeOrNull(value))
        return value;
      for (t1 = adapters._map, t1 = new A.LinkedHashMapValueIterator(t1, t1._modifications, t1._first, adapters.$ti._eval$1("LinkedHashMapValueIterator<1>")); t1.moveNext$0();) {
        t2 = t1.__js_helper$_current;
        if (t2.isType$1(value)) {
          t1 = t2.get$name();
          A._instanceType(t2)._eval$1("Codec.S")._as(value);
          return A.LinkedHashMap_LinkedHashMap$_literal(["@" + t1, t2.get$encoder().convert$1(value)], type$.String, type$.nullable_Object);
        }
      }
      if (type$.Map_dynamic_dynamic._is(value)) {
        t1 = {};
        if (A._looksLikeCustomType(value))
          return A.LinkedHashMap_LinkedHashMap$_literal(["@", value], type$.String, type$.nullable_Object);
        t1.clone = null;
        value.forEach$1(0, new A._toJsonEncodable_closure(t1, adapters, value));
        t1 = t1.clone;
        return t1 == null ? value : t1;
      } else if (type$.List_dynamic._is(value)) {
        for (t1 = J.getInterceptor$asx(value), t2 = type$.dynamic, clone = null, i = 0; i < t1.get$length(value); ++i) {
          item = t1.$index(value, i);
          converted = A._toJsonEncodable(item, adapters);
          if (converted == null ? item != null : converted !== item) {
            if (clone == null)
              clone = A.List_List$from(value, true, t2);
            B.JSArray_methods.$indexSet(clone, i, converted);
          }
        }
        return clone == null ? value : clone;
      } else
        throw A.wrapException(A.ArgumentError$value(value, null, null));
    },
    toJsonEncodable(value, adapters) {
      var e, exception, t1, converted = null;
      try {
        converted = A._toJsonEncodable(value, adapters);
      } catch (exception) {
        t1 = A.unwrapException(exception);
        if (t1 instanceof A.ArgumentError) {
          e = t1;
          throw A.wrapException(A.ArgumentError$value(e.get$invalidValue(), J.get$runtimeType$(e.get$invalidValue()).toString$0(0) + " in " + A.S(value), "not supported"));
        } else
          throw exception;
      }
      if (type$.Map_dynamic_dynamic._is(converted) && !type$.Map_of_String_and_nullable_Object._is(converted))
        converted = converted.cast$2$0(0, type$.String, type$.nullable_Object);
      t1 = converted;
      t1.toString;
      return t1;
    },
    JsonEncodableEncoder: function JsonEncodableEncoder(t0) {
      this._codec = t0;
    },
    JsonEncodableDecoder: function JsonEncodableDecoder(t0) {
      this._codec = t0;
    },
    JsonEncodableCodec: function JsonEncodableCodec() {
      this._adapters = null;
      this.__JsonEncodableCodec__encoder_A = this.__JsonEncodableCodec__decoder_A = $;
    },
    _toJsonEncodable_closure: function _toJsonEncodable_closure(t0, t1, t2) {
      this._box_0 = t0;
      this.adapters = t1;
      this.map = t2;
    },
    DatabaseListener: function DatabaseListener(t0) {
      this._listener$_stores = t0;
    },
    DatabaseFactoryMemory: function DatabaseFactoryMemory(t0, t1, t2) {
      this._exists = t0;
      this._databases = t1;
      this.SembastDatabaseFactoryMixin__databaseOpenHelpers = t2;
    },
    DatabaseStorageMemory: function DatabaseStorageMemory(t0, t1) {
      this.factory = t0;
      this.path = t1;
    },
    _DatabaseFactoryMemory_SembastDatabaseFactory_SembastDatabaseFactoryMixin: function _DatabaseFactoryMemory_SembastDatabaseFactory_SembastDatabaseFactoryMixin() {
    },
    Meta: function Meta(t0, t1) {
      this.version = t0;
      this.sembastVersion = 1;
      this.codecSignature = t1;
    },
    ImmutableSembastRecordJdb$(ref, value, deleted, revision) {
      var t1 = new A.ImmutableSembastRecordJdb(null, $, $, null);
      t1.ImmutableSembastRecord$3$deleted(ref, value, deleted);
      t1.RecordSnapshotMixin_revision = revision;
      return t1;
    },
    ImmutableSembastRecord$(ref, value, deleted) {
      var t1 = new A.ImmutableSembastRecord(null, $, $, null);
      t1.ImmutableSembastRecord$3$deleted(ref, value, deleted);
      return t1;
    },
    ImmutableSembastRecord$noValue(ref, deleted) {
      var t1 = new A.ImmutableSembastRecord(null, $, $, null);
      t1.ImmutableSembastRecord$noValue$2$deleted(ref, true);
      return t1;
    },
    SembastRecordHelperMixin: function SembastRecordHelperMixin() {
    },
    SembastRecordMixin: function SembastRecordMixin() {
    },
    ImmutableSembastRecordJdb: function ImmutableSembastRecordJdb(t0, t1, t2, t3) {
      var _ = this;
      _.RecordSnapshotMixin_revision = t0;
      _.RecordSnapshotMixin___RecordSnapshotMixin_ref_A = t1;
      _.RecordSnapshotMixin___RecordSnapshotMixin_rawValue_A = t2;
      _.SembastRecordMixin__deleted = t3;
    },
    ImmutableSembastRecord: function ImmutableSembastRecord(t0, t1, t2, t3) {
      var _ = this;
      _.RecordSnapshotMixin_revision = t0;
      _.RecordSnapshotMixin___RecordSnapshotMixin_ref_A = t1;
      _.RecordSnapshotMixin___RecordSnapshotMixin_rawValue_A = t2;
      _.SembastRecordMixin__deleted = t3;
    },
    TxnRecord: function TxnRecord(t0) {
      this.record = t0;
    },
    _ImmutableSembastRecord_Object_SembastRecordMixin: function _ImmutableSembastRecord_Object_SembastRecordMixin() {
    },
    _ImmutableSembastRecord_Object_SembastRecordMixin_SembastRecordHelperMixin: function _ImmutableSembastRecord_Object_SembastRecordMixin_SembastRecordHelperMixin() {
    },
    _ImmutableSembastRecord_Object_SembastRecordMixin_SembastRecordHelperMixin_RecordSnapshotMixin: function _ImmutableSembastRecord_Object_SembastRecordMixin_SembastRecordHelperMixin_RecordSnapshotMixin() {
    },
    _TxnRecord_Object_SembastRecordHelperMixin: function _TxnRecord_Object_SembastRecordHelperMixin() {
    },
    SembastRecordRef$(store, key, $K, $V) {
      var t1 = $K._eval$1("@<0>")._bind$1($V)._eval$1("SembastRecordRef<1,2>"),
        t2 = new A.SembastRecordRef($, $, t1);
      t2.RecordRefMixin___RecordRefMixin_store_A = t1._eval$1("StoreRef<1,2>")._as(store);
      t2.RecordRefMixin___RecordRefMixin_key_A = t1._precomputed1._as(key);
      return t2;
    },
    SembastRecordRefExtension_add(_this, databaseClient, value, $K, $V) {
      return A.SembastRecordRefExtension_add$body(_this, databaseClient, value, $K, $V, $K._eval$1("0?"));
    },
    SembastRecordRefExtension_add$body(_this, databaseClient, value, $K, $V, $async$type) {
      var $async$goto = 0,
        $async$completer = A._makeAsyncAwaitCompleter($async$type),
        $async$returnValue, t1;
      var $async$SembastRecordRefExtension_add = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return A._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = {};
              t1.value = value;
              t1.value = databaseClient.get$sembastDatabase().sanitizeInputValue$1$1(value, $V);
              $async$goto = 3;
              return A._asyncAwait(databaseClient.inTransaction$1$1(new A.SembastRecordRefExtension_add_closure(t1, databaseClient, _this, $K), $K._eval$1("0?")), $async$SembastRecordRefExtension_add);
            case 3:
              // returning from await.
              $async$returnValue = $async$result;
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return A._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return A._asyncStartSync($async$SembastRecordRefExtension_add, $async$completer);
    },
    SembastRecordRefExtension_put(_this, databaseClient, value, $K, $V) {
      return A.SembastRecordRefExtension_put$body(_this, databaseClient, value, $K, $V, $V);
    },
    SembastRecordRefExtension_put$body(_this, databaseClient, value, $K, $V, $async$type) {
      var $async$goto = 0,
        $async$completer = A._makeAsyncAwaitCompleter($async$type),
        $async$returnValue, t1, $async$temp1;
      var $async$SembastRecordRefExtension_put = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return A._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = {};
              t1.value = value;
              t1.value = databaseClient.get$sembastDatabase().sanitizeInputValue$1$2$update(value, null, $V);
              $async$temp1 = $V._eval$1("0?");
              $async$goto = 3;
              return A._asyncAwait(databaseClient.inTransaction$1$1(new A.SembastRecordRefExtension_put_closure(t1, databaseClient, _this, null, null), type$.nullable_Object), $async$SembastRecordRefExtension_put);
            case 3:
              // returning from await.
              t1 = $async$temp1._as($async$result);
              t1.toString;
              $async$returnValue = t1;
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return A._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return A._asyncStartSync($async$SembastRecordRefExtension_put, $async$completer);
    },
    SembastRecordRefExtension_get(_this, databaseClient, $K, $V) {
      return A.SembastRecordRefExtension_get$body(_this, databaseClient, $K, $V, $V._eval$1("0?"));
    },
    SembastRecordRefExtension_get$body(_this, databaseClient, $K, $V, $async$type) {
      var $async$goto = 0,
        $async$completer = A._makeAsyncAwaitCompleter($async$type),
        $async$returnValue, t1;
      var $async$SembastRecordRefExtension_get = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return A._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$goto = 3;
              return A._asyncAwait(A.SembastRecordRefExtension_getSnapshot(_this, databaseClient, $K, $V), $async$SembastRecordRefExtension_get);
            case 3:
              // returning from await.
              t1 = $async$result;
              $async$returnValue = t1 == null ? null : t1.get$value();
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return A._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return A._asyncStartSync($async$SembastRecordRefExtension_get, $async$completer);
    },
    SembastRecordRefExtension_getSnapshot(_this, databaseClient, $K, $V) {
      return A.SembastRecordRefExtension_getSnapshot$body(_this, databaseClient, $K, $V, $K._eval$1("@<0>")._bind$1($V)._eval$1("RecordSnapshot<1,2>?"));
    },
    SembastRecordRefExtension_getSnapshot$body(_this, databaseClient, $K, $V, $async$type) {
      var $async$goto = 0,
        $async$completer = A._makeAsyncAwaitCompleter($async$type),
        $async$returnValue, t2, t3, t1;
      var $async$SembastRecordRefExtension_getSnapshot = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return A._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = _this.RecordRefMixin___RecordRefMixin_store_A;
              t1 === $ && A.throwLateFieldNI("store");
              t1 = databaseClient.getSembastStore$1(t1);
              t2 = databaseClient.get$sembastTransaction();
              t3 = _this.RecordRefMixin___RecordRefMixin_key_A;
              t3 === $ && A.throwLateFieldNI("key");
              $async$goto = 3;
              return A._asyncAwait(t1.txnGetImmutableRecord$2(t2, t3), $async$SembastRecordRefExtension_getSnapshot);
            case 3:
              // returning from await.
              t3 = $async$result;
              if (t3 == null)
                t1 = null;
              else {
                t1 = A.RecordSnapshotMixin.prototype.get$value.call(t3);
                t1 = A.immutableValueOrNull(t1);
                t1.toString;
                $V._as(t1);
                t2 = $K._eval$1("@<0>")._bind$1($V)._eval$1("SembastRecordSnapshot<1,2>");
                t3 = new A.SembastRecordSnapshot(null, $, $, t2);
                t3.RecordSnapshotMixin___RecordSnapshotMixin_ref_A = t2._eval$1("RecordRef<RecordSnapshotMixin.K,RecordSnapshotMixin.V>")._as(_this);
                t3.RecordSnapshotMixin___RecordSnapshotMixin_rawValue_A = t2._eval$1("RecordSnapshotMixin.V")._as(t1);
                t1 = t3;
              }
              $async$returnValue = t1;
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return A._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return A._asyncStartSync($async$SembastRecordRefExtension_getSnapshot, $async$completer);
    },
    SembastRecordRefExtension_delete(_this, databaseClient, $K, $V) {
      return databaseClient.inTransaction$1$1(new A.SembastRecordRefExtension_delete_closure(databaseClient, _this, $K), $K._eval$1("0?"));
    },
    RecordRefMixin: function RecordRefMixin() {
    },
    SembastRecordRef: function SembastRecordRef(t0, t1, t2) {
      this.RecordRefMixin___RecordRefMixin_store_A = t0;
      this.RecordRefMixin___RecordRefMixin_key_A = t1;
      this.$ti = t2;
    },
    SembastRecordRefExtension_add_closure: function SembastRecordRefExtension_add_closure(t0, t1, t2, t3) {
      var _ = this;
      _._box_0 = t0;
      _.client = t1;
      _._this = t2;
      _.K = t3;
    },
    SembastRecordRefExtension_put_closure: function SembastRecordRefExtension_put_closure(t0, t1, t2, t3, t4) {
      var _ = this;
      _._box_0 = t0;
      _.client = t1;
      _._this = t2;
      _.merge = t3;
      _.ifNotExists = t4;
    },
    SembastRecordRefExtension_delete_closure: function SembastRecordRefExtension_delete_closure(t0, t1, t2) {
      this.client = t0;
      this._this = t1;
      this.K = t2;
    },
    _SembastRecordRef_Object_RecordRefMixin: function _SembastRecordRef_Object_RecordRefMixin() {
    },
    SembastRecordSnapshot$fromRecord(store, record, $K, $V) {
      var t1 = $K._eval$1("@<0>")._bind$1($V)._eval$1("SembastRecordSnapshot<1,2>"),
        t2 = new A.SembastRecordSnapshot(null, $, $, t1),
        t3 = A.RecordSnapshotMixin.prototype.get$key.call(record),
        t4 = store.$ti,
        t5 = t4._precomputed1;
      t2.RecordSnapshotMixin___RecordSnapshotMixin_ref_A = t1._eval$1("RecordRef<RecordSnapshotMixin.K,RecordSnapshotMixin.V>")._as(A.SembastRecordRef$(store, t5._as($K._as(t3)), t5, t4._rest[1]));
      t4 = A.RecordSnapshotMixin.prototype.get$value.call(record);
      t3 = A.immutableValueOrNull(t4);
      t3.toString;
      t2.RecordSnapshotMixin___RecordSnapshotMixin_rawValue_A = t1._eval$1("RecordSnapshotMixin.V")._as($V._as(t3));
      return t2;
    },
    RecordSnapshotMixin: function RecordSnapshotMixin() {
    },
    SembastRecordSnapshot: function SembastRecordSnapshot(t0, t1, t2, t3) {
      var _ = this;
      _.RecordSnapshotMixin_revision = t0;
      _.RecordSnapshotMixin___RecordSnapshotMixin_ref_A = t1;
      _.RecordSnapshotMixin___RecordSnapshotMixin_rawValue_A = t2;
      _.$ti = t3;
    },
    SembastRecordRawSnapshot: function SembastRecordRawSnapshot(t0, t1) {
      this.snapshot = t0;
      this.$ti = t1;
    },
    _SembastRecordSnapshot_Object_RecordSnapshotMixin: function _SembastRecordSnapshot_Object_RecordSnapshotMixin() {
    },
    SembastRecordsRefExtension_getSnapshots(_this, databaseClient, $K, $V) {
      return A.SembastRecordsRefExtension_getSnapshots$body(_this, databaseClient, $K, $V, $K._eval$1("@<0>")._bind$1($V)._eval$1("List<RecordSnapshot<1,2>?>"));
    },
    SembastRecordsRefExtension_getSnapshots$body(_this, databaseClient, $K, $V, $async$type) {
      var $async$goto = 0,
        $async$completer = A._makeAsyncAwaitCompleter($async$type),
        $async$returnValue, t1, $async$temp1, $async$temp2;
      var $async$SembastRecordsRefExtension_getSnapshots = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return A._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = _this.RecordsRefMixin___RecordsRefMixin_store_A;
              t1 === $ && A.throwLateFieldNI("store");
              $async$temp1 = A;
              $async$temp2 = _this;
              $async$goto = 3;
              return A._asyncAwait(databaseClient.getSembastStore$1(t1).txnGetImmutableRecords$1$2(databaseClient.get$sembastTransaction(), _this, $K), $async$SembastRecordsRefExtension_getSnapshots);
            case 3:
              // returning from await.
              $async$returnValue = $async$temp1.SembastRecordsRefExtensionPrv_snapshotsFromImmutableRecords($async$temp2, $async$result, $K, $V);
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return A._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return A._asyncStartSync($async$SembastRecordsRefExtension_getSnapshots, $async$completer);
    },
    SembastRecordsRefExtensionPrv_snapshotsFromImmutableRecords(_this, records, $K, $V) {
      var t4, t5, t6, t7, t8, t9,
        t1 = A._setArrayType([], $K._eval$1("@<0>")._bind$1($V)._eval$1("JSArray<RecordSnapshot<1,2>?>")),
        t2 = $K._eval$1("@<0>")._bind$1($V)._eval$1("SembastRecordSnapshot<1,2>"),
        t3 = J.getInterceptor$asx(records),
        i = 0;
      while (true) {
        t4 = _this.RecordsRefMixin___RecordsRefMixin_keys_A;
        t4 === $ && A.throwLateFieldNI("keys");
        if (!(i < t4.length))
          break;
        t4 = _this.RecordsRefMixin___RecordsRefMixin_store_A;
        t4 === $ && A.throwLateFieldNI("store");
        t5 = t3.$index(records, i);
        if (t5 == null)
          t4 = null;
        else {
          t6 = new A.SembastRecordSnapshot(null, $, $, t2);
          t7 = A.RecordSnapshotMixin.prototype.get$key.call(t5);
          t8 = t4.$ti;
          t7 = t8._precomputed1._as($K._as(t7));
          t8 = t8._eval$1("SembastRecordRef<1,2>");
          t9 = new A.SembastRecordRef($, $, t8);
          t9.RecordRefMixin___RecordRefMixin_store_A = t8._eval$1("StoreRef<1,2>")._as(t4);
          t9.RecordRefMixin___RecordRefMixin_key_A = t8._precomputed1._as(t7);
          t6.RecordSnapshotMixin___RecordSnapshotMixin_ref_A = t2._eval$1("RecordRef<RecordSnapshotMixin.K,RecordSnapshotMixin.V>")._as(t9);
          t5 = A.RecordSnapshotMixin.prototype.get$value.call(t5);
          t4 = A.immutableValueOrNull(t5);
          t4.toString;
          t6.RecordSnapshotMixin___RecordSnapshotMixin_rawValue_A = t2._eval$1("RecordSnapshotMixin.V")._as($V._as(t4));
          t4 = t6;
        }
        t1.push(t4);
        ++i;
      }
      return t1;
    },
    RecordsRefMixin: function RecordsRefMixin() {
    },
    SembastRecordsRef: function SembastRecordsRef(t0, t1, t2) {
      this.RecordsRefMixin___RecordsRefMixin_store_A = t0;
      this.RecordsRefMixin___RecordsRefMixin_keys_A = t1;
      this.$ti = t2;
    },
    _SembastRecordsRef_Object_RecordsRefMixin: function _SembastRecordsRef_Object_RecordsRefMixin() {
    },
    Sort: function Sort(t0) {
      this.cooperator = t0;
    },
    SembastSortOrder$(field, ascending, nullLast, $T) {
      return new A.SembastSortOrder(field, ascending, false, $T._eval$1("SembastSortOrder<0>"));
    },
    SembastSortOrderBase: function SembastSortOrderBase() {
    },
    SembastSortOrder: function SembastSortOrder(t0, t1, t2, t3) {
      var _ = this;
      _.field = t0;
      _.ascending = t1;
      _.nullLast = t2;
      _.$ti = t3;
    },
    StorageBase: function StorageBase() {
    },
    DatabaseStorage: function DatabaseStorage() {
    },
    finderRecordMatchBoundaries(finder, result) {
      return true;
    },
    _FinderData$(sembastFinder) {
      var t1 = new A._FinderData(sembastFinder);
      if (t1.get$usePreordered())
        t1.___FinderData_preOrderedResults_A = type$.SplayTreeMap_of_nullable_Object_and_ImmutableSembastRecord._as(A.SplayTreeMap$(A.utils__compareKey$closure(), type$.nullable_Object, type$.ImmutableSembastRecord));
      else
        t1.___FinderData_results_A = type$.List_ImmutableSembastRecord._as(A._setArrayType([], type$.JSArray_ImmutableSembastRecord));
      return t1;
    },
    SembastStore: function SembastStore(t0, t1, t2) {
      var _ = this;
      _.database = t0;
      _.ref = t1;
      _.lastIntKey = 0;
      _._recordMap = t2;
      _.txnRecords = _._currentRecordsCache = null;
    },
    SembastStore_txnCurrentRecords_closure: function SembastStore_txnCurrentRecords_closure() {
    },
    SembastStore_forEachRecords_finderMatchesRecord: function SembastStore_forEachRecords_finderMatchesRecord() {
    },
    SembastStore_forEachRecordsSync_finderMatchesRecord: function SembastStore_forEachRecordsSync_finderMatchesRecord() {
    },
    SembastStore_txnFindRecords_closure: function SembastStore_txnFindRecords_closure(t0) {
      this.finder = t0;
    },
    SembastStore_txnFindRecordsSync_closure: function SembastStore_txnFindRecordsSync_closure(t0) {
      this.finder = t0;
    },
    SembastStore_txnFindKeys_closure: function SembastStore_txnFindKeys_closure() {
    },
    _FinderData: function _FinderData(t0) {
      var _ = this;
      _.___FinderData_preOrderedResults_A = _.___FinderData_results_A = $;
      _.sembastFinder = t0;
      _.___FinderData_usePreordered_AI = _.___FinderData_hasSortOrder_AI = $;
      _.preorderedCurrentOffset = 0;
    },
    SembastStoreRef$($name, $K, $V) {
      var t1 = new A.SembastStoreRef($, $K._eval$1("@<0>")._bind$1($V)._eval$1("SembastStoreRef<1,2>"));
      t1.StoreRefMixin___StoreRefMixin_name_A = $name;
      return t1;
    },
    SembastStoreRefExtensionImpl_findImmutableRecords(_this, databaseClient, finder, $K, $V) {
      return A.SembastStoreRefExtensionImpl_findImmutableRecords$body(_this, databaseClient, finder, $K, $V);
    },
    SembastStoreRefExtensionImpl_findImmutableRecords$body(_this, databaseClient, finder, $K, $V) {
      var $async$goto = 0,
        $async$completer = A._makeAsyncAwaitCompleter(type$.List_ImmutableSembastRecord),
        $async$returnValue;
      var $async$SembastStoreRefExtensionImpl_findImmutableRecords = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return A._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$goto = 3;
              return A._asyncAwait(databaseClient.getSembastStore$1(_this).txnFindRecords$2(databaseClient.get$sembastTransaction(), finder), $async$SembastStoreRefExtensionImpl_findImmutableRecords);
            case 3:
              // returning from await.
              $async$returnValue = $async$result;
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return A._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return A._asyncStartSync($async$SembastStoreRefExtensionImpl_findImmutableRecords, $async$completer);
    },
    SembastStoreRefExtensionPrv_immutableRecordIterableToSnapshots(_this, records, $K, $V) {
      var t1 = J.map$1$1$ax(records, new A.SembastStoreRefExtensionPrv_immutableRecordIterableToSnapshots_closure(_this, $K, $V), $K._eval$1("@<0>")._bind$1($V)._eval$1("SembastRecordSnapshot<1,2>"));
      t1 = A.List_List$_of(t1, t1.$ti._eval$1("ListIterable.E"));
      t1.$flags = 1;
      return t1;
    },
    SembastStoreRefExtension_drop(_this, databaseClient, $K, $V) {
      return databaseClient.inTransaction$1$1(new A.SembastStoreRefExtension_drop_closure(databaseClient, _this), type$.void);
    },
    SembastStoreRefExtension_findFirst(_this, databaseClient, finder, $K, $V) {
      return A.SembastStoreRefExtension_findFirst$body(_this, databaseClient, finder, $K, $V, $K._eval$1("@<0>")._bind$1($V)._eval$1("RecordSnapshot<1,2>?"));
    },
    SembastStoreRefExtension_findFirst$body(_this, databaseClient, finder, $K, $V, $async$type) {
      var $async$goto = 0,
        $async$completer = A._makeAsyncAwaitCompleter($async$type),
        $async$returnValue, record;
      var $async$SembastStoreRefExtension_findFirst = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return A._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$goto = 3;
              return A._asyncAwait(databaseClient.getSembastStore$1(_this).txnFindRecord$2(databaseClient.get$sembastTransaction(), finder), $async$SembastStoreRefExtension_findFirst);
            case 3:
              // returning from await.
              record = $async$result;
              if (record == null) {
                $async$returnValue = null;
                // goto return
                $async$goto = 1;
                break;
              } else {
                $async$returnValue = A.SembastRecordSnapshot$fromRecord(_this, record, $K, $V);
                // goto return
                $async$goto = 1;
                break;
              }
            case 1:
              // return
              return A._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return A._asyncStartSync($async$SembastStoreRefExtension_findFirst, $async$completer);
    },
    SembastStoreRefExtension_find(_this, databaseClient, finder, $K, $V) {
      return A.SembastStoreRefExtension_find$body(_this, databaseClient, finder, $K, $V, $K._eval$1("@<0>")._bind$1($V)._eval$1("List<RecordSnapshot<1,2>>"));
    },
    SembastStoreRefExtension_find$body(_this, databaseClient, finder, $K, $V, $async$type) {
      var $async$goto = 0,
        $async$completer = A._makeAsyncAwaitCompleter($async$type),
        $async$returnValue, $async$temp1, $async$temp2;
      var $async$SembastStoreRefExtension_find = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return A._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$temp1 = A;
              $async$temp2 = _this;
              $async$goto = 3;
              return A._asyncAwait(A.SembastStoreRefExtensionImpl_findImmutableRecords(_this, databaseClient, finder, $K, $V), $async$SembastStoreRefExtension_find);
            case 3:
              // returning from await.
              $async$returnValue = $async$temp1.SembastStoreRefExtensionPrv_immutableRecordIterableToSnapshots($async$temp2, $async$result, $K, $V);
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return A._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return A._asyncStartSync($async$SembastStoreRefExtension_find, $async$completer);
    },
    SembastStoreRefExtension_findKey(_this, databaseClient, finder, $K, $V) {
      return A.SembastStoreRefExtension_findKey$body(_this, databaseClient, finder, $K, $V, $K._eval$1("0?"));
    },
    SembastStoreRefExtension_findKey$body(_this, databaseClient, finder, $K, $V, $async$type) {
      var $async$goto = 0,
        $async$completer = A._makeAsyncAwaitCompleter($async$type),
        $async$returnValue, $async$temp1;
      var $async$SembastStoreRefExtension_findKey = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return A._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$temp1 = $K._eval$1("0?");
              $async$goto = 3;
              return A._asyncAwait(databaseClient.getSembastStore$1(_this).txnFindKey$2(databaseClient.get$sembastTransaction(), finder), $async$SembastStoreRefExtension_findKey);
            case 3:
              // returning from await.
              $async$returnValue = $async$temp1._as($async$result);
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return A._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return A._asyncStartSync($async$SembastStoreRefExtension_findKey, $async$completer);
    },
    SembastStoreRefExtension_generateIntKey(_this, databaseClient, $K, $V) {
      return databaseClient.inTransaction$1$1(new A.SembastStoreRefExtension_generateIntKey_closure(databaseClient, _this), type$.int);
    },
    SembastStoreRefExtension_delete(_this, databaseClient, finder, $K, $V) {
      return databaseClient.inTransaction$1$1(new A.SembastStoreRefExtension_delete_closure(databaseClient, _this, finder), type$.int);
    },
    SembastStoreRef: function SembastStoreRef(t0, t1) {
      this.StoreRefMixin___StoreRefMixin_name_A = t0;
      this.$ti = t1;
    },
    StoreRefMixin: function StoreRefMixin() {
    },
    SembastStoreRefExtensionPrv_immutableRecordIterableToSnapshots_closure: function SembastStoreRefExtensionPrv_immutableRecordIterableToSnapshots_closure(t0, t1, t2) {
      this._this = t0;
      this.K = t1;
      this.V = t2;
    },
    SembastStoreRefExtension_drop_closure: function SembastStoreRefExtension_drop_closure(t0, t1) {
      this.client = t0;
      this._this = t1;
    },
    SembastStoreRefExtension_generateIntKey_closure: function SembastStoreRefExtension_generateIntKey_closure(t0, t1) {
      this.client = t0;
      this._this = t1;
    },
    SembastStoreRefExtension_delete_closure: function SembastStoreRefExtension_delete_closure(t0, t1, t2) {
      this.client = t0;
      this._this = t1;
      this.finder = t2;
    },
    StoreFactoryMixin: function StoreFactoryMixin() {
    },
    StoreFactoryBase: function StoreFactoryBase(t0) {
      this.$ti = t0;
    },
    _SembastStoreRef_Object_StoreRefMixin: function _SembastStoreRef_Object_StoreRefMixin() {
    },
    _StoreFactoryBase_Object_StoreFactoryMixin: function _StoreFactoryBase_Object_StoreFactoryMixin() {
    },
    Timestamp$(seconds, nanoseconds) {
      var t1 = new A.Timestamp(seconds, nanoseconds);
      if (seconds < -62135596800 || seconds > 253402300799)
        A.throwExpression(A.ArgumentError$("invalid seconds part " + t1.toDateTime$1$isUtc(true).toString$0(0), null));
      if (nanoseconds < 0 || nanoseconds > 999999999)
        A.throwExpression(A.ArgumentError$("invalid nanoseconds part " + t1.toDateTime$1$isUtc(true).toString$0(0), null));
      return t1;
    },
    Timestamp_tryParse(text) {
      var dateTime, dateTimeNoSubSeconds, t1, i, t2, char, seconds, _null = null,
        subSecondsStart = B.JSString_methods.lastIndexOf$1(text, ".") + 1;
      if (subSecondsStart === 0) {
        dateTime = A.DateTime_tryParse(text);
        if (dateTime == null)
          return _null;
        else
          return A.Timestamp_Timestamp$fromDateTime(dateTime);
      }
      dateTimeNoSubSeconds = new A.StringBuffer("");
      t1 = "" + B.JSString_methods.substring$2(text, 0, subSecondsStart);
      dateTimeNoSubSeconds._contents = t1;
      dateTimeNoSubSeconds._contents = t1 + "000";
      for (t1 = text.length, i = subSecondsStart, t2 = ""; i < t1; ++i) {
        if (!(i >= 0))
          return A.ioore(text, i);
        char = text[i];
        if (0 >= char.length)
          return A.ioore(char, 0);
        if ((char.charCodeAt(0) ^ 48) <= 9) {
          if (t2.length < 9)
            t2 += char;
        } else {
          dateTimeNoSubSeconds._contents += B.JSString_methods.substring$1(text, i);
          break;
        }
      }
      t1 = dateTimeNoSubSeconds._contents;
      dateTime = A.DateTime_tryParse(t1.charCodeAt(0) == 0 ? t1 : t1);
      if (dateTime == null)
        return _null;
      for (t1 = t2; t1.length < 9;)
        t1 += "0";
      seconds = B.JSNumber_methods.floor$0(dateTime._core$_value / 1000);
      t1 = A.Primitives_parseInt(t1.charCodeAt(0) == 0 ? t1 : t1, _null);
      t1.toString;
      return A.Timestamp$(seconds, t1);
    },
    Timestamp_Timestamp$fromDateTime(dateTime) {
      var t1 = dateTime._core$_value;
      return A.Timestamp$(B.JSNumber_methods.floor$0(t1 / 1000), B.JSInt_methods.$mod(1000 * t1 + dateTime._microsecond, 1000000) * 1000);
    },
    Timestamp__threeDigits(n) {
      if (n >= 100)
        return "" + n;
      if (n >= 10)
        return "0" + n;
      return "00" + n;
    },
    Timestamp__formatNanos(nanoseconds) {
      var t1, us, _1000 = 1000,
        ns = B.JSInt_methods.$mod(nanoseconds, _1000);
      if (ns !== 0)
        return A.Timestamp__threeDigits(B.JSInt_methods._tdivFast$1(nanoseconds, 1000000)) + A.Timestamp__threeDigits(B.JSInt_methods.$mod(B.JSInt_methods._tdivFast$1(nanoseconds, _1000), _1000)) + A.Timestamp__threeDigits(ns);
      else {
        t1 = B.JSInt_methods._tdivFast$1(nanoseconds, _1000);
        us = B.JSInt_methods.$mod(t1, _1000);
        t1 = A.Timestamp__threeDigits(B.JSInt_methods._tdivFast$1(t1, _1000));
        return t1 + (us === 0 ? "" : A.Timestamp__threeDigits(us));
      }
    },
    Timestamp: function Timestamp(t0, t1) {
      this.seconds = t0;
      this.nanoseconds = t1;
    },
    SembastTransaction: function SembastTransaction(t0, t1, t2) {
      this.sembastDatabase = t0;
      this._id = t1;
      this.completer = t2;
    },
    SembastTransactionStore: function SembastTransactionStore(t0) {
      this.store = t0;
    },
    _TimestampAdapter$() {
      var t1 = new A._TimestampAdapter($, $);
      t1._TimestampAdapter$0();
      return t1;
    },
    _BlobAdapter$() {
      var t1 = new A._BlobAdapter($, $);
      t1._BlobAdapter$0();
      return t1;
    },
    _Converter: function _Converter(t0, t1) {
      this._convert = t0;
      this.$ti = t1;
    },
    _TimestampAdapter: function _TimestampAdapter(t0, t1) {
      this._TypeAdapterCodecMixin____TypeAdapterCodecMixin_encoder_A = t0;
      this._TypeAdapterCodecMixin____TypeAdapterCodecMixin_decoder_A = t1;
    },
    _TimestampAdapter_closure: function _TimestampAdapter_closure() {
    },
    _TimestampAdapter_closure0: function _TimestampAdapter_closure0() {
    },
    _BlobAdapter: function _BlobAdapter(t0, t1) {
      this._TypeAdapterCodecMixin____TypeAdapterCodecMixin_encoder_A = t0;
      this._TypeAdapterCodecMixin____TypeAdapterCodecMixin_decoder_A = t1;
    },
    _BlobAdapter_closure: function _BlobAdapter_closure() {
    },
    _BlobAdapter_closure0: function _BlobAdapter_closure0() {
    },
    SembastTypeAdapter: function SembastTypeAdapter() {
    },
    _TypeAdapterCodecMixin: function _TypeAdapterCodecMixin() {
    },
    __BlobAdapter_SembastTypeAdapter__TypeAdapterCodecMixin: function __BlobAdapter_SembastTypeAdapter__TypeAdapterCodecMixin() {
    },
    __TimestampAdapter_SembastTypeAdapter__TypeAdapterCodecMixin: function __TimestampAdapter_SembastTypeAdapter__TypeAdapterCodecMixin() {
    },
    compareKey(key1, key2) {
      return A.compareValue(key1, key2);
    },
    compareValue(value1, value2) {
      var list1, list2, i, cmp, t1, t2, t3, t4, exception;
      try {
        t1 = type$.Comparable_dynamic;
        if (t1._is(value1) && t1._is(value2)) {
          t1 = J.compareTo$1$ns(value1, value2);
          return t1;
        } else {
          t1 = type$.List_dynamic;
          if (t1._is(value1) && t1._is(value2)) {
            list1 = value1;
            list2 = value2;
            i = 0;
            t1 = J.getInterceptor$asx(value1);
            t2 = J.getInterceptor$asx(value2);
            while (true) {
              t3 = i;
              t4 = Math.min(t1.get$length(value1), t2.get$length(value2));
              if (typeof t3 !== "number")
                return t3.$lt();
              if (!(t3 < t4))
                break;
              c$0: {
                cmp = A.compareValue(J.$index$asx(list1, i), J.$index$asx(list2, i));
                if (J.$eq$(cmp, 0))
                  break c$0;
                return cmp;
              }
              t3 = i;
              if (typeof t3 !== "number")
                return t3.$add();
              i = t3 + 1;
            }
            t1 = A.compareValue(J.get$length$asx(list1), J.get$length$asx(list2));
            return t1;
          } else if (A._isBool(value1) && A._isBool(value2)) {
            t1 = A.compareBool(value1, value2);
            return t1;
          }
        }
      } catch (exception) {
      }
      return A.compareValueType(value1, value2);
    },
    compareBool(value1, value2) {
      if (value1) {
        if (value2)
          return 0;
        return 1;
      }
      return value2 ? -1 : 0;
    },
    compareValueType(value1, value2) {
      var t1;
      if (value1 == null)
        if (value2 == null)
          return 0;
        else
          return -1;
      else if (value2 == null)
        return 1;
      else if (A._isBool(value1))
        if (A._isBool(value2))
          return 0;
        else
          return -1;
      else if (A._isBool(value2))
        return 1;
      else if (typeof value1 == "number")
        if (typeof value2 == "number")
          return 0;
        else
          return -1;
      else if (typeof value2 == "number")
        return 1;
      else if (value1 instanceof A.Timestamp)
        if (value2 instanceof A.Timestamp)
          return 0;
        else
          return -1;
      else if (value2 instanceof A.Timestamp)
        return 1;
      else if (typeof value1 == "string")
        if (typeof value2 == "string")
          return 0;
        else
          return -1;
      else if (typeof value2 == "string")
        return 1;
      else if (value1 instanceof A.Blob)
        if (value2 instanceof A.Blob)
          return 0;
        else
          return -1;
      else if (value2 instanceof A.Blob)
        return 1;
      else {
        t1 = type$.List_dynamic;
        if (t1._is(value1))
          if (t1._is(value2))
            return 0;
          else
            return -1;
        else if (t1._is(value2))
          return 1;
        else {
          t1 = type$.Map_dynamic_dynamic;
          if (t1._is(value1))
            return -1;
          else if (t1._is(value2))
            return 1;
        }
      }
      return A.compareValue(J.toString$0$(value1), J.toString$0$(value2));
    },
    cloneValue(value) {
      if (type$.Map_dynamic_dynamic._is(value))
        return value.map$2$1(0, new A.cloneValue_closure(), type$.String, type$.nullable_Object);
      if (type$.Iterable_dynamic._is(value))
        return J.map$1$1$ax(value, new A.cloneValue_closure0(), type$.dynamic).toList$0(0);
      return value;
    },
    cloneValueOrNull(value) {
      if (type$.Map_dynamic_dynamic._is(value))
        return value.map$2$1(0, new A.cloneValueOrNull_closure(), type$.String, type$.nullable_Object);
      if (type$.Iterable_dynamic._is(value))
        return J.map$1$1$ax(value, new A.cloneValueOrNull_closure0(), type$.dynamic).toList$0(0);
      return value;
    },
    sanitizeValueIfMap(value) {
      if (type$.Map_dynamic_dynamic._is(value))
        if (!type$.Map_of_String_and_nullable_Object._is(value))
          return value.cast$2$0(0, type$.String, type$.nullable_Object);
      return value;
    },
    isBasicTypeOrNull(value) {
      if (value == null)
        return true;
      else if (typeof value == "number" || typeof value == "string" || A._isBool(value))
        return true;
      return false;
    },
    getPartsMapValue(map, parts, $T) {
      var t1, t2, t3, value, _i, part, index;
      for (t1 = parts.length, t2 = type$.List_dynamic, t3 = type$.Map_dynamic_dynamic, value = map, _i = 0; _i < parts.length; parts.length === t1 || (0, A.throwConcurrentModificationError)(parts), ++_i) {
        part = parts[_i];
        if (t3._is(value))
          value = value.$index(0, part);
        else if (t2._is(value)) {
          index = A.Primitives_parseInt(part, null);
          if (index == null)
            index = -1;
          if (index >= 0 && index < J.get$length$asx(value))
            value = J.$index$asx(value, index);
        } else
          return null;
      }
      return $T._eval$1("0?")._as(value);
    },
    _smartMatchPartsAnyValue(value, part, parts, match) {
      var t1, itemIndex,
        matchItem = new A._smartMatchPartsAnyValue_matchItem(parts, match);
      if (type$.List_dynamic._is(value))
        if (part === "@") {
          for (t1 = J.get$iterator$ax(value); t1.moveNext$0();)
            if (matchItem.call$1(t1.get$current()))
              return true;
          return false;
        } else {
          itemIndex = A.Primitives_parseInt(part, null);
          if (itemIndex == null)
            itemIndex = -1;
          if (itemIndex >= 0 && itemIndex < J.get$length$asx(value))
            return matchItem.call$1(J.$index$asx(value, itemIndex));
          return false;
        }
      else if (type$.Map_dynamic_dynamic._is(value))
        return matchItem.call$1(value.$index(0, part));
      return false;
    },
    smartMatchPartsMapValue(map, parts, match) {
      if (parts.length === 0)
        return false;
      return A._smartMatchPartsAnyValue(map, B.JSArray_methods.get$first(parts), A.SubListIterable$(parts, 1, null, A._arrayInstanceType(parts)._precomputed1), match);
    },
    isBacktickEnclosed(field) {
      var t1,
        $length = field.length;
      if ($length < 2)
        return false;
      t1 = $.$get$backtickChrCode();
      return field.charCodeAt(0) === t1 && field.charCodeAt($length - 1) === t1;
    },
    getFieldParts(field) {
      if (A.isBacktickEnclosed(field))
        return A._setArrayType([B.JSString_methods.substring$2(field, 1, field.length - 1)], type$.JSArray_String);
      return A._setArrayType(field.split("."), type$.JSArray_String);
    },
    cloneValue_closure: function cloneValue_closure() {
    },
    cloneValue_closure0: function cloneValue_closure0() {
    },
    cloneValueOrNull_closure: function cloneValueOrNull_closure() {
    },
    cloneValueOrNull_closure0: function cloneValueOrNull_closure0() {
    },
    _smartMatchPartsAnyValue_matchItem: function _smartMatchPartsAnyValue_matchItem(t0, t1) {
      this.parts = t0;
      this.match = t1;
    },
    BasicLock: function BasicLock() {
      this.last = null;
    },
    BasicLock_synchronized_complete: function BasicLock_synchronized_complete(t0, t1) {
      this.$this = t0;
      this.completer = t1;
    },
    _EventStreamSubscription$(_target, _eventType, onData, _useCapture, $T) {
      var t1 = A._wrapZone(new A._EventStreamSubscription_closure(onData), type$.JSObject);
      t1 = t1 == null ? null : A._functionToJS1(t1);
      t1 = new A._EventStreamSubscription(_target, _eventType, t1, false, $T._eval$1("_EventStreamSubscription<0>"));
      t1._tryResume$0();
      return t1;
    },
    _wrapZone(callback, $T) {
      var t1 = $.Zone__current;
      if (t1 === B.C__RootZone)
        return callback;
      return t1.bindUnaryCallbackGuarded$1$1(callback, $T);
    },
    EventStreamProvider: function EventStreamProvider(t0) {
      this.$ti = t0;
    },
    _EventStream: function _EventStream(t0, t1, t2, t3) {
      var _ = this;
      _._target = t0;
      _._eventType = t1;
      _._useCapture = t2;
      _.$ti = t3;
    },
    _EventStreamSubscription: function _EventStreamSubscription(t0, t1, t2, t3, t4) {
      var _ = this;
      _._pauseCount = 0;
      _._target = t0;
      _._eventType = t1;
      _._streams$_onData = t2;
      _._useCapture = t3;
      _.$ti = t4;
    },
    _EventStreamSubscription_closure: function _EventStreamSubscription_closure(t0) {
      this.onData = t0;
    },
    main() {
      var $async$goto = 0,
        $async$completer = A._makeAsyncAwaitCompleter(type$.void),
        $async$temp1;
      var $async$main = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return A._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              A.print("\ud83d\ude80 Starting Student Management System...");
              $async$temp1 = $.__database;
              $async$goto = 2;
              return A._asyncAwait(A.initializeDatabase(), $async$main);
            case 2:
              // returning from await.
              $async$temp1._value = $async$result;
              A.setupEventListeners();
              A.print("\u2705 Application ready!");
              $async$goto = 3;
              return A._asyncAwait(A.Future_Future$delayed(A.Duration$(0, 1), null, type$.dynamic), $async$main);
            case 3:
              // returning from await.
              $async$goto = 4;
              return A._asyncAwait(A.showAllStudents(), $async$main);
            case 4:
              // returning from await.
              // implicit return
              return A._asyncReturn(null, $async$completer);
          }
      });
      return A._asyncStartSync($async$main, $async$completer);
    },
    setupEventListeners() {
      var t1 = init.G,
        t2 = type$.JSObject,
        t3 = type$.nullable_JSObject,
        addBtn = t3._as(t2._as(t1.document).querySelector("#add-student-btn")),
        getAllBtn = t3._as(t2._as(t1.document).querySelector("#get-all-students-btn")),
        getBtn = t3._as(t2._as(t1.document).querySelector("#get-student-btn")),
        updateBtn = t3._as(t2._as(t1.document).querySelector("#update-student-btn")),
        deleteBtn = t3._as(t2._as(t1.document).querySelector("#delete-student-btn")),
        clearBtn = t3._as(t2._as(t1.document).querySelector("#clear-all-btn"));
      if (addBtn != null)
        addBtn.onclick = A._functionToJS0(new A.setupEventListeners_handleAddStudent());
      if (getAllBtn != null)
        getAllBtn.onclick = A._functionToJS0(new A.setupEventListeners_handleGetAllStudents());
      if (getBtn != null)
        getBtn.onclick = A._functionToJS0(new A.setupEventListeners_handleGetStudent());
      if (updateBtn != null)
        updateBtn.onclick = A._functionToJS0(new A.setupEventListeners_handleUpdateStudent());
      if (deleteBtn != null)
        deleteBtn.onclick = A._functionToJS0(new A.setupEventListeners_handleDeleteStudent());
      if (clearBtn != null)
        clearBtn.onclick = A._functionToJS0(new A.setupEventListeners_handleClearAll());
    },
    showAllStudents() {
      var $async$goto = 0,
        $async$completer = A._makeAsyncAwaitCompleter(type$.void),
        $async$returnValue, $async$handler = 2, $async$errorStack = [], students, output, i, student, error, errorMsg, t1, t2, exception, $async$exception;
      var $async$showAllStudents = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1) {
          $async$errorStack.push($async$result);
          $async$goto = $async$handler;
        }
        while (true)
          $async$outer:
            switch ($async$goto) {
              case 0:
                // Function start
                A.print("\ud83d\udccb showAllStudents() called");
                $async$handler = 4;
                A.showOutput("\ud83d\udd0d Loading students from database...");
                $async$goto = 7;
                return A._asyncAwait(A.readAllStudents($.__database._readField$0()), $async$showAllStudents);
              case 7:
                // returning from await.
                students = $async$result;
                A.print("\ud83d\udcca Got " + J.get$length$asx(students) + " students from database");
                if (J.get$isEmpty$asx(students)) {
                  A.showOutput("\ud83d\udccb NO STUDENTS IN DATABASE\n\nThe database is currently empty.\nAdd some students using the CREATE section above.\n\nSample data should have been loaded automatically.\nIf not, try refreshing the page.\n      ");
                  // goto return
                  $async$goto = 1;
                  break;
                }
                output = new A.StringBuffer("");
                t1 = output;
                t2 = "\ud83d\udccb ALL STUDENTS (" + J.get$length$asx(students) + " total)\n";
                t1._contents += t2;
                t2 = output;
                t1 = B.JSString_methods.$mul("=", 50) + "\n";
                t2._contents += t1;
                i = 0;
                while (true) {
                  t1 = i;
                  t2 = J.get$length$asx(students);
                  if (typeof t1 !== "number") {
                    $async$returnValue = t1.$lt();
                    // goto return
                    $async$goto = 1;
                    break $async$outer;
                  }
                  if (!(t1 < t2))
                    break;
                  student = J.$index$asx(students, i);
                  output._contents += "\n";
                  t1 = output;
                  t2 = i;
                  if (typeof t2 !== "number") {
                    $async$returnValue = t2.$add();
                    // goto return
                    $async$goto = 1;
                    break $async$outer;
                  }
                  t2 = A.S(t2 + 1) + ". " + student.name + "\n";
                  t1._contents += t2;
                  t2 = output;
                  t1 = "   ID: " + student.id + "\n";
                  t2._contents += t1;
                  t1 = output;
                  t2 = "   Age: " + student.age + "\n";
                  t1._contents += t2;
                  t2 = output;
                  t1 = "   Major: " + student.major + "\n";
                  t2._contents += t1;
                  t1 = output;
                  t2 = B.JSString_methods.$mul("-", 30) + "\n";
                  t1._contents += t2;
                  t1 = i;
                  if (typeof t1 !== "number") {
                    $async$returnValue = t1.$add();
                    // goto return
                    $async$goto = 1;
                    break $async$outer;
                  }
                  i = t1 + 1;
                }
                output._contents += "\n";
                t1 = output;
                t2 = "Last updated: " + B.JSString_methods.substring$2(new A.DateTime(Date.now(), 0, false).toString$0(0), 0, 19) + "\n";
                t1._contents += t2;
                t2 = output._contents;
                A.showOutput(t2.charCodeAt(0) == 0 ? t2 : t2);
                A.print("\u2705 Successfully displayed " + J.get$length$asx(students) + " students");
                $async$handler = 2;
                // goto after finally
                $async$goto = 6;
                break;
              case 4:
                // catch
                $async$handler = 3;
                $async$exception = $async$errorStack.pop();
                error = A.unwrapException($async$exception);
                errorMsg = "\u274c Error loading students: " + A.S(error);
                A.showOutput(errorMsg);
                A.print(errorMsg);
                // goto after finally
                $async$goto = 6;
                break;
              case 3:
                // uncaught
                // goto rethrow
                $async$goto = 2;
                break;
              case 6:
                // after finally
              case 1:
                // return
                return A._asyncReturn($async$returnValue, $async$completer);
              case 2:
                // rethrow
                return A._asyncRethrow($async$errorStack.at(-1), $async$completer);
            }
      });
      return A._asyncStartSync($async$showAllStudents, $async$completer);
    },
    showOutput(text) {
      var outputElement = type$.nullable_JSObject._as(type$.JSObject._as(init.G.document).querySelector("#output"));
      if (outputElement != null) {
        outputElement.textContent = text;
        A.print("\ud83d\udcfa Output updated: " + text.length + " characters");
      } else
        A.print("\u274c Output element not found!");
    },
    setupEventListeners_handleAddStudent: function setupEventListeners_handleAddStudent() {
    },
    setupEventListeners_handleGetAllStudents: function setupEventListeners_handleGetAllStudents() {
    },
    setupEventListeners_handleGetStudent: function setupEventListeners_handleGetStudent() {
    },
    setupEventListeners_handleUpdateStudent: function setupEventListeners_handleUpdateStudent() {
    },
    setupEventListeners_handleDeleteStudent: function setupEventListeners_handleDeleteStudent() {
    },
    setupEventListeners_handleClearAll: function setupEventListeners_handleClearAll() {
    },
    Student_Student$fromMap(map) {
      return new A.Student(A._asString(map.$index(0, "id")), A._asString(map.$index(0, "name")), A._asInt(map.$index(0, "age")), A._asString(map.$index(0, "major")));
    },
    Student: function Student(t0, t1, t2, t3) {
      var _ = this;
      _.id = t0;
      _.name = t1;
      _.age = t2;
      _.major = t3;
    },
    updateStatus(message, type) {
      var statusElement = type$.nullable_JSObject._as(type$.JSObject._as(init.G.document).querySelector("#db-status"));
      if (statusElement != null) {
        statusElement.textContent = message;
        statusElement.className = "status " + type;
      }
      A.print("Status: " + message);
    },
    initializeDatabase() {
      var $async$goto = 0,
        $async$completer = A._makeAsyncAwaitCompleter(type$.Database),
        $async$returnValue, $async$handler = 2, $async$errorStack = [], idbFactory, database, error, exception, $async$exception;
      var $async$initializeDatabase = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1) {
          $async$errorStack.push($async$result);
          $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$handler = 4;
              A.updateStatus("\ud83d\udd27 Initializing database...", "info");
              A.print("\ud83d\udd27 Starting database initialization...");
              idbFactory = A.idbFactoryBrowser();
              A.print("\u2705 Got IDB factory");
              $async$goto = 7;
              return A._asyncAwait(idbFactory.deleteDatabase$1("StudentDatabase"), $async$initializeDatabase);
            case 7:
              // returning from await.
              A.print("\ud83d\uddd1\ufe0f Cleaned up existing database");
              $async$goto = 8;
              return A._asyncAwait(idbFactory.open$3$onUpgradeNeeded$version("StudentDatabase", new A.initializeDatabase_closure(), 1), $async$initializeDatabase);
            case 8:
              // returning from await.
              database = $async$result;
              A.updateStatus("\u2705 Database initialized successfully!", "success");
              A.print("\ud83c\udfd7\ufe0f Database ready: StudentDatabase with store: students");
              $async$goto = 9;
              return A._asyncAwait(A.addSampleData(database), $async$initializeDatabase);
            case 9:
              // returning from await.
              $async$returnValue = database;
              // goto return
              $async$goto = 1;
              break;
              $async$handler = 2;
              // goto after finally
              $async$goto = 6;
              break;
            case 4:
              // catch
              $async$handler = 3;
              $async$exception = $async$errorStack.pop();
              error = A.unwrapException($async$exception);
              A.updateStatus("\u274c Failed to initialize database: " + A.S(error), "error");
              A.print("\ud83d\udca5 Database initialization failed: " + A.S(error));
              throw $async$exception;
              // goto after finally
              $async$goto = 6;
              break;
            case 3:
              // uncaught
              // goto rethrow
              $async$goto = 2;
              break;
            case 6:
              // after finally
            case 1:
              // return
              return A._asyncReturn($async$returnValue, $async$completer);
            case 2:
              // rethrow
              return A._asyncRethrow($async$errorStack.at(-1), $async$completer);
          }
      });
      return A._asyncStartSync($async$initializeDatabase, $async$completer);
    },
    addSampleData(database) {
      return A.addSampleData$body(database);
    },
    addSampleData$body(database) {
      var $async$goto = 0,
        $async$completer = A._makeAsyncAwaitCompleter(type$.void),
        sampleStudents, _i;
      var $async$addSampleData = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return A._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              A.print("\ud83d\udcca Adding sample data...");
              sampleStudents = [new A.Student("S001", "Alice Johnson", 20, "Computer Science"), new A.Student("S002", "Bob Smith", 22, "Mathematics"), new A.Student("S003", "Carol Davis", 21, "Physics"), new A.Student("S004", "David Wilson", 23, "Engineering"), new A.Student("S005", "Eva Martinez", 19, "Biology")];
              _i = 0;
            case 2:
              // for condition
              if (!(_i < 5)) {
                // goto after for
                $async$goto = 4;
                break;
              }
              $async$goto = 5;
              return A._asyncAwait(A.createStudent(database, sampleStudents[_i]), $async$addSampleData);
            case 5:
              // returning from await.
            case 3:
              // for update
              ++_i;
              // goto for condition
              $async$goto = 2;
              break;
            case 4:
              // after for
              A.print("\ud83d\udcca Successfully added 5 sample students");
              // implicit return
              return A._asyncReturn(null, $async$completer);
          }
      });
      return A._asyncStartSync($async$addSampleData, $async$completer);
    },
    createStudent(database, student) {
      return A.createStudent$body(database, student);
    },
    createStudent$body(database, student) {
      var $async$goto = 0,
        $async$completer = A._makeAsyncAwaitCompleter(type$.void),
        $async$handler = 1, $async$errorStack = [], txn, store, error, t1, exception, $async$exception;
      var $async$createStudent = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1) {
          $async$errorStack.push($async$result);
          $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$handler = 3;
              t1 = student.id;
              A.print("\ud83d\udcbe Creating student: " + t1 + " - " + student.name);
              txn = database.transaction$2("students", "readwrite");
              store = txn.objectStore$1("students");
              $async$goto = 6;
              return A._asyncAwait(store.put$2(student.toMap$0(), t1), $async$createStudent);
            case 6:
              // returning from await.
              $async$goto = 7;
              return A._asyncAwait(txn.get$completed(), $async$createStudent);
            case 7:
              // returning from await.
              A.print("\u2705 Student created: " + t1);
              $async$handler = 1;
              // goto after finally
              $async$goto = 5;
              break;
            case 3:
              // catch
              $async$handler = 2;
              $async$exception = $async$errorStack.pop();
              error = A.unwrapException($async$exception);
              A.print("\ud83d\udca5 Create error: " + A.S(error));
              throw $async$exception;
              // goto after finally
              $async$goto = 5;
              break;
            case 2:
              // uncaught
              // goto rethrow
              $async$goto = 1;
              break;
            case 5:
              // after finally
              // implicit return
              return A._asyncReturn(null, $async$completer);
            case 1:
              // rethrow
              return A._asyncRethrow($async$errorStack.at(-1), $async$completer);
          }
      });
      return A._asyncStartSync($async$createStudent, $async$completer);
    },
    readStudent(database, studentId) {
      return A.readStudent$body(database, studentId);
    },
    readStudent$body(database, studentId) {
      var $async$goto = 0,
        $async$completer = A._makeAsyncAwaitCompleter(type$.nullable_Student),
        $async$returnValue, $async$handler = 2, $async$errorStack = [], txn, store, result, studentMap, student, error, exception, $async$exception;
      var $async$readStudent = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1) {
          $async$errorStack.push($async$result);
          $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$handler = 4;
              A.print("\ud83d\udd0d Reading student: " + studentId);
              txn = database.transaction$2("students", "readonly");
              store = txn.objectStore$1("students");
              $async$goto = 7;
              return A._asyncAwait(store.getObject$1(studentId), $async$readStudent);
            case 7:
              // returning from await.
              result = $async$result;
              $async$goto = 8;
              return A._asyncAwait(txn.get$completed(), $async$readStudent);
            case 8:
              // returning from await.
              if (result != null && type$.Map_dynamic_dynamic._is(result)) {
                studentMap = A.LinkedHashMap_LinkedHashMap$from(result, type$.String, type$.dynamic);
                student = A.Student_Student$fromMap(studentMap);
                A.print("\u2705 Found student: " + J.toString$0$(student));
                $async$returnValue = student;
                // goto return
                $async$goto = 1;
                break;
              } else {
                A.print("\u26a0\ufe0f Student not found: " + studentId);
                $async$returnValue = null;
                // goto return
                $async$goto = 1;
                break;
              }
              $async$handler = 2;
              // goto after finally
              $async$goto = 6;
              break;
            case 4:
              // catch
              $async$handler = 3;
              $async$exception = $async$errorStack.pop();
              error = A.unwrapException($async$exception);
              A.print("\ud83d\udca5 Read error: " + A.S(error));
              $async$returnValue = null;
              // goto return
              $async$goto = 1;
              break;
              // goto after finally
              $async$goto = 6;
              break;
            case 3:
              // uncaught
              // goto rethrow
              $async$goto = 2;
              break;
            case 6:
              // after finally
            case 1:
              // return
              return A._asyncReturn($async$returnValue, $async$completer);
            case 2:
              // rethrow
              return A._asyncRethrow($async$errorStack.at(-1), $async$completer);
          }
      });
      return A._asyncStartSync($async$readStudent, $async$completer);
    },
    readAllStudents(database) {
      return A.readAllStudents$body(database);
    },
    readAllStudents$body(database) {
      var $async$goto = 0,
        $async$completer = A._makeAsyncAwaitCompleter(type$.List_Student),
        $async$returnValue, $async$handler = 2, $async$errorStack = [], $async$next = [], txn, store, students, cursor, data, studentMap, student, parseError, error, t1, t2, t3, t4, line, toZone, exception, $async$exception;
      var $async$readAllStudents = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1) {
          $async$errorStack.push($async$result);
          $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              A.print("\ud83d\udd0d Starting readAllStudents()");
              $async$handler = 4;
              txn = database.transaction$2("students", "readonly");
              store = txn.objectStore$1("students");
              students = A._setArrayType([], type$.JSArray_Student);
              A.print("\ud83d\udcca Opening cursor...");
              t1 = new A._StreamIterator(A.checkNotNullable(store.openCursor$0(), "stream", type$.Object), type$._StreamIterator_IdbCursorWithValue);
              $async$handler = 7;
              t2 = type$.Map_dynamic_dynamic, t3 = type$.String, t4 = type$.dynamic;
            case 10:
              // for condition
              $async$goto = 12;
              return A._asyncAwait(t1.moveNext$0(), $async$readAllStudents);
            case 12:
              // returning from await.
              if (!$async$result) {
                // goto after for
                $async$goto = 11;
                break;
              }
              cursor = t1.get$current();
              line = "\ud83d\udcc4 Found record: " + A.S(cursor.get$key());
              toZone = $.printToZone;
              if (toZone == null)
                A.printString(line);
              else
                toZone.call$1(line);
              try {
                data = cursor.get$value();
                line = "\ud83d\udcc4 Raw data: " + A.S(data);
                toZone = $.printToZone;
                if (toZone == null)
                  A.printString(line);
                else
                  toZone.call$1(line);
                if (t2._is(data)) {
                  studentMap = A.LinkedHashMap_LinkedHashMap$from(data, t3, t4);
                  student = A.Student_Student$fromMap(studentMap);
                  J.add$1$ax(students, student);
                  line = "\u2705 Added student: " + student.name;
                  toZone = $.printToZone;
                  if (toZone == null)
                    A.printString(line);
                  else
                    toZone.call$1(line);
                }
              } catch (exception) {
                parseError = A.unwrapException(exception);
                line = "\ud83d\udca5 Parse error for record " + A.S(cursor.get$key()) + ": " + A.S(parseError);
                toZone = $.printToZone;
                if (toZone == null)
                  A.printString(line);
                else
                  toZone.call$1(line);
              }
              // goto for condition
              $async$goto = 10;
              break;
            case 11:
              // after for
              $async$next.push(9);
              // goto finally
              $async$goto = 8;
              break;
            case 7:
              // uncaught
              $async$next = [4];
            case 8:
              // finally
              $async$handler = 4;
              $async$goto = 13;
              return A._asyncAwait(t1.cancel$0(), $async$readAllStudents);
            case 13:
              // returning from await.
              // goto the next finally handler
              $async$goto = $async$next.pop();
              break;
            case 9:
              // after finally
              $async$goto = 14;
              return A._asyncAwait(txn.get$completed(), $async$readAllStudents);
            case 14:
              // returning from await.
              A.print("\ud83d\udcca readAllStudents() returning " + J.get$length$asx(students) + " students");
              $async$returnValue = students;
              // goto return
              $async$goto = 1;
              break;
              $async$handler = 2;
              // goto after finally
              $async$goto = 6;
              break;
            case 4:
              // catch
              $async$handler = 3;
              $async$exception = $async$errorStack.pop();
              error = A.unwrapException($async$exception);
              A.print("\ud83d\udca5 readAllStudents() error: " + A.S(error));
              t1 = A._setArrayType([], type$.JSArray_Student);
              $async$returnValue = t1;
              // goto return
              $async$goto = 1;
              break;
              // goto after finally
              $async$goto = 6;
              break;
            case 3:
              // uncaught
              // goto rethrow
              $async$goto = 2;
              break;
            case 6:
              // after finally
            case 1:
              // return
              return A._asyncReturn($async$returnValue, $async$completer);
            case 2:
              // rethrow
              return A._asyncRethrow($async$errorStack.at(-1), $async$completer);
          }
      });
      return A._asyncStartSync($async$readAllStudents, $async$completer);
    },
    updateStudent(database, studentId, age, major, $name) {
      return A.updateStudent$body(database, studentId, age, major, $name);
    },
    updateStudent$body(database, studentId, age, major, $name) {
      var $async$goto = 0,
        $async$completer = A._makeAsyncAwaitCompleter(type$.bool),
        $async$returnValue, $async$handler = 2, $async$errorStack = [], existingStudent, updatedStudent, txn, store, error, t1, t2, exception, $async$exception;
      var $async$updateStudent = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1) {
          $async$errorStack.push($async$result);
          $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$handler = 4;
              A.print("\ud83d\udd04 Updating student: " + studentId);
              $async$goto = 7;
              return A._asyncAwait(A.readStudent(database, studentId), $async$updateStudent);
            case 7:
              // returning from await.
              existingStudent = $async$result;
              if (existingStudent == null) {
                A.print("\u26a0\ufe0f Student not found for update: " + studentId);
                $async$returnValue = false;
                // goto return
                $async$goto = 1;
                break;
              }
              t1 = $name == null ? existingStudent.name : $name;
              t2 = age == null ? existingStudent.age : age;
              updatedStudent = new A.Student(studentId, t1, t2, major == null ? existingStudent.major : major);
              txn = database.transaction$2("students", "readwrite");
              store = txn.objectStore$1("students");
              $async$goto = 8;
              return A._asyncAwait(store.put$2(updatedStudent.toMap$0(), studentId), $async$updateStudent);
            case 8:
              // returning from await.
              $async$goto = 9;
              return A._asyncAwait(txn.get$completed(), $async$updateStudent);
            case 9:
              // returning from await.
              A.print("\u2705 Student updated: " + J.toString$0$(updatedStudent));
              $async$returnValue = true;
              // goto return
              $async$goto = 1;
              break;
              $async$handler = 2;
              // goto after finally
              $async$goto = 6;
              break;
            case 4:
              // catch
              $async$handler = 3;
              $async$exception = $async$errorStack.pop();
              error = A.unwrapException($async$exception);
              A.print("\ud83d\udca5 Update error: " + A.S(error));
              $async$returnValue = false;
              // goto return
              $async$goto = 1;
              break;
              // goto after finally
              $async$goto = 6;
              break;
            case 3:
              // uncaught
              // goto rethrow
              $async$goto = 2;
              break;
            case 6:
              // after finally
            case 1:
              // return
              return A._asyncReturn($async$returnValue, $async$completer);
            case 2:
              // rethrow
              return A._asyncRethrow($async$errorStack.at(-1), $async$completer);
          }
      });
      return A._asyncStartSync($async$updateStudent, $async$completer);
    },
    deleteStudent(database, studentId) {
      return A.deleteStudent$body(database, studentId);
    },
    deleteStudent$body(database, studentId) {
      var $async$goto = 0,
        $async$completer = A._makeAsyncAwaitCompleter(type$.bool),
        $async$returnValue, $async$handler = 2, $async$errorStack = [], existingStudent, txn, store, error, exception, $async$exception;
      var $async$deleteStudent = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1) {
          $async$errorStack.push($async$result);
          $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$handler = 4;
              A.print("\ud83d\uddd1\ufe0f Deleting student: " + studentId);
              $async$goto = 7;
              return A._asyncAwait(A.readStudent(database, studentId), $async$deleteStudent);
            case 7:
              // returning from await.
              existingStudent = $async$result;
              if (existingStudent == null) {
                A.print("\u26a0\ufe0f Student not found for deletion: " + studentId);
                $async$returnValue = false;
                // goto return
                $async$goto = 1;
                break;
              }
              txn = database.transaction$2("students", "readwrite");
              store = txn.objectStore$1("students");
              $async$goto = 8;
              return A._asyncAwait(store.delete$1(studentId), $async$deleteStudent);
            case 8:
              // returning from await.
              $async$goto = 9;
              return A._asyncAwait(txn.get$completed(), $async$deleteStudent);
            case 9:
              // returning from await.
              A.print("\u2705 Student deleted: " + studentId);
              $async$returnValue = true;
              // goto return
              $async$goto = 1;
              break;
              $async$handler = 2;
              // goto after finally
              $async$goto = 6;
              break;
            case 4:
              // catch
              $async$handler = 3;
              $async$exception = $async$errorStack.pop();
              error = A.unwrapException($async$exception);
              A.print("\ud83d\udca5 Delete error: " + A.S(error));
              $async$returnValue = false;
              // goto return
              $async$goto = 1;
              break;
              // goto after finally
              $async$goto = 6;
              break;
            case 3:
              // uncaught
              // goto rethrow
              $async$goto = 2;
              break;
            case 6:
              // after finally
            case 1:
              // return
              return A._asyncReturn($async$returnValue, $async$completer);
            case 2:
              // rethrow
              return A._asyncRethrow($async$errorStack.at(-1), $async$completer);
          }
      });
      return A._asyncStartSync($async$deleteStudent, $async$completer);
    },
    clearAllStudents(database) {
      return A.clearAllStudents$body(database);
    },
    clearAllStudents$body(database) {
      var $async$goto = 0,
        $async$completer = A._makeAsyncAwaitCompleter(type$.void),
        $async$handler = 1, $async$errorStack = [], txn, store, error, exception, $async$exception;
      var $async$clearAllStudents = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1) {
          $async$errorStack.push($async$result);
          $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$handler = 3;
              A.print("\ud83d\uddd1\ufe0f Clearing all students...");
              txn = database.transaction$2("students", "readwrite");
              store = txn.objectStore$1("students");
              $async$goto = 6;
              return A._asyncAwait(J.clear$0$ax(store), $async$clearAllStudents);
            case 6:
              // returning from await.
              $async$goto = 7;
              return A._asyncAwait(txn.get$completed(), $async$clearAllStudents);
            case 7:
              // returning from await.
              A.print("\u2705 All students cleared");
              $async$handler = 1;
              // goto after finally
              $async$goto = 5;
              break;
            case 3:
              // catch
              $async$handler = 2;
              $async$exception = $async$errorStack.pop();
              error = A.unwrapException($async$exception);
              A.print("\ud83d\udca5 Clear all error: " + A.S(error));
              // goto after finally
              $async$goto = 5;
              break;
            case 2:
              // uncaught
              // goto rethrow
              $async$goto = 1;
              break;
            case 5:
              // after finally
              // implicit return
              return A._asyncReturn(null, $async$completer);
            case 1:
              // rethrow
              return A._asyncRethrow($async$errorStack.at(-1), $async$completer);
          }
      });
      return A._asyncStartSync($async$clearAllStudents, $async$completer);
    },
    initializeDatabase_closure: function initializeDatabase_closure() {
    },
    Finder_Finder(filter, limit, sortOrders) {
      return new A.SembastFinder(filter, null, limit, null, null, sortOrders);
    },
    printString(string) {
      if (typeof dartPrint == "function") {
        dartPrint(string);
        return;
      }
      if (typeof console == "object" && typeof console.log != "undefined") {
        console.log(string);
        return;
      }
      if (typeof print == "function") {
        print(string);
        return;
      }
      throw "Unable to print message: " + String(string);
    },
    JSAnyUtilityExtension_instanceOfString(_this, constructorName) {
      var parts, $constructor, t1, t2, _i, part;
      if (constructorName.length === 0)
        return false;
      parts = constructorName.split(".");
      $constructor = init.G;
      for (t1 = parts.length, t2 = type$.nullable_JSObject, _i = 0; _i < t1; ++_i) {
        part = parts[_i];
        $constructor = t2._as($constructor[part]);
        if ($constructor == null)
          return false;
      }
      return _this instanceof type$.JavaScriptFunction._as($constructor);
    },
    idbFactoryBrowser() {
      var t1, exception;
      try {
        t1 = $.$get$idbFactoryBrowserWrapperImpl();
        return t1;
      } catch (exception) {
        t1 = $._idbSembastMemoryFactoryImpl;
        if (t1 == null)
          t1 = $._idbSembastMemoryFactoryImpl = new A.IdbFactorySembastImpl($.$get$databaseFactoryMemory(), null);
        return t1;
      }
    },
    checkKeyParam(key) {
    },
    logTruncateAny(value) {
      var t1 = J.toString$0$(value),
        text = t1;
      return text.length > 128 ? B.JSString_methods.substring$2(text, 0, 128) : text;
    },
    toNativeKeyRange(common) {
      return null;
    },
    toNativeQuery(query) {
      return A.IDBJsifyExtension_jsifyValueStrict(query);
    },
    keyOrKeyRangeToNativeQuery(key, range) {
      var t1 = A.toNativeKeyRange(range);
      return t1;
    },
    SembastContentCodecAsyncSupport_get__contentCodecAsync(_this) {
      return type$.AsyncCodec_of_nullable_Object_and_String._as(_this);
    },
    SembastContentCodecAsyncSupport_encodeContent(_this, value) {
      var t1 = _this.encode$1(value);
      return t1;
    },
    SembastContentCodecAsyncSupport_encodeContentAsync(_this, value) {
      return A.SembastContentCodecAsyncSupport_encodeContentAsync$body(_this, value);
    },
    SembastContentCodecAsyncSupport_encodeContentAsync$body(_this, value) {
      var $async$goto = 0,
        $async$completer = A._makeAsyncAwaitCompleter(type$.String),
        $async$returnValue;
      var $async$SembastContentCodecAsyncSupport_encodeContentAsync = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return A._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$goto = 3;
              return A._asyncAwait(A.SembastContentCodecAsyncSupport_get__contentCodecAsync(_this).encodeAsync$1(value), $async$SembastContentCodecAsyncSupport_encodeContentAsync);
            case 3:
              // returning from await.
              $async$returnValue = $async$result;
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return A._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return A._asyncStartSync($async$SembastContentCodecAsyncSupport_encodeContentAsync, $async$completer);
    },
    PushIdGenerator_generatePushChildName() {
      var timeStampChars, now0, i, result,
        _s64_ = "-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz",
        now = Date.now(),
        t1 = $.PushIdGenerator__lastPushTime;
      $.PushIdGenerator__lastPushTime = now;
      timeStampChars = A.List_List$filled(8, null, false, type$.nullable_String);
      for (now0 = now, i = 7; i >= 0; --i) {
        B.JSArray_methods.$indexSet(timeStampChars, i, _s64_[B.JSInt_methods.$mod(now0, 64)]);
        now0 = B.JSNumber_methods.floor$0(now0 / 64);
      }
      result = new A.StringBuffer(B.JSArray_methods.join$0(timeStampChars));
      if (now !== t1)
        for (i = 0; i < 12; ++i)
          B.JSArray_methods.$indexSet($.$get$PushIdGenerator__lastRandChars(), i, $.$get$PushIdGenerator__random().nextInt$1(64));
      else
        A.PushIdGenerator__incrementArray();
      for (i = 0; i < 12; ++i) {
        t1 = $.$get$PushIdGenerator__lastRandChars()[i];
        t1.toString;
        if (!(t1 >= 0 && t1 < 64))
          return A.ioore(_s64_, t1);
        result._contents += _s64_[t1];
      }
      t1 = result._contents;
      return t1.charCodeAt(0) == 0 ? t1 : t1;
    },
    PushIdGenerator__incrementArray() {
      var i, t1, t2;
      for (i = 11; i >= 0; --i) {
        t1 = $.$get$PushIdGenerator__lastRandChars();
        t2 = t1[i];
        if (t2 !== 63) {
          t2.toString;
          B.JSArray_methods.$indexSet(t1, i, t2 + 1);
          return;
        }
        B.JSArray_methods.$indexSet(t1, i, 0);
      }
    },
    sembastCodecContentCodec(sembastCodec) {
      return B.C_JsonCodec;
    },
    getCodecEncodedSignature(codec) {
      return null;
    },
    valuesAreEquals(value1, value2) {
      var t1, t2, i, key;
      if (value1 == null)
        return value2 == null;
      else if (value2 == null)
        return false;
      t1 = type$.List_dynamic;
      if (t1._is(value1)) {
        if (t1._is(value2)) {
          t1 = J.getInterceptor$asx(value1);
          t2 = J.getInterceptor$asx(value2);
          if (t1.get$length(value1) !== t2.get$length(value2))
            return false;
          for (i = 0; i < t1.get$length(value1); ++i)
            if (!A.valuesAreEquals(t1.$index(value1, i), t2.$index(value2, i)))
              return false;
          return true;
        }
        return false;
      } else {
        t1 = type$.Map_dynamic_dynamic;
        if (t1._is(value1))
          if (t1._is(value2)) {
            if (value1.get$length(value1) !== value2.get$length(value2))
              return false;
            for (t1 = value1.get$keys(), t1 = t1.get$iterator(t1); t1.moveNext$0();) {
              key = t1.get$current();
              if (!A.valuesAreEquals(value1.$index(0, key), value2.$index(0, key)))
                return false;
            }
            return true;
          }
      }
      return J.$eq$(value1, value2);
    },
    Lock_Lock() {
      return new A.BasicLock();
    }
  },
  B = {};
  var holders = [A, J, B];
  var $ = {};
  A.JS_CONST.prototype = {};
  J.Interceptor.prototype = {
    $eq(receiver, other) {
      return receiver === other;
    },
    get$hashCode(receiver) {
      return A.Primitives_objectHashCode(receiver);
    },
    toString$0(receiver) {
      return "Instance of '" + A.Primitives_objectTypeName(receiver) + "'";
    },
    get$runtimeType(receiver) {
      return A.createRuntimeType(A._instanceTypeFromConstructor(this));
    }
  };
  J.JSBool.prototype = {
    toString$0(receiver) {
      return String(receiver);
    },
    get$hashCode(receiver) {
      return receiver ? 519018 : 218159;
    },
    get$runtimeType(receiver) {
      return A.createRuntimeType(type$.bool);
    },
    $isTrustedGetRuntimeType: 1,
    $isbool: 1
  };
  J.JSNull.prototype = {
    $eq(receiver, other) {
      return null == other;
    },
    toString$0(receiver) {
      return "null";
    },
    get$hashCode(receiver) {
      return 0;
    },
    get$runtimeType(receiver) {
      return A.createRuntimeType(type$.Null);
    },
    $isTrustedGetRuntimeType: 1,
    $isNull: 1
  };
  J.JavaScriptObject.prototype = {$isJSObject: 1};
  J.LegacyJavaScriptObject.prototype = {
    get$hashCode(receiver) {
      return 0;
    },
    get$runtimeType(receiver) {
      return B.Type_JSObject_ttY;
    },
    toString$0(receiver) {
      return String(receiver);
    }
  };
  J.PlainJavaScriptObject.prototype = {};
  J.UnknownJavaScriptObject.prototype = {};
  J.JavaScriptFunction.prototype = {
    toString$0(receiver) {
      var dartClosure = receiver[$.$get$DART_CLOSURE_PROPERTY_NAME()];
      if (dartClosure == null)
        return this.super$LegacyJavaScriptObject$toString(receiver);
      return "JavaScript function for " + J.toString$0$(dartClosure);
    },
    $isFunction: 1
  };
  J.JavaScriptBigInt.prototype = {
    get$hashCode(receiver) {
      return 0;
    },
    toString$0(receiver) {
      return String(receiver);
    }
  };
  J.JavaScriptSymbol.prototype = {
    get$hashCode(receiver) {
      return 0;
    },
    toString$0(receiver) {
      return String(receiver);
    }
  };
  J.JSArray.prototype = {
    cast$1$0(receiver, $R) {
      return new A.CastList(receiver, A._arrayInstanceType(receiver)._eval$1("@<1>")._bind$1($R)._eval$1("CastList<1,2>"));
    },
    add$1(receiver, value) {
      A._arrayInstanceType(receiver)._precomputed1._as(value);
      receiver.$flags & 1 && A.throwUnsupportedOperation(receiver, 29);
      receiver.push(value);
    },
    remove$1(receiver, element) {
      var i;
      receiver.$flags & 1 && A.throwUnsupportedOperation(receiver, "remove", 1);
      for (i = 0; i < receiver.length; ++i)
        if (J.$eq$(receiver[i], element)) {
          receiver.splice(i, 1);
          return true;
        }
      return false;
    },
    addAll$1(receiver, collection) {
      var t1;
      A._arrayInstanceType(receiver)._eval$1("Iterable<1>")._as(collection);
      receiver.$flags & 1 && A.throwUnsupportedOperation(receiver, "addAll", 2);
      if (Array.isArray(collection)) {
        this._addAllFromArray$1(receiver, collection);
        return;
      }
      for (t1 = J.get$iterator$ax(collection); t1.moveNext$0();)
        receiver.push(t1.get$current());
    },
    _addAllFromArray$1(receiver, array) {
      var len, i;
      type$.JSArray_dynamic._as(array);
      len = array.length;
      if (len === 0)
        return;
      if (receiver === array)
        throw A.wrapException(A.ConcurrentModificationError$(receiver));
      for (i = 0; i < len; ++i)
        receiver.push(array[i]);
    },
    clear$0(receiver) {
      receiver.$flags & 1 && A.throwUnsupportedOperation(receiver, "clear", "clear");
      receiver.length = 0;
    },
    forEach$1(receiver, f) {
      var end, i;
      A._arrayInstanceType(receiver)._eval$1("~(1)")._as(f);
      end = receiver.length;
      for (i = 0; i < end; ++i) {
        f.call$1(receiver[i]);
        if (receiver.length !== end)
          throw A.wrapException(A.ConcurrentModificationError$(receiver));
      }
    },
    map$1$1(receiver, f, $T) {
      var t1 = A._arrayInstanceType(receiver);
      return new A.MappedListIterable(receiver, t1._bind$1($T)._eval$1("1(2)")._as(f), t1._eval$1("@<1>")._bind$1($T)._eval$1("MappedListIterable<1,2>"));
    },
    join$1(receiver, separator) {
      var i,
        list = A.List_List$filled(receiver.length, "", false, type$.String);
      for (i = 0; i < receiver.length; ++i)
        this.$indexSet(list, i, A.S(receiver[i]));
      return list.join(separator);
    },
    join$0(receiver) {
      return this.join$1(receiver, "");
    },
    take$1(receiver, n) {
      return A.SubListIterable$(receiver, 0, A.checkNotNullable(n, "count", type$.int), A._arrayInstanceType(receiver)._precomputed1);
    },
    skip$1(receiver, n) {
      return A.SubListIterable$(receiver, n, null, A._arrayInstanceType(receiver)._precomputed1);
    },
    elementAt$1(receiver, index) {
      if (!(index >= 0 && index < receiver.length))
        return A.ioore(receiver, index);
      return receiver[index];
    },
    sublist$2(receiver, start, end) {
      if (start < 0 || start > receiver.length)
        throw A.wrapException(A.RangeError$range(start, 0, receiver.length, "start", null));
      if (end == null)
        end = receiver.length;
      else if (end < start || end > receiver.length)
        throw A.wrapException(A.RangeError$range(end, start, receiver.length, "end", null));
      if (start === end)
        return A._setArrayType([], A._arrayInstanceType(receiver));
      return A._setArrayType(receiver.slice(start, end), A._arrayInstanceType(receiver));
    },
    get$first(receiver) {
      if (receiver.length > 0)
        return receiver[0];
      throw A.wrapException(A.IterableElementError_noElement());
    },
    get$last(receiver) {
      var t1 = receiver.length;
      if (t1 > 0)
        return receiver[t1 - 1];
      throw A.wrapException(A.IterableElementError_noElement());
    },
    sort$1(receiver, compare) {
      var len, a, b, undefineds, i,
        t1 = A._arrayInstanceType(receiver);
      t1._eval$1("int(1,1)?")._as(compare);
      receiver.$flags & 2 && A.throwUnsupportedOperation(receiver, "sort");
      len = receiver.length;
      if (len < 2)
        return;
      if (compare == null)
        compare = J._interceptors_JSArray__compareAny$closure();
      if (len === 2) {
        a = receiver[0];
        b = receiver[1];
        t1 = compare.call$2(a, b);
        if (typeof t1 !== "number")
          return t1.$gt();
        if (t1 > 0) {
          receiver[0] = b;
          receiver[1] = a;
        }
        return;
      }
      undefineds = 0;
      if (t1._precomputed1._is(null))
        for (i = 0; i < receiver.length; ++i)
          if (receiver[i] === void 0) {
            receiver[i] = null;
            ++undefineds;
          }
      receiver.sort(A.convertDartClosureToJS(compare, 2));
      if (undefineds > 0)
        this._replaceSomeNullsWithUndefined$1(receiver, undefineds);
    },
    sort$0(receiver) {
      return this.sort$1(receiver, null);
    },
    _replaceSomeNullsWithUndefined$1(receiver, count) {
      var i0,
        i = receiver.length;
      for (; i0 = i - 1, i > 0; i = i0)
        if (receiver[i0] === null) {
          receiver[i0] = void 0;
          --count;
          if (count === 0)
            break;
        }
    },
    contains$1(receiver, other) {
      var i;
      for (i = 0; i < receiver.length; ++i)
        if (J.$eq$(receiver[i], other))
          return true;
      return false;
    },
    get$isEmpty(receiver) {
      return receiver.length === 0;
    },
    get$isNotEmpty(receiver) {
      return receiver.length !== 0;
    },
    toString$0(receiver) {
      return A.Iterable_iterableToFullString(receiver, "[", "]");
    },
    toList$1$growable(receiver, growable) {
      var t1 = A._arrayInstanceType(receiver);
      return growable ? A._setArrayType(receiver.slice(0), t1) : J.JSArray_JSArray$markFixed(receiver.slice(0), t1._precomputed1);
    },
    get$iterator(receiver) {
      return new J.ArrayIterator(receiver, receiver.length, A._arrayInstanceType(receiver)._eval$1("ArrayIterator<1>"));
    },
    get$hashCode(receiver) {
      return A.Primitives_objectHashCode(receiver);
    },
    get$length(receiver) {
      return receiver.length;
    },
    $index(receiver, index) {
      if (!(index >= 0 && index < receiver.length))
        throw A.wrapException(A.diagnoseIndexError(receiver, index));
      return receiver[index];
    },
    $indexSet(receiver, index, value) {
      A._arrayInstanceType(receiver)._precomputed1._as(value);
      receiver.$flags & 2 && A.throwUnsupportedOperation(receiver);
      if (!(index >= 0 && index < receiver.length))
        throw A.wrapException(A.diagnoseIndexError(receiver, index));
      receiver[index] = value;
    },
    get$runtimeType(receiver) {
      return A.createRuntimeType(A._arrayInstanceType(receiver));
    },
    $isEfficientLengthIterable: 1,
    $isIterable: 1,
    $isList: 1
  };
  J.JSUnmodifiableArray.prototype = {};
  J.ArrayIterator.prototype = {
    get$current() {
      var t1 = this._current;
      return t1 == null ? this.$ti._precomputed1._as(t1) : t1;
    },
    moveNext$0() {
      var t2, _this = this,
        t1 = _this._iterable,
        $length = t1.length;
      if (_this._length !== $length) {
        t1 = A.throwConcurrentModificationError(t1);
        throw A.wrapException(t1);
      }
      t2 = _this._index;
      if (t2 >= $length) {
        _this._current = null;
        return false;
      }
      _this._current = t1[t2];
      _this._index = t2 + 1;
      return true;
    },
    $isIterator: 1
  };
  J.JSNumber.prototype = {
    compareTo$1(receiver, b) {
      var bIsNegative;
      A._asNum(b);
      if (receiver < b)
        return -1;
      else if (receiver > b)
        return 1;
      else if (receiver === b) {
        if (receiver === 0) {
          bIsNegative = this.get$isNegative(b);
          if (this.get$isNegative(receiver) === bIsNegative)
            return 0;
          if (this.get$isNegative(receiver))
            return -1;
          return 1;
        }
        return 0;
      } else if (isNaN(receiver)) {
        if (isNaN(b))
          return 0;
        return 1;
      } else
        return -1;
    },
    get$isNegative(receiver) {
      return receiver === 0 ? 1 / receiver < 0 : receiver < 0;
    },
    floor$0(receiver) {
      var truncated, d;
      if (receiver >= 0) {
        if (receiver <= 2147483647)
          return receiver | 0;
      } else if (receiver >= -2147483648) {
        truncated = receiver | 0;
        return receiver === truncated ? truncated : truncated - 1;
      }
      d = Math.floor(receiver);
      if (isFinite(d))
        return d;
      throw A.wrapException(A.UnsupportedError$("" + receiver + ".floor()"));
    },
    toRadixString$1(receiver, radix) {
      var result, t1, t2, match, exponent;
      if (radix < 2 || radix > 36)
        throw A.wrapException(A.RangeError$range(radix, 2, 36, "radix", null));
      result = receiver.toString(radix);
      t1 = result.length;
      t2 = t1 - 1;
      if (!(t2 >= 0))
        return A.ioore(result, t2);
      if (result.charCodeAt(t2) !== 41)
        return result;
      match = /^([\da-z]+)(?:\.([\da-z]+))?\(e\+(\d+)\)$/.exec(result);
      if (match == null)
        A.throwExpression(A.UnsupportedError$("Unexpected toString result: " + result));
      t1 = match.length;
      if (1 >= t1)
        return A.ioore(match, 1);
      result = match[1];
      if (3 >= t1)
        return A.ioore(match, 3);
      exponent = +match[3];
      t1 = match[2];
      if (t1 != null) {
        result += t1;
        exponent -= t1.length;
      }
      return result + B.JSString_methods.$mul("0", exponent);
    },
    toString$0(receiver) {
      if (receiver === 0 && 1 / receiver < 0)
        return "-0.0";
      else
        return "" + receiver;
    },
    get$hashCode(receiver) {
      var absolute, floorLog2, factor, scaled,
        intValue = receiver | 0;
      if (receiver === intValue)
        return intValue & 536870911;
      absolute = Math.abs(receiver);
      floorLog2 = Math.log(absolute) / 0.6931471805599453 | 0;
      factor = Math.pow(2, floorLog2);
      scaled = absolute < 1 ? absolute / factor : factor / absolute;
      return ((scaled * 9007199254740992 | 0) + (scaled * 3542243181176521 | 0)) * 599197 + floorLog2 * 1259 & 536870911;
    },
    $mod(receiver, other) {
      var result = receiver % other;
      if (result === 0)
        return 0;
      if (result > 0)
        return result;
      return result + other;
    },
    _tdivFast$1(receiver, other) {
      return (receiver | 0) === receiver ? receiver / other | 0 : this._tdivSlow$1(receiver, other);
    },
    _tdivSlow$1(receiver, other) {
      var quotient = receiver / other;
      if (quotient >= -2147483648 && quotient <= 2147483647)
        return quotient | 0;
      if (quotient > 0) {
        if (quotient !== 1 / 0)
          return Math.floor(quotient);
      } else if (quotient > -1 / 0)
        return Math.ceil(quotient);
      throw A.wrapException(A.UnsupportedError$("Result of truncating division is " + A.S(quotient) + ": " + A.S(receiver) + " ~/ " + other));
    },
    _shrOtherPositive$1(receiver, other) {
      var t1;
      if (receiver > 0)
        t1 = this._shrBothPositive$1(receiver, other);
      else {
        t1 = other > 31 ? 31 : other;
        t1 = receiver >> t1 >>> 0;
      }
      return t1;
    },
    _shrBothPositive$1(receiver, other) {
      return other > 31 ? 0 : receiver >>> other;
    },
    $gt(receiver, other) {
      return receiver > other;
    },
    get$runtimeType(receiver) {
      return A.createRuntimeType(type$.num);
    },
    $isComparable: 1,
    $isdouble: 1,
    $isnum: 1
  };
  J.JSInt.prototype = {
    get$runtimeType(receiver) {
      return A.createRuntimeType(type$.int);
    },
    $isTrustedGetRuntimeType: 1,
    $isint: 1
  };
  J.JSNumNotInt.prototype = {
    get$runtimeType(receiver) {
      return A.createRuntimeType(type$.double);
    },
    $isTrustedGetRuntimeType: 1
  };
  J.JSString.prototype = {
    startsWith$2(receiver, pattern, index) {
      var endIndex;
      if (index < 0 || index > receiver.length)
        throw A.wrapException(A.RangeError$range(index, 0, receiver.length, null, null));
      endIndex = index + pattern.length;
      if (endIndex > receiver.length)
        return false;
      return pattern === receiver.substring(index, endIndex);
    },
    startsWith$1(receiver, pattern) {
      return this.startsWith$2(receiver, pattern, 0);
    },
    substring$2(receiver, start, end) {
      return receiver.substring(start, A.RangeError_checkValidRange(start, end, receiver.length));
    },
    substring$1(receiver, start) {
      return this.substring$2(receiver, start, null);
    },
    trim$0(receiver) {
      var startIndex, t1, endIndex0,
        result = receiver.trim(),
        endIndex = result.length;
      if (endIndex === 0)
        return result;
      if (0 >= endIndex)
        return A.ioore(result, 0);
      if (result.charCodeAt(0) === 133) {
        startIndex = J.JSString__skipLeadingWhitespace(result, 1);
        if (startIndex === endIndex)
          return "";
      } else
        startIndex = 0;
      t1 = endIndex - 1;
      if (!(t1 >= 0))
        return A.ioore(result, t1);
      endIndex0 = result.charCodeAt(t1) === 133 ? J.JSString__skipTrailingWhitespace(result, t1) : endIndex;
      if (startIndex === 0 && endIndex0 === endIndex)
        return result;
      return result.substring(startIndex, endIndex0);
    },
    $mul(receiver, times) {
      var s, result;
      if (0 >= times)
        return "";
      if (times === 1 || receiver.length === 0)
        return receiver;
      if (times !== times >>> 0)
        throw A.wrapException(B.C_OutOfMemoryError);
      for (s = receiver, result = ""; true;) {
        if ((times & 1) === 1)
          result = s + result;
        times = times >>> 1;
        if (times === 0)
          break;
        s += s;
      }
      return result;
    },
    padLeft$2(receiver, width, padding) {
      var delta = width - receiver.length;
      if (delta <= 0)
        return receiver;
      return this.$mul(padding, delta) + receiver;
    },
    lastIndexOf$2(receiver, pattern, start) {
      var t1, t2;
      if (start == null)
        start = receiver.length;
      else if (start < 0 || start > receiver.length)
        throw A.wrapException(A.RangeError$range(start, 0, receiver.length, null, null));
      t1 = pattern.length;
      t2 = receiver.length;
      if (start + t1 > t2)
        start = t2 - t1;
      return receiver.lastIndexOf(pattern, start);
    },
    lastIndexOf$1(receiver, pattern) {
      return this.lastIndexOf$2(receiver, pattern, null);
    },
    compareTo$1(receiver, other) {
      var t1;
      A._asString(other);
      if (receiver === other)
        t1 = 0;
      else
        t1 = receiver < other ? -1 : 1;
      return t1;
    },
    toString$0(receiver) {
      return receiver;
    },
    get$hashCode(receiver) {
      var t1, hash, i;
      for (t1 = receiver.length, hash = 0, i = 0; i < t1; ++i) {
        hash = hash + receiver.charCodeAt(i) & 536870911;
        hash = hash + ((hash & 524287) << 10) & 536870911;
        hash ^= hash >> 6;
      }
      hash = hash + ((hash & 67108863) << 3) & 536870911;
      hash ^= hash >> 11;
      return hash + ((hash & 16383) << 15) & 536870911;
    },
    get$runtimeType(receiver) {
      return A.createRuntimeType(type$.String);
    },
    get$length(receiver) {
      return receiver.length;
    },
    $isTrustedGetRuntimeType: 1,
    $isComparable: 1,
    $isPattern: 1,
    $isString: 1
  };
  A._CastIterableBase.prototype = {
    get$iterator(_) {
      return new A.CastIterator(J.get$iterator$ax(this.get$_source()), A._instanceType(this)._eval$1("CastIterator<1,2>"));
    },
    get$length(_) {
      return J.get$length$asx(this.get$_source());
    },
    get$isEmpty(_) {
      return J.get$isEmpty$asx(this.get$_source());
    },
    get$isNotEmpty(_) {
      return J.get$isNotEmpty$asx(this.get$_source());
    },
    skip$1(_, count) {
      var t1 = A._instanceType(this);
      return A.CastIterable_CastIterable(J.skip$1$ax(this.get$_source(), count), t1._precomputed1, t1._rest[1]);
    },
    take$1(_, count) {
      var t1 = A._instanceType(this);
      return A.CastIterable_CastIterable(J.take$1$ax(this.get$_source(), count), t1._precomputed1, t1._rest[1]);
    },
    elementAt$1(_, index) {
      return A._instanceType(this)._rest[1]._as(J.elementAt$1$ax(this.get$_source(), index));
    },
    get$first(_) {
      return A._instanceType(this)._rest[1]._as(J.get$first$ax(this.get$_source()));
    },
    contains$1(_, other) {
      return J.contains$1$asx(this.get$_source(), other);
    },
    toString$0(_) {
      return J.toString$0$(this.get$_source());
    }
  };
  A.CastIterator.prototype = {
    moveNext$0() {
      return this._source.moveNext$0();
    },
    get$current() {
      return this.$ti._rest[1]._as(this._source.get$current());
    },
    $isIterator: 1
  };
  A.CastIterable.prototype = {
    cast$1$0(_, $R) {
      return A.CastIterable_CastIterable(this._source, A._instanceType(this)._precomputed1, $R);
    },
    get$_source() {
      return this._source;
    }
  };
  A._EfficientLengthCastIterable.prototype = {$isEfficientLengthIterable: 1};
  A._CastListBase.prototype = {
    $index(_, index) {
      return this.$ti._rest[1]._as(J.$index$asx(this._source, index));
    },
    $isEfficientLengthIterable: 1,
    $isList: 1
  };
  A.CastList.prototype = {
    cast$1$0(_, $R) {
      return new A.CastList(this._source, this.$ti._eval$1("@<1>")._bind$1($R)._eval$1("CastList<1,2>"));
    },
    get$_source() {
      return this._source;
    }
  };
  A.CastSet.prototype = {
    cast$1$0(_, $R) {
      return new A.CastSet(this._source, this._emptySet, this.$ti._eval$1("@<1>")._bind$1($R)._eval$1("CastSet<1,2>"));
    },
    addAll$1(_, elements) {
      var t1 = this.$ti;
      this._source.addAll$1(0, A.CastIterable_CastIterable(t1._eval$1("Iterable<2>")._as(elements), t1._rest[1], t1._precomputed1));
    },
    $isEfficientLengthIterable: 1,
    $isSet: 1,
    get$_source() {
      return this._source;
    }
  };
  A.CastMap.prototype = {
    cast$2$0(_, RK, RV) {
      return new A.CastMap(this._source, this.$ti._eval$1("@<1,2>")._bind$1(RK)._bind$1(RV)._eval$1("CastMap<1,2,3,4>"));
    },
    $index(_, key) {
      return this.$ti._eval$1("4?")._as(this._source.$index(0, key));
    },
    $indexSet(_, key, value) {
      var t1 = this.$ti;
      t1._rest[2]._as(key);
      t1._rest[3]._as(value);
      this._source.$indexSet(0, t1._precomputed1._as(key), t1._rest[1]._as(value));
    },
    forEach$1(_, f) {
      this._source.forEach$1(0, new A.CastMap_forEach_closure(this, this.$ti._eval$1("~(3,4)")._as(f)));
    },
    get$keys() {
      var t1 = this.$ti;
      return A.CastIterable_CastIterable(this._source.get$keys(), t1._precomputed1, t1._rest[2]);
    },
    get$values() {
      var t1 = this.$ti;
      return A.CastIterable_CastIterable(this._source.get$values(), t1._rest[1], t1._rest[3]);
    },
    get$length(_) {
      var t1 = this._source;
      return t1.get$length(t1);
    },
    get$isEmpty(_) {
      var t1 = this._source;
      return t1.get$isEmpty(t1);
    },
    get$isNotEmpty(_) {
      var t1 = this._source;
      return t1.get$isNotEmpty(t1);
    }
  };
  A.CastMap_forEach_closure.prototype = {
    call$2(key, value) {
      var t1 = this.$this.$ti;
      t1._precomputed1._as(key);
      t1._rest[1]._as(value);
      this.f.call$2(t1._rest[2]._as(key), t1._rest[3]._as(value));
    },
    $signature() {
      return this.$this.$ti._eval$1("~(1,2)");
    }
  };
  A.LateError.prototype = {
    toString$0(_) {
      return "LateInitializationError: " + this.__internal$_message;
    }
  };
  A.nullFuture_closure.prototype = {
    call$0() {
      return A.Future_Future$value(null, type$.void);
    },
    $signature: 14
  };
  A.SentinelValue.prototype = {};
  A.EfficientLengthIterable.prototype = {};
  A.ListIterable.prototype = {
    get$iterator(_) {
      var _this = this;
      return new A.ListIterator(_this, _this.get$length(_this), A._instanceType(_this)._eval$1("ListIterator<ListIterable.E>"));
    },
    get$isEmpty(_) {
      return this.get$length(this) === 0;
    },
    get$first(_) {
      if (this.get$length(this) === 0)
        throw A.wrapException(A.IterableElementError_noElement());
      return this.elementAt$1(0, 0);
    },
    contains$1(_, element) {
      var i, _this = this,
        $length = _this.get$length(_this);
      for (i = 0; i < $length; ++i) {
        if (J.$eq$(_this.elementAt$1(0, i), element))
          return true;
        if ($length !== _this.get$length(_this))
          throw A.wrapException(A.ConcurrentModificationError$(_this));
      }
      return false;
    },
    map$1$1(_, toElement, $T) {
      var t1 = A._instanceType(this);
      return new A.MappedListIterable(this, t1._bind$1($T)._eval$1("1(ListIterable.E)")._as(toElement), t1._eval$1("@<ListIterable.E>")._bind$1($T)._eval$1("MappedListIterable<1,2>"));
    },
    skip$1(_, count) {
      return A.SubListIterable$(this, count, null, A._instanceType(this)._eval$1("ListIterable.E"));
    },
    take$1(_, count) {
      return A.SubListIterable$(this, 0, A.checkNotNullable(count, "count", type$.int), A._instanceType(this)._eval$1("ListIterable.E"));
    },
    toList$1$growable(_, growable) {
      var t1 = A._instanceType(this)._eval$1("ListIterable.E");
      if (growable)
        t1 = A.List_List$_of(this, t1);
      else {
        t1 = A.List_List$_of(this, t1);
        t1.$flags = 1;
        t1 = t1;
      }
      return t1;
    },
    toList$0(_) {
      return this.toList$1$growable(0, true);
    }
  };
  A.SubListIterable.prototype = {
    get$_endIndex() {
      var $length = J.get$length$asx(this.__internal$_iterable),
        endOrLength = this._endOrLength;
      if (endOrLength == null || endOrLength > $length)
        return $length;
      return endOrLength;
    },
    get$_startIndex() {
      var $length = J.get$length$asx(this.__internal$_iterable),
        t1 = this._start;
      if (t1 > $length)
        return $length;
      return t1;
    },
    get$length(_) {
      var endOrLength,
        $length = J.get$length$asx(this.__internal$_iterable),
        t1 = this._start;
      if (t1 >= $length)
        return 0;
      endOrLength = this._endOrLength;
      if (endOrLength == null || endOrLength >= $length)
        return $length - t1;
      return endOrLength - t1;
    },
    elementAt$1(_, index) {
      var _this = this,
        realIndex = _this.get$_startIndex() + index;
      if (index < 0 || realIndex >= _this.get$_endIndex())
        throw A.wrapException(A.IndexError$withLength(index, _this.get$length(0), _this, null, "index"));
      return J.elementAt$1$ax(_this.__internal$_iterable, realIndex);
    },
    skip$1(_, count) {
      var newStart, endOrLength, _this = this;
      A.RangeError_checkNotNegative(count, "count");
      newStart = _this._start + count;
      endOrLength = _this._endOrLength;
      if (endOrLength != null && newStart >= endOrLength)
        return new A.EmptyIterable(_this.$ti._eval$1("EmptyIterable<1>"));
      return A.SubListIterable$(_this.__internal$_iterable, newStart, endOrLength, _this.$ti._precomputed1);
    },
    take$1(_, count) {
      var endOrLength, t1, newEnd, _this = this;
      A.RangeError_checkNotNegative(count, "count");
      endOrLength = _this._endOrLength;
      t1 = _this._start;
      newEnd = t1 + count;
      if (endOrLength == null)
        return A.SubListIterable$(_this.__internal$_iterable, t1, newEnd, _this.$ti._precomputed1);
      else {
        if (endOrLength < newEnd)
          return _this;
        return A.SubListIterable$(_this.__internal$_iterable, t1, newEnd, _this.$ti._precomputed1);
      }
    },
    toList$1$growable(_, growable) {
      var $length, result, i, _this = this,
        start = _this._start,
        t1 = _this.__internal$_iterable,
        t2 = J.getInterceptor$asx(t1),
        end = t2.get$length(t1),
        endOrLength = _this._endOrLength;
      if (endOrLength != null && endOrLength < end)
        end = endOrLength;
      $length = end - start;
      if ($length <= 0) {
        t1 = J.JSArray_JSArray$fixed(0, _this.$ti._precomputed1);
        return t1;
      }
      result = A.List_List$filled($length, t2.elementAt$1(t1, start), false, _this.$ti._precomputed1);
      for (i = 1; i < $length; ++i) {
        B.JSArray_methods.$indexSet(result, i, t2.elementAt$1(t1, start + i));
        if (t2.get$length(t1) < end)
          throw A.wrapException(A.ConcurrentModificationError$(_this));
      }
      return result;
    }
  };
  A.ListIterator.prototype = {
    get$current() {
      var t1 = this.__internal$_current;
      return t1 == null ? this.$ti._precomputed1._as(t1) : t1;
    },
    moveNext$0() {
      var t3, _this = this,
        t1 = _this.__internal$_iterable,
        t2 = J.getInterceptor$asx(t1),
        $length = t2.get$length(t1);
      if (_this.__internal$_length !== $length)
        throw A.wrapException(A.ConcurrentModificationError$(t1));
      t3 = _this.__internal$_index;
      if (t3 >= $length) {
        _this.__internal$_current = null;
        return false;
      }
      _this.__internal$_current = t2.elementAt$1(t1, t3);
      ++_this.__internal$_index;
      return true;
    },
    $isIterator: 1
  };
  A.MappedIterable.prototype = {
    get$iterator(_) {
      return new A.MappedIterator(J.get$iterator$ax(this.__internal$_iterable), this._f, A._instanceType(this)._eval$1("MappedIterator<1,2>"));
    },
    get$length(_) {
      return J.get$length$asx(this.__internal$_iterable);
    },
    get$isEmpty(_) {
      return J.get$isEmpty$asx(this.__internal$_iterable);
    },
    get$first(_) {
      return this._f.call$1(J.get$first$ax(this.__internal$_iterable));
    },
    elementAt$1(_, index) {
      return this._f.call$1(J.elementAt$1$ax(this.__internal$_iterable, index));
    }
  };
  A.EfficientLengthMappedIterable.prototype = {$isEfficientLengthIterable: 1};
  A.MappedIterator.prototype = {
    moveNext$0() {
      var _this = this,
        t1 = _this._iterator;
      if (t1.moveNext$0()) {
        _this.__internal$_current = _this._f.call$1(t1.get$current());
        return true;
      }
      _this.__internal$_current = null;
      return false;
    },
    get$current() {
      var t1 = this.__internal$_current;
      return t1 == null ? this.$ti._rest[1]._as(t1) : t1;
    },
    $isIterator: 1
  };
  A.MappedListIterable.prototype = {
    get$length(_) {
      return J.get$length$asx(this._source);
    },
    elementAt$1(_, index) {
      return this._f.call$1(J.elementAt$1$ax(this._source, index));
    }
  };
  A.WhereIterable.prototype = {
    get$iterator(_) {
      return new A.WhereIterator(J.get$iterator$ax(this.__internal$_iterable), this._f, this.$ti._eval$1("WhereIterator<1>"));
    },
    map$1$1(_, toElement, $T) {
      var t1 = this.$ti;
      return new A.MappedIterable(this, t1._bind$1($T)._eval$1("1(2)")._as(toElement), t1._eval$1("@<1>")._bind$1($T)._eval$1("MappedIterable<1,2>"));
    }
  };
  A.WhereIterator.prototype = {
    moveNext$0() {
      var t1, t2;
      for (t1 = this._iterator, t2 = this._f; t1.moveNext$0();)
        if (t2.call$1(t1.get$current()))
          return true;
      return false;
    },
    get$current() {
      return this._iterator.get$current();
    },
    $isIterator: 1
  };
  A.TakeIterable.prototype = {
    get$iterator(_) {
      return new A.TakeIterator(J.get$iterator$ax(this.__internal$_iterable), this._takeCount, A._instanceType(this)._eval$1("TakeIterator<1>"));
    }
  };
  A.EfficientLengthTakeIterable.prototype = {
    get$length(_) {
      var iterableLength = J.get$length$asx(this.__internal$_iterable),
        t1 = this._takeCount;
      if (B.JSInt_methods.$gt(iterableLength, t1))
        return t1;
      return iterableLength;
    },
    $isEfficientLengthIterable: 1
  };
  A.TakeIterator.prototype = {
    moveNext$0() {
      if (--this._remaining >= 0)
        return this._iterator.moveNext$0();
      this._remaining = -1;
      return false;
    },
    get$current() {
      if (this._remaining < 0) {
        this.$ti._precomputed1._as(null);
        return null;
      }
      return this._iterator.get$current();
    },
    $isIterator: 1
  };
  A.SkipIterable.prototype = {
    skip$1(_, count) {
      A.ArgumentError_checkNotNull(count, "count", type$.int);
      A.RangeError_checkNotNegative(count, "count");
      return new A.SkipIterable(this.__internal$_iterable, this._skipCount + count, A._instanceType(this)._eval$1("SkipIterable<1>"));
    },
    get$iterator(_) {
      return new A.SkipIterator(J.get$iterator$ax(this.__internal$_iterable), this._skipCount, A._instanceType(this)._eval$1("SkipIterator<1>"));
    }
  };
  A.EfficientLengthSkipIterable.prototype = {
    get$length(_) {
      var $length = J.get$length$asx(this.__internal$_iterable) - this._skipCount;
      if ($length >= 0)
        return $length;
      return 0;
    },
    skip$1(_, count) {
      A.ArgumentError_checkNotNull(count, "count", type$.int);
      A.RangeError_checkNotNegative(count, "count");
      return new A.EfficientLengthSkipIterable(this.__internal$_iterable, this._skipCount + count, this.$ti);
    },
    $isEfficientLengthIterable: 1
  };
  A.SkipIterator.prototype = {
    moveNext$0() {
      var t1, i;
      for (t1 = this._iterator, i = 0; i < this._skipCount; ++i)
        t1.moveNext$0();
      this._skipCount = 0;
      return t1.moveNext$0();
    },
    get$current() {
      return this._iterator.get$current();
    },
    $isIterator: 1
  };
  A.EmptyIterable.prototype = {
    get$iterator(_) {
      return B.C_EmptyIterator;
    },
    get$isEmpty(_) {
      return true;
    },
    get$length(_) {
      return 0;
    },
    get$first(_) {
      throw A.wrapException(A.IterableElementError_noElement());
    },
    elementAt$1(_, index) {
      throw A.wrapException(A.RangeError$range(index, 0, 0, "index", null));
    },
    contains$1(_, element) {
      return false;
    },
    map$1$1(_, toElement, $T) {
      this.$ti._bind$1($T)._eval$1("1(2)")._as(toElement);
      return new A.EmptyIterable($T._eval$1("EmptyIterable<0>"));
    },
    skip$1(_, count) {
      A.RangeError_checkNotNegative(count, "count");
      return this;
    },
    take$1(_, count) {
      A.RangeError_checkNotNegative(count, "count");
      return this;
    },
    toList$1$growable(_, growable) {
      var t1 = this.$ti._precomputed1;
      return growable ? J.JSArray_JSArray$growable(0, t1) : J.JSArray_JSArray$fixed(0, t1);
    },
    toList$0(_) {
      return this.toList$1$growable(0, true);
    }
  };
  A.EmptyIterator.prototype = {
    moveNext$0() {
      return false;
    },
    get$current() {
      throw A.wrapException(A.IterableElementError_noElement());
    },
    $isIterator: 1
  };
  A.IndexedIterable.prototype = {
    get$length(_) {
      return J.get$length$asx(this._source);
    },
    get$isEmpty(_) {
      return J.get$isEmpty$asx(this._source);
    },
    get$isNotEmpty(_) {
      return J.get$isNotEmpty$asx(this._source);
    },
    get$first(_) {
      return new A._Record_2(this._start, J.get$first$ax(this._source));
    },
    elementAt$1(_, index) {
      return new A._Record_2(index + this._start, J.elementAt$1$ax(this._source, index));
    },
    contains$1(_, element) {
      return false;
    },
    take$1(_, count) {
      A.ArgumentError_checkNotNull(count, "count", type$.int);
      A.RangeError_checkNotNegative(count, "count");
      return new A.IndexedIterable(J.take$1$ax(this._source, count), this._start, A._instanceType(this)._eval$1("IndexedIterable<1>"));
    },
    skip$1(_, count) {
      A.ArgumentError_checkNotNull(count, "count", type$.int);
      A.RangeError_checkNotNegative(count, "count");
      return new A.IndexedIterable(J.skip$1$ax(this._source, count), count + this._start, A._instanceType(this)._eval$1("IndexedIterable<1>"));
    },
    get$iterator(_) {
      return new A.IndexedIterator(J.get$iterator$ax(this._source), this._start, A._instanceType(this)._eval$1("IndexedIterator<1>"));
    }
  };
  A.EfficientLengthIndexedIterable.prototype = {
    contains$1(_, element) {
      return false;
    },
    take$1(_, count) {
      A.ArgumentError_checkNotNull(count, "count", type$.int);
      A.RangeError_checkNotNegative(count, "count");
      return new A.EfficientLengthIndexedIterable(J.take$1$ax(this._source, count), this._start, this.$ti);
    },
    skip$1(_, count) {
      A.ArgumentError_checkNotNull(count, "count", type$.int);
      A.RangeError_checkNotNegative(count, "count");
      return new A.EfficientLengthIndexedIterable(J.skip$1$ax(this._source, count), this._start + count, this.$ti);
    },
    $isEfficientLengthIterable: 1
  };
  A.IndexedIterator.prototype = {
    moveNext$0() {
      if (++this.__internal$_index >= 0 && this._source.moveNext$0())
        return true;
      this.__internal$_index = -2;
      return false;
    },
    get$current() {
      var t1 = this.__internal$_index;
      return t1 >= 0 ? new A._Record_2(this._start + t1, this._source.get$current()) : A.throwExpression(A.IterableElementError_noElement());
    },
    $isIterator: 1
  };
  A.FixedLengthListMixin.prototype = {};
  A.__CastListBase__CastIterableBase_ListMixin.prototype = {};
  A._Record_2.prototype = {$recipe: "+(1,2)", $shape: 1};
  A.Primitives_initTicker_closure.prototype = {
    call$0() {
      return B.JSNumber_methods.floor$0(1000 * this.performance.now());
    },
    $signature: 15
  };
  A.TypeErrorDecoder.prototype = {
    matchTypeError$1(message) {
      var result, t1, _this = this,
        match = new RegExp(_this._pattern).exec(message);
      if (match == null)
        return null;
      result = Object.create(null);
      t1 = _this._arguments;
      if (t1 !== -1)
        result.arguments = match[t1 + 1];
      t1 = _this._argumentsExpr;
      if (t1 !== -1)
        result.argumentsExpr = match[t1 + 1];
      t1 = _this._expr;
      if (t1 !== -1)
        result.expr = match[t1 + 1];
      t1 = _this._method;
      if (t1 !== -1)
        result.method = match[t1 + 1];
      t1 = _this._receiver;
      if (t1 !== -1)
        result.receiver = match[t1 + 1];
      return result;
    }
  };
  A.NullError.prototype = {
    toString$0(_) {
      return "Null check operator used on a null value";
    }
  };
  A.JsNoSuchMethodError.prototype = {
    toString$0(_) {
      var t2, _this = this,
        _s38_ = "NoSuchMethodError: method not found: '",
        t1 = _this._method;
      if (t1 == null)
        return "NoSuchMethodError: " + _this.__js_helper$_message;
      t2 = _this._receiver;
      if (t2 == null)
        return _s38_ + t1 + "' (" + _this.__js_helper$_message + ")";
      return _s38_ + t1 + "' on '" + t2 + "' (" + _this.__js_helper$_message + ")";
    }
  };
  A.UnknownJsTypeError.prototype = {
    toString$0(_) {
      var t1 = this.__js_helper$_message;
      return t1.length === 0 ? "Error" : "Error: " + t1;
    }
  };
  A.NullThrownFromJavaScriptException.prototype = {
    toString$0(_) {
      return "Throw of null ('" + (this._irritant === null ? "null" : "undefined") + "' from JavaScript)";
    },
    $isException: 1
  };
  A.ExceptionAndStackTrace.prototype = {};
  A._StackTrace.prototype = {
    toString$0(_) {
      var trace,
        t1 = this._trace;
      if (t1 != null)
        return t1;
      t1 = this._exception;
      trace = t1 !== null && typeof t1 === "object" ? t1.stack : null;
      return this._trace = trace == null ? "" : trace;
    },
    $isStackTrace: 1
  };
  A.Closure.prototype = {
    toString$0(_) {
      var $constructor = this.constructor,
        $name = $constructor == null ? null : $constructor.name;
      return "Closure '" + A.unminifyOrTag($name == null ? "unknown" : $name) + "'";
    },
    get$runtimeType(_) {
      var rti = A.closureFunctionType(this);
      return A.createRuntimeType(rti == null ? A.instanceType(this) : rti);
    },
    $isFunction: 1,
    get$$call() {
      return this;
    },
    "call*": "call$1",
    $requiredArgCount: 1,
    $defaultValues: null
  };
  A.Closure0Args.prototype = {"call*": "call$0", $requiredArgCount: 0};
  A.Closure2Args.prototype = {"call*": "call$2", $requiredArgCount: 2};
  A.TearOffClosure.prototype = {};
  A.StaticClosure.prototype = {
    toString$0(_) {
      var $name = this.$static_name;
      if ($name == null)
        return "Closure of unknown static method";
      return "Closure '" + A.unminifyOrTag($name) + "'";
    }
  };
  A.BoundClosure.prototype = {
    $eq(_, other) {
      if (other == null)
        return false;
      if (this === other)
        return true;
      if (!(other instanceof A.BoundClosure))
        return false;
      return this.$_target === other.$_target && this._receiver === other._receiver;
    },
    get$hashCode(_) {
      return (A.objectHashCode(this._receiver) ^ A.Primitives_objectHashCode(this.$_target)) >>> 0;
    },
    toString$0(_) {
      return "Closure '" + this.$_name + "' of " + ("Instance of '" + A.Primitives_objectTypeName(this._receiver) + "'");
    }
  };
  A.RuntimeError.prototype = {
    toString$0(_) {
      return "RuntimeError: " + this.message;
    }
  };
  A.JsLinkedHashMap.prototype = {
    get$length(_) {
      return this.__js_helper$_length;
    },
    get$isEmpty(_) {
      return this.__js_helper$_length === 0;
    },
    get$isNotEmpty(_) {
      return this.__js_helper$_length !== 0;
    },
    get$keys() {
      return new A.LinkedHashMapKeysIterable(this, A._instanceType(this)._eval$1("LinkedHashMapKeysIterable<1>"));
    },
    get$values() {
      return new A.LinkedHashMapValuesIterable(this, A._instanceType(this)._eval$1("LinkedHashMapValuesIterable<2>"));
    },
    containsKey$1(key) {
      var strings, nums;
      if (typeof key == "string") {
        strings = this._strings;
        if (strings == null)
          return false;
        return strings[key] != null;
      } else if (typeof key == "number" && (key & 0x3fffffff) === key) {
        nums = this._nums;
        if (nums == null)
          return false;
        return nums[key] != null;
      } else
        return this.internalContainsKey$1(key);
    },
    internalContainsKey$1(key) {
      var rest = this.__js_helper$_rest;
      if (rest == null)
        return false;
      return this.internalFindBucketIndex$2(rest[this.internalComputeHashCode$1(key)], key) >= 0;
    },
    $index(_, key) {
      var strings, cell, t1, nums, _null = null;
      if (typeof key == "string") {
        strings = this._strings;
        if (strings == null)
          return _null;
        cell = strings[key];
        t1 = cell == null ? _null : cell.hashMapCellValue;
        return t1;
      } else if (typeof key == "number" && (key & 0x3fffffff) === key) {
        nums = this._nums;
        if (nums == null)
          return _null;
        cell = nums[key];
        t1 = cell == null ? _null : cell.hashMapCellValue;
        return t1;
      } else
        return this.internalGet$1(key);
    },
    internalGet$1(key) {
      var bucket, index,
        rest = this.__js_helper$_rest;
      if (rest == null)
        return null;
      bucket = rest[this.internalComputeHashCode$1(key)];
      index = this.internalFindBucketIndex$2(bucket, key);
      if (index < 0)
        return null;
      return bucket[index].hashMapCellValue;
    },
    $indexSet(_, key, value) {
      var strings, nums, _this = this,
        t1 = A._instanceType(_this);
      t1._precomputed1._as(key);
      t1._rest[1]._as(value);
      if (typeof key == "string") {
        strings = _this._strings;
        _this._addHashTableEntry$3(strings == null ? _this._strings = _this._newHashTable$0() : strings, key, value);
      } else if (typeof key == "number" && (key & 0x3fffffff) === key) {
        nums = _this._nums;
        _this._addHashTableEntry$3(nums == null ? _this._nums = _this._newHashTable$0() : nums, key, value);
      } else
        _this.internalSet$2(key, value);
    },
    internalSet$2(key, value) {
      var rest, hash, bucket, index, _this = this,
        t1 = A._instanceType(_this);
      t1._precomputed1._as(key);
      t1._rest[1]._as(value);
      rest = _this.__js_helper$_rest;
      if (rest == null)
        rest = _this.__js_helper$_rest = _this._newHashTable$0();
      hash = _this.internalComputeHashCode$1(key);
      bucket = rest[hash];
      if (bucket == null)
        rest[hash] = [_this._newLinkedCell$2(key, value)];
      else {
        index = _this.internalFindBucketIndex$2(bucket, key);
        if (index >= 0)
          bucket[index].hashMapCellValue = value;
        else
          bucket.push(_this._newLinkedCell$2(key, value));
      }
    },
    remove$1(_, key) {
      var t1;
      if (typeof key == "string")
        return this._removeHashTableEntry$2(this._strings, key);
      else {
        t1 = this.internalRemove$1(key);
        return t1;
      }
    },
    internalRemove$1(key) {
      var hash, bucket, index, cell, _this = this,
        rest = _this.__js_helper$_rest;
      if (rest == null)
        return null;
      hash = _this.internalComputeHashCode$1(key);
      bucket = rest[hash];
      index = _this.internalFindBucketIndex$2(bucket, key);
      if (index < 0)
        return null;
      cell = bucket.splice(index, 1)[0];
      _this._unlinkCell$1(cell);
      if (bucket.length === 0)
        delete rest[hash];
      return cell.hashMapCellValue;
    },
    clear$0(_) {
      var _this = this;
      if (_this.__js_helper$_length > 0) {
        _this._strings = _this._nums = _this.__js_helper$_rest = _this._first = _this._last = null;
        _this.__js_helper$_length = 0;
        _this._modified$0();
      }
    },
    forEach$1(_, action) {
      var cell, modifications, _this = this;
      A._instanceType(_this)._eval$1("~(1,2)")._as(action);
      cell = _this._first;
      modifications = _this._modifications;
      for (; cell != null;) {
        action.call$2(cell.hashMapCellKey, cell.hashMapCellValue);
        if (modifications !== _this._modifications)
          throw A.wrapException(A.ConcurrentModificationError$(_this));
        cell = cell._next;
      }
    },
    _addHashTableEntry$3(table, key, value) {
      var cell,
        t1 = A._instanceType(this);
      t1._precomputed1._as(key);
      t1._rest[1]._as(value);
      cell = table[key];
      if (cell == null)
        table[key] = this._newLinkedCell$2(key, value);
      else
        cell.hashMapCellValue = value;
    },
    _removeHashTableEntry$2(table, key) {
      var cell;
      if (table == null)
        return null;
      cell = table[key];
      if (cell == null)
        return null;
      this._unlinkCell$1(cell);
      delete table[key];
      return cell.hashMapCellValue;
    },
    _modified$0() {
      this._modifications = this._modifications + 1 & 1073741823;
    },
    _newLinkedCell$2(key, value) {
      var _this = this,
        t1 = A._instanceType(_this),
        cell = new A.LinkedHashMapCell(t1._precomputed1._as(key), t1._rest[1]._as(value));
      if (_this._first == null)
        _this._first = _this._last = cell;
      else {
        t1 = _this._last;
        t1.toString;
        cell._previous = t1;
        _this._last = t1._next = cell;
      }
      ++_this.__js_helper$_length;
      _this._modified$0();
      return cell;
    },
    _unlinkCell$1(cell) {
      var _this = this,
        previous = cell._previous,
        next = cell._next;
      if (previous == null)
        _this._first = next;
      else
        previous._next = next;
      if (next == null)
        _this._last = previous;
      else
        next._previous = previous;
      --_this.__js_helper$_length;
      _this._modified$0();
    },
    internalComputeHashCode$1(key) {
      return J.get$hashCode$(key) & 1073741823;
    },
    internalFindBucketIndex$2(bucket, key) {
      var $length, i;
      if (bucket == null)
        return -1;
      $length = bucket.length;
      for (i = 0; i < $length; ++i)
        if (J.$eq$(bucket[i].hashMapCellKey, key))
          return i;
      return -1;
    },
    toString$0(_) {
      return A.MapBase_mapToString(this);
    },
    _newHashTable$0() {
      var table = Object.create(null);
      table["<non-identifier-key>"] = table;
      delete table["<non-identifier-key>"];
      return table;
    },
    $isLinkedHashMap: 1
  };
  A.LinkedHashMapCell.prototype = {};
  A.LinkedHashMapKeysIterable.prototype = {
    get$length(_) {
      return this._map.__js_helper$_length;
    },
    get$isEmpty(_) {
      return this._map.__js_helper$_length === 0;
    },
    get$iterator(_) {
      var t1 = this._map;
      return new A.LinkedHashMapKeyIterator(t1, t1._modifications, t1._first, this.$ti._eval$1("LinkedHashMapKeyIterator<1>"));
    },
    contains$1(_, element) {
      return this._map.containsKey$1(element);
    }
  };
  A.LinkedHashMapKeyIterator.prototype = {
    get$current() {
      return this.__js_helper$_current;
    },
    moveNext$0() {
      var cell, _this = this,
        t1 = _this._map;
      if (_this._modifications !== t1._modifications)
        throw A.wrapException(A.ConcurrentModificationError$(t1));
      cell = _this._cell;
      if (cell == null) {
        _this.__js_helper$_current = null;
        return false;
      } else {
        _this.__js_helper$_current = cell.hashMapCellKey;
        _this._cell = cell._next;
        return true;
      }
    },
    $isIterator: 1
  };
  A.LinkedHashMapValuesIterable.prototype = {
    get$length(_) {
      return this._map.__js_helper$_length;
    },
    get$isEmpty(_) {
      return this._map.__js_helper$_length === 0;
    },
    get$iterator(_) {
      var t1 = this._map;
      return new A.LinkedHashMapValueIterator(t1, t1._modifications, t1._first, this.$ti._eval$1("LinkedHashMapValueIterator<1>"));
    }
  };
  A.LinkedHashMapValueIterator.prototype = {
    get$current() {
      return this.__js_helper$_current;
    },
    moveNext$0() {
      var cell, _this = this,
        t1 = _this._map;
      if (_this._modifications !== t1._modifications)
        throw A.wrapException(A.ConcurrentModificationError$(t1));
      cell = _this._cell;
      if (cell == null) {
        _this.__js_helper$_current = null;
        return false;
      } else {
        _this.__js_helper$_current = cell.hashMapCellValue;
        _this._cell = cell._next;
        return true;
      }
    },
    $isIterator: 1
  };
  A.initHooks_closure.prototype = {
    call$1(o) {
      return this.getTag(o);
    },
    $signature: 6
  };
  A.initHooks_closure0.prototype = {
    call$2(o, tag) {
      return this.getUnknownTag(o, tag);
    },
    $signature: 81
  };
  A.initHooks_closure1.prototype = {
    call$1(tag) {
      return this.prototypeForTag(A._asString(tag));
    },
    $signature: 60
  };
  A._Record.prototype = {
    get$runtimeType(_) {
      return A.createRuntimeType(this._getRti$0());
    },
    _getRti$0() {
      return A.evaluateRtiForRecord(this.$recipe, this._getFieldValues$0());
    },
    toString$0(_) {
      return this._toString$1(false);
    },
    _toString$1(safe) {
      var t2, separator, i, key, value,
        keys = this._fieldKeys$0(),
        values = this._getFieldValues$0(),
        t1 = (safe ? "" + "Record " : "") + "(";
      for (t2 = keys.length, separator = "", i = 0; i < t2; ++i, separator = ", ") {
        t1 += separator;
        key = keys[i];
        if (typeof key == "string")
          t1 = t1 + key + ": ";
        if (!(i < values.length))
          return A.ioore(values, i);
        value = values[i];
        t1 = safe ? t1 + A.Primitives_safeToString(value) : t1 + A.S(value);
      }
      t1 += ")";
      return t1.charCodeAt(0) == 0 ? t1 : t1;
    },
    _fieldKeys$0() {
      var t1,
        shapeTag = this.$shape;
      for (; $._Record__computedFieldKeys.length <= shapeTag;)
        B.JSArray_methods.add$1($._Record__computedFieldKeys, null);
      t1 = $._Record__computedFieldKeys[shapeTag];
      if (t1 == null) {
        t1 = this._computeFieldKeys$0();
        B.JSArray_methods.$indexSet($._Record__computedFieldKeys, shapeTag, t1);
      }
      return t1;
    },
    _computeFieldKeys$0() {
      var i, names, last,
        recipe = this.$recipe,
        position = recipe.indexOf("("),
        joinedNames = recipe.substring(1, position),
        fields = recipe.substring(position),
        arity = fields === "()" ? 0 : fields.replace(/[^,]/g, "").length + 1,
        t1 = type$.Object,
        result = J.JSArray_JSArray$allocateGrowable(arity, t1);
      for (i = 0; i < arity; ++i)
        result[i] = i;
      if (joinedNames !== "") {
        names = joinedNames.split(",");
        i = names.length;
        for (last = arity; i > 0;) {
          --last;
          --i;
          B.JSArray_methods.$indexSet(result, last, names[i]);
        }
      }
      return A.List_List$unmodifiable(result, t1);
    }
  };
  A._Record2.prototype = {
    _getFieldValues$0() {
      return [this._0, this._1];
    },
    $eq(_, other) {
      if (other == null)
        return false;
      return other instanceof A._Record2 && this.$shape === other.$shape && J.$eq$(this._0, other._0) && J.$eq$(this._1, other._1);
    },
    get$hashCode(_) {
      return A.Object_hash(this.$shape, this._0, this._1, B.C_SentinelValue);
    }
  };
  A.JSSyntaxRegExp.prototype = {
    toString$0(_) {
      return "RegExp/" + this.pattern + "/" + this._nativeRegExp.flags;
    },
    firstMatch$1(string) {
      var m = this._nativeRegExp.exec(string);
      if (m == null)
        return null;
      return new A._MatchImplementation(m);
    },
    $isPattern: 1,
    $isRegExp: 1
  };
  A._MatchImplementation.prototype = {};
  A._Cell.prototype = {
    _readLocal$0() {
      var t1 = this._value;
      if (t1 === this)
        throw A.wrapException(new A.LateError("Local '" + this._name + "' has not been initialized."));
      return t1;
    },
    _readField$0() {
      var t1 = this._value;
      if (t1 === this)
        throw A.wrapException(A.LateError$fieldNI(this._name));
      return t1;
    }
  };
  A.NativeByteBuffer.prototype = {
    get$runtimeType(receiver) {
      return B.Type_ByteBuffer_rqD;
    },
    $isTrustedGetRuntimeType: 1,
    $isNativeByteBuffer: 1,
    $isByteBuffer: 1
  };
  A.NativeTypedData.prototype = {};
  A.NativeByteData.prototype = {
    get$runtimeType(receiver) {
      return B.Type_ByteData_9dB;
    },
    $isTrustedGetRuntimeType: 1,
    $isByteData: 1
  };
  A.NativeTypedArray.prototype = {
    get$length(receiver) {
      return receiver.length;
    },
    $isJavaScriptIndexingBehavior: 1
  };
  A.NativeTypedArrayOfDouble.prototype = {
    $index(receiver, index) {
      A._checkValidIndex(index, receiver, receiver.length);
      return receiver[index];
    },
    $isEfficientLengthIterable: 1,
    $isIterable: 1,
    $isList: 1
  };
  A.NativeTypedArrayOfInt.prototype = {$isEfficientLengthIterable: 1, $isIterable: 1, $isList: 1};
  A.NativeFloat32List.prototype = {
    get$runtimeType(receiver) {
      return B.Type_Float32List_9Kz;
    },
    $isTrustedGetRuntimeType: 1,
    $isFloat32List: 1
  };
  A.NativeFloat64List.prototype = {
    get$runtimeType(receiver) {
      return B.Type_Float64List_9Kz;
    },
    $isTrustedGetRuntimeType: 1,
    $isFloat64List: 1
  };
  A.NativeInt16List.prototype = {
    get$runtimeType(receiver) {
      return B.Type_Int16List_s5h;
    },
    $index(receiver, index) {
      A._checkValidIndex(index, receiver, receiver.length);
      return receiver[index];
    },
    $isTrustedGetRuntimeType: 1,
    $isInt16List: 1
  };
  A.NativeInt32List.prototype = {
    get$runtimeType(receiver) {
      return B.Type_Int32List_O8Z;
    },
    $index(receiver, index) {
      A._checkValidIndex(index, receiver, receiver.length);
      return receiver[index];
    },
    $isTrustedGetRuntimeType: 1,
    $isInt32List: 1
  };
  A.NativeInt8List.prototype = {
    get$runtimeType(receiver) {
      return B.Type_Int8List_rFV;
    },
    $index(receiver, index) {
      A._checkValidIndex(index, receiver, receiver.length);
      return receiver[index];
    },
    $isTrustedGetRuntimeType: 1,
    $isInt8List: 1
  };
  A.NativeUint16List.prototype = {
    get$runtimeType(receiver) {
      return B.Type_Uint16List_kmP;
    },
    $index(receiver, index) {
      A._checkValidIndex(index, receiver, receiver.length);
      return receiver[index];
    },
    $isTrustedGetRuntimeType: 1,
    $isUint16List: 1
  };
  A.NativeUint32List.prototype = {
    get$runtimeType(receiver) {
      return B.Type_Uint32List_kmP;
    },
    $index(receiver, index) {
      A._checkValidIndex(index, receiver, receiver.length);
      return receiver[index];
    },
    $isTrustedGetRuntimeType: 1,
    $isUint32List: 1
  };
  A.NativeUint8ClampedList.prototype = {
    get$runtimeType(receiver) {
      return B.Type_Uint8ClampedList_04U;
    },
    get$length(receiver) {
      return receiver.length;
    },
    $index(receiver, index) {
      A._checkValidIndex(index, receiver, receiver.length);
      return receiver[index];
    },
    $isTrustedGetRuntimeType: 1,
    $isUint8ClampedList: 1
  };
  A.NativeUint8List.prototype = {
    get$runtimeType(receiver) {
      return B.Type_Uint8List_8Eb;
    },
    get$length(receiver) {
      return receiver.length;
    },
    $index(receiver, index) {
      A._checkValidIndex(index, receiver, receiver.length);
      return receiver[index];
    },
    $isTrustedGetRuntimeType: 1,
    $isNativeUint8List: 1,
    $isUint8List: 1
  };
  A._NativeTypedArrayOfDouble_NativeTypedArray_ListMixin.prototype = {};
  A._NativeTypedArrayOfDouble_NativeTypedArray_ListMixin_FixedLengthListMixin.prototype = {};
  A._NativeTypedArrayOfInt_NativeTypedArray_ListMixin.prototype = {};
  A._NativeTypedArrayOfInt_NativeTypedArray_ListMixin_FixedLengthListMixin.prototype = {};
  A.Rti.prototype = {
    _eval$1(recipe) {
      return A._Universe_evalInEnvironment(init.typeUniverse, this, recipe);
    },
    _bind$1(typeOrTuple) {
      return A._Universe_bind(init.typeUniverse, this, typeOrTuple);
    }
  };
  A._FunctionParameters.prototype = {};
  A._Type.prototype = {
    toString$0(_) {
      return A._rtiToString(this._rti, null);
    }
  };
  A._Error.prototype = {
    toString$0(_) {
      return this._message;
    }
  };
  A._TypeError.prototype = {$isTypeError: 1};
  A._AsyncRun__initializeScheduleImmediate_internalCallback.prototype = {
    call$1(__wc0_formal) {
      var t1 = this._box_0,
        f = t1.storedCallback;
      t1.storedCallback = null;
      f.call$0();
    },
    $signature: 7
  };
  A._AsyncRun__initializeScheduleImmediate_closure.prototype = {
    call$1(callback) {
      var t1, t2;
      this._box_0.storedCallback = type$.void_Function._as(callback);
      t1 = this.div;
      t2 = this.span;
      t1.firstChild ? t1.removeChild(t2) : t1.appendChild(t2);
    },
    $signature: 53
  };
  A._AsyncRun__scheduleImmediateJsOverride_internalCallback.prototype = {
    call$0() {
      this.callback.call$0();
    },
    $signature: 8
  };
  A._AsyncRun__scheduleImmediateWithSetImmediate_internalCallback.prototype = {
    call$0() {
      this.callback.call$0();
    },
    $signature: 8
  };
  A._TimerImpl.prototype = {
    _TimerImpl$2(milliseconds, callback) {
      if (self.setTimeout != null)
        this._handle = self.setTimeout(A.convertDartClosureToJS(new A._TimerImpl_internalCallback(this, callback), 0), milliseconds);
      else
        throw A.wrapException(A.UnsupportedError$("`setTimeout()` not found."));
    }
  };
  A._TimerImpl_internalCallback.prototype = {
    call$0() {
      var t1 = this.$this;
      t1._handle = null;
      t1._tick = 1;
      this.callback.call$0();
    },
    $signature: 0
  };
  A._AsyncAwaitCompleter.prototype = {
    complete$1(value) {
      var t2, _this = this,
        t1 = _this.$ti;
      t1._eval$1("1/?")._as(value);
      if (value == null)
        value = t1._precomputed1._as(value);
      if (!_this.isSync)
        _this._future._asyncComplete$1(value);
      else {
        t2 = _this._future;
        if (t1._eval$1("Future<1>")._is(value))
          t2._chainFuture$1(value);
        else
          t2._completeWithValue$1(value);
      }
    },
    completeError$2(e, st) {
      var t1;
      type$.nullable_StackTrace._as(st);
      if (st == null)
        st = A.AsyncError_defaultStackTrace(e);
      t1 = this._future;
      if (this.isSync)
        t1._completeErrorObject$1(new A.AsyncError(e, st));
      else
        t1._asyncCompleteErrorObject$1(new A.AsyncError(e, st));
    },
    get$future() {
      return this._future;
    },
    $isCompleter: 1
  };
  A._awaitOnObject_closure.prototype = {
    call$1(result) {
      return this.bodyFunction.call$2(0, result);
    },
    $signature: 31
  };
  A._awaitOnObject_closure0.prototype = {
    call$2(error, stackTrace) {
      this.bodyFunction.call$2(1, new A.ExceptionAndStackTrace(error, type$.StackTrace._as(stackTrace)));
    },
    $signature: 33
  };
  A._wrapJsFunctionForAsync_closure.prototype = {
    call$2(errorCode, result) {
      this.$protected(A._asInt(errorCode), result);
    },
    $signature: 34
  };
  A.AsyncError.prototype = {
    toString$0(_) {
      return A.S(this.error);
    },
    $isError: 1,
    get$stackTrace() {
      return this.stackTrace;
    }
  };
  A.Future_Future$delayed_closure.prototype = {
    call$0() {
      var computationResult, e, s, exception, t2, t3, _this = this,
        t1 = _this.computation;
      if (t1 == null) {
        _this.T._as(null);
        _this.result._complete$1(null);
      } else {
        computationResult = null;
        try {
          computationResult = t1.call$0();
        } catch (exception) {
          e = A.unwrapException(exception);
          s = A.getTraceFromException(exception);
          t1 = e;
          t2 = s;
          t3 = A._interceptError(t1, t2);
          if (t3 == null)
            t1 = new A.AsyncError(t1, t2);
          else
            t1 = t3;
          _this.result._completeErrorObject$1(t1);
          return;
        }
        _this.result._complete$1(computationResult);
      }
    },
    $signature: 0
  };
  A.Future_wait_handleError.prototype = {
    call$2(theError, theStackTrace) {
      var t1, t2, _this = this;
      type$.Object._as(theError);
      type$.StackTrace._as(theStackTrace);
      t1 = _this._box_0;
      t2 = --t1.remaining;
      if (t1.values != null) {
        t1.values = null;
        t1.error = theError;
        t1.stackTrace = theStackTrace;
        if (t2 === 0 || _this.eagerError)
          _this._future._completeErrorObject$1(new A.AsyncError(theError, theStackTrace));
      } else if (t2 === 0 && !_this.eagerError) {
        t2 = t1.error;
        t2.toString;
        t1 = t1.stackTrace;
        t1.toString;
        _this._future._completeErrorObject$1(new A.AsyncError(t2, t1));
      }
    },
    $signature: 9
  };
  A.Future_wait_closure.prototype = {
    call$1(value) {
      var remainingResults, valueList, t1, value0, t3, t4, _i, t5, _this = this,
        t2 = _this.T;
      t2._as(value);
      t3 = _this._box_0;
      remainingResults = --t3.remaining;
      valueList = t3.values;
      if (valueList != null) {
        J.$indexSet$ax(valueList, _this.pos, value);
        if (J.$eq$(remainingResults, 0)) {
          t1 = A._setArrayType([], t2._eval$1("JSArray<0>"));
          for (t3 = valueList, t4 = t3.length, _i = 0; _i < t3.length; t3.length === t4 || (0, A.throwConcurrentModificationError)(t3), ++_i) {
            value0 = t3[_i];
            t5 = value0;
            if (t5 == null)
              t5 = t2._as(t5);
            J.add$1$ax(t1, t5);
          }
          _this._future._completeWithValue$1(t1);
        }
      } else if (J.$eq$(remainingResults, 0) && !_this.eagerError) {
        t1 = t3.error;
        t1.toString;
        t3 = t3.stackTrace;
        t3.toString;
        _this._future._completeErrorObject$1(new A.AsyncError(t1, t3));
      }
    },
    $signature() {
      return this.T._eval$1("Null(0)");
    }
  };
  A._Completer.prototype = {
    completeError$2(error, stackTrace) {
      type$.nullable_StackTrace._as(stackTrace);
      if ((this.future._state & 30) !== 0)
        throw A.wrapException(A.StateError$("Future already completed"));
      this._completeErrorObject$1(A._interceptUserError(error, stackTrace));
    },
    completeError$1(error) {
      return this.completeError$2(error, null);
    },
    $isCompleter: 1,
    get$future() {
      return this.future;
    }
  };
  A._AsyncCompleter.prototype = {
    complete$1(value) {
      var t2,
        t1 = this.$ti;
      t1._eval$1("1/?")._as(value);
      t2 = this.future;
      if ((t2._state & 30) !== 0)
        throw A.wrapException(A.StateError$("Future already completed"));
      t2._asyncComplete$1(t1._eval$1("1/")._as(value));
    },
    complete$0() {
      return this.complete$1(null);
    },
    _completeErrorObject$1(error) {
      this.future._asyncCompleteErrorObject$1(error);
    }
  };
  A._SyncCompleter.prototype = {
    complete$1(value) {
      var t2,
        t1 = this.$ti;
      t1._eval$1("1/?")._as(value);
      t2 = this.future;
      if ((t2._state & 30) !== 0)
        throw A.wrapException(A.StateError$("Future already completed"));
      t2._complete$1(t1._eval$1("1/")._as(value));
    },
    complete$0() {
      return this.complete$1(null);
    },
    _completeErrorObject$1(error) {
      this.future._completeErrorObject$1(error);
    }
  };
  A._FutureListener.prototype = {
    matchesErrorTest$1(asyncError) {
      if ((this.state & 15) !== 6)
        return true;
      return this.result._zone.runUnary$2$2(type$.bool_Function_Object._as(this.callback), asyncError.error, type$.bool, type$.Object);
    },
    handleError$1(asyncError) {
      var exception, _this = this,
        errorCallback = _this.errorCallback,
        result = null,
        t1 = type$.dynamic,
        t2 = type$.Object,
        t3 = asyncError.error,
        t4 = _this.result._zone;
      if (type$.dynamic_Function_Object_StackTrace._is(errorCallback))
        result = t4.runBinary$3$3(errorCallback, t3, asyncError.stackTrace, t1, t2, type$.StackTrace);
      else
        result = t4.runUnary$2$2(type$.dynamic_Function_Object._as(errorCallback), t3, t1, t2);
      try {
        t1 = _this.$ti._eval$1("2/")._as(result);
        return t1;
      } catch (exception) {
        if (type$.TypeError._is(A.unwrapException(exception))) {
          if ((_this.state & 1) !== 0)
            throw A.wrapException(A.ArgumentError$("The error handler of Future.then must return a value of the returned future's type", "onError"));
          throw A.wrapException(A.ArgumentError$("The error handler of Future.catchError must return a value of the future's type", "onError"));
        } else
          throw exception;
      }
    }
  };
  A._Future.prototype = {
    then$1$2$onError(f, onError, $R) {
      var currentZone, result, t2,
        t1 = this.$ti;
      t1._bind$1($R)._eval$1("1/(2)")._as(f);
      currentZone = $.Zone__current;
      if (currentZone === B.C__RootZone) {
        if (onError != null && !type$.dynamic_Function_Object_StackTrace._is(onError) && !type$.dynamic_Function_Object._is(onError))
          throw A.wrapException(A.ArgumentError$value(onError, "onError", string$.Error_));
      } else {
        f = currentZone.registerUnaryCallback$2$1(f, $R._eval$1("0/"), t1._precomputed1);
        if (onError != null)
          onError = A._registerErrorHandler(onError, currentZone);
      }
      result = new A._Future($.Zone__current, $R._eval$1("_Future<0>"));
      t2 = onError == null ? 1 : 3;
      this._addListener$1(new A._FutureListener(result, t2, f, onError, t1._eval$1("@<1>")._bind$1($R)._eval$1("_FutureListener<1,2>")));
      return result;
    },
    then$1$1(f, $R) {
      f.toString;
      return this.then$1$2$onError(f, null, $R);
    },
    _thenAwait$1$2(f, onError, $E) {
      var result,
        t1 = this.$ti;
      t1._bind$1($E)._eval$1("1/(2)")._as(f);
      result = new A._Future($.Zone__current, $E._eval$1("_Future<0>"));
      this._addListener$1(new A._FutureListener(result, 19, f, onError, t1._eval$1("@<1>")._bind$1($E)._eval$1("_FutureListener<1,2>")));
      return result;
    },
    catchError$1(onError) {
      var t1 = this.$ti,
        t2 = $.Zone__current,
        result = new A._Future(t2, t1);
      if (t2 !== B.C__RootZone)
        onError = A._registerErrorHandler(onError, t2);
      this._addListener$1(new A._FutureListener(result, 2, null, onError, t1._eval$1("_FutureListener<1,1>")));
      return result;
    },
    whenComplete$1(action) {
      var t1, t2, result;
      type$.dynamic_Function._as(action);
      t1 = this.$ti;
      t2 = $.Zone__current;
      result = new A._Future(t2, t1);
      if (t2 !== B.C__RootZone)
        action = t2.registerCallback$1$1(action, type$.dynamic);
      this._addListener$1(new A._FutureListener(result, 8, action, null, t1._eval$1("_FutureListener<1,1>")));
      return result;
    },
    _setErrorObject$1(error) {
      this._state = this._state & 1 | 16;
      this._resultOrListeners = error;
    },
    _cloneResult$1(source) {
      this._state = source._state & 30 | this._state & 1;
      this._resultOrListeners = source._resultOrListeners;
    },
    _addListener$1(listener) {
      var source, _this = this,
        t1 = _this._state;
      if (t1 <= 3) {
        listener._nextListener = type$.nullable__FutureListener_dynamic_dynamic._as(_this._resultOrListeners);
        _this._resultOrListeners = listener;
      } else {
        if ((t1 & 4) !== 0) {
          source = type$._Future_dynamic._as(_this._resultOrListeners);
          if ((source._state & 24) === 0) {
            source._addListener$1(listener);
            return;
          }
          _this._cloneResult$1(source);
        }
        _this._zone.scheduleMicrotask$1(new A._Future__addListener_closure(_this, listener));
      }
    },
    _prependListeners$1(listeners) {
      var t1, existingListeners, next, cursor, next0, source, _this = this, _box_0 = {};
      _box_0.listeners = listeners;
      if (listeners == null)
        return;
      t1 = _this._state;
      if (t1 <= 3) {
        existingListeners = type$.nullable__FutureListener_dynamic_dynamic._as(_this._resultOrListeners);
        _this._resultOrListeners = listeners;
        if (existingListeners != null) {
          next = listeners._nextListener;
          for (cursor = listeners; next != null; cursor = next, next = next0)
            next0 = next._nextListener;
          cursor._nextListener = existingListeners;
        }
      } else {
        if ((t1 & 4) !== 0) {
          source = type$._Future_dynamic._as(_this._resultOrListeners);
          if ((source._state & 24) === 0) {
            source._prependListeners$1(listeners);
            return;
          }
          _this._cloneResult$1(source);
        }
        _box_0.listeners = _this._reverseListeners$1(listeners);
        _this._zone.scheduleMicrotask$1(new A._Future__prependListeners_closure(_box_0, _this));
      }
    },
    _removeListeners$0() {
      var current = type$.nullable__FutureListener_dynamic_dynamic._as(this._resultOrListeners);
      this._resultOrListeners = null;
      return this._reverseListeners$1(current);
    },
    _reverseListeners$1(listeners) {
      var current, prev, next;
      for (current = listeners, prev = null; current != null; prev = current, current = next) {
        next = current._nextListener;
        current._nextListener = prev;
      }
      return prev;
    },
    _complete$1(value) {
      var listeners, _this = this,
        t1 = _this.$ti;
      t1._eval$1("1/")._as(value);
      if (t1._eval$1("Future<1>")._is(value))
        A._Future__chainCoreFuture(value, _this, true);
      else {
        listeners = _this._removeListeners$0();
        t1._precomputed1._as(value);
        _this._state = 8;
        _this._resultOrListeners = value;
        A._Future__propagateToListeners(_this, listeners);
      }
    },
    _completeWithValue$1(value) {
      var listeners, _this = this;
      _this.$ti._precomputed1._as(value);
      listeners = _this._removeListeners$0();
      _this._state = 8;
      _this._resultOrListeners = value;
      A._Future__propagateToListeners(_this, listeners);
    },
    _completeWithResultOf$1(source) {
      var t1, t2, listeners, _this = this;
      if ((source._state & 16) !== 0) {
        t1 = _this._zone;
        t2 = source._zone;
        t1 = !(t1 === t2 || t1.get$errorZone() === t2.get$errorZone());
      } else
        t1 = false;
      if (t1)
        return;
      listeners = _this._removeListeners$0();
      _this._cloneResult$1(source);
      A._Future__propagateToListeners(_this, listeners);
    },
    _completeErrorObject$1(error) {
      var listeners = this._removeListeners$0();
      this._setErrorObject$1(error);
      A._Future__propagateToListeners(this, listeners);
    },
    _completeError$2(error, stackTrace) {
      type$.Object._as(error);
      type$.StackTrace._as(stackTrace);
      this._completeErrorObject$1(new A.AsyncError(error, stackTrace));
    },
    _asyncComplete$1(value) {
      var t1 = this.$ti;
      t1._eval$1("1/")._as(value);
      if (t1._eval$1("Future<1>")._is(value)) {
        this._chainFuture$1(value);
        return;
      }
      this._asyncCompleteWithValue$1(value);
    },
    _asyncCompleteWithValue$1(value) {
      var _this = this;
      _this.$ti._precomputed1._as(value);
      _this._state ^= 2;
      _this._zone.scheduleMicrotask$1(new A._Future__asyncCompleteWithValue_closure(_this, value));
    },
    _chainFuture$1(value) {
      A._Future__chainCoreFuture(this.$ti._eval$1("Future<1>")._as(value), this, false);
      return;
    },
    _asyncCompleteErrorObject$1(error) {
      this._state ^= 2;
      this._zone.scheduleMicrotask$1(new A._Future__asyncCompleteErrorObject_closure(this, error));
    },
    $isFuture: 1
  };
  A._Future__addListener_closure.prototype = {
    call$0() {
      A._Future__propagateToListeners(this.$this, this.listener);
    },
    $signature: 0
  };
  A._Future__prependListeners_closure.prototype = {
    call$0() {
      A._Future__propagateToListeners(this.$this, this._box_0.listeners);
    },
    $signature: 0
  };
  A._Future__chainCoreFuture_closure.prototype = {
    call$0() {
      A._Future__chainCoreFuture(this._box_0.source, this.target, true);
    },
    $signature: 0
  };
  A._Future__asyncCompleteWithValue_closure.prototype = {
    call$0() {
      this.$this._completeWithValue$1(this.value);
    },
    $signature: 0
  };
  A._Future__asyncCompleteErrorObject_closure.prototype = {
    call$0() {
      this.$this._completeErrorObject$1(this.error);
    },
    $signature: 0
  };
  A._Future__propagateToListeners_handleWhenCompleteCallback.prototype = {
    call$0() {
      var e, s, t1, exception, t2, t3, originalSource, joinedResult, _this = this, completeResult = null;
      try {
        t1 = _this._box_0.listener;
        completeResult = t1.result._zone.run$1$1(type$.dynamic_Function._as(t1.callback), type$.dynamic);
      } catch (exception) {
        e = A.unwrapException(exception);
        s = A.getTraceFromException(exception);
        if (_this.hasError && type$.AsyncError._as(_this._box_1.source._resultOrListeners).error === e) {
          t1 = _this._box_0;
          t1.listenerValueOrError = type$.AsyncError._as(_this._box_1.source._resultOrListeners);
        } else {
          t1 = e;
          t2 = s;
          if (t2 == null)
            t2 = A.AsyncError_defaultStackTrace(t1);
          t3 = _this._box_0;
          t3.listenerValueOrError = new A.AsyncError(t1, t2);
          t1 = t3;
        }
        t1.listenerHasError = true;
        return;
      }
      if (completeResult instanceof A._Future && (completeResult._state & 24) !== 0) {
        if ((completeResult._state & 16) !== 0) {
          t1 = _this._box_0;
          t1.listenerValueOrError = type$.AsyncError._as(completeResult._resultOrListeners);
          t1.listenerHasError = true;
        }
        return;
      }
      if (completeResult instanceof A._Future) {
        originalSource = _this._box_1.source;
        joinedResult = new A._Future(originalSource._zone, originalSource.$ti);
        completeResult.then$1$2$onError(new A._Future__propagateToListeners_handleWhenCompleteCallback_closure(joinedResult, originalSource), new A._Future__propagateToListeners_handleWhenCompleteCallback_closure0(joinedResult), type$.void);
        t1 = _this._box_0;
        t1.listenerValueOrError = joinedResult;
        t1.listenerHasError = false;
      }
    },
    $signature: 0
  };
  A._Future__propagateToListeners_handleWhenCompleteCallback_closure.prototype = {
    call$1(__wc0_formal) {
      this.joinedResult._completeWithResultOf$1(this.originalSource);
    },
    $signature: 7
  };
  A._Future__propagateToListeners_handleWhenCompleteCallback_closure0.prototype = {
    call$2(e, s) {
      type$.Object._as(e);
      type$.StackTrace._as(s);
      this.joinedResult._completeErrorObject$1(new A.AsyncError(e, s));
    },
    $signature: 16
  };
  A._Future__propagateToListeners_handleValueCallback.prototype = {
    call$0() {
      var e, s, t1, t2, t3, t4, t5, exception;
      try {
        t1 = this._box_0;
        t2 = t1.listener;
        t3 = t2.$ti;
        t4 = t3._precomputed1;
        t5 = t4._as(this.sourceResult);
        t1.listenerValueOrError = t2.result._zone.runUnary$2$2(t3._eval$1("2/(1)")._as(t2.callback), t5, t3._eval$1("2/"), t4);
      } catch (exception) {
        e = A.unwrapException(exception);
        s = A.getTraceFromException(exception);
        t1 = e;
        t2 = s;
        if (t2 == null)
          t2 = A.AsyncError_defaultStackTrace(t1);
        t3 = this._box_0;
        t3.listenerValueOrError = new A.AsyncError(t1, t2);
        t3.listenerHasError = true;
      }
    },
    $signature: 0
  };
  A._Future__propagateToListeners_handleError.prototype = {
    call$0() {
      var asyncError, e, s, t1, exception, t2, t3, _this = this;
      try {
        asyncError = type$.AsyncError._as(_this._box_1.source._resultOrListeners);
        t1 = _this._box_0;
        if (t1.listener.matchesErrorTest$1(asyncError) && t1.listener.errorCallback != null) {
          t1.listenerValueOrError = t1.listener.handleError$1(asyncError);
          t1.listenerHasError = false;
        }
      } catch (exception) {
        e = A.unwrapException(exception);
        s = A.getTraceFromException(exception);
        t1 = type$.AsyncError._as(_this._box_1.source._resultOrListeners);
        if (t1.error === e) {
          t2 = _this._box_0;
          t2.listenerValueOrError = t1;
          t1 = t2;
        } else {
          t1 = e;
          t2 = s;
          if (t2 == null)
            t2 = A.AsyncError_defaultStackTrace(t1);
          t3 = _this._box_0;
          t3.listenerValueOrError = new A.AsyncError(t1, t2);
          t1 = t3;
        }
        t1.listenerHasError = true;
      }
    },
    $signature: 0
  };
  A._AsyncCallbackEntry.prototype = {};
  A.Stream.prototype = {
    get$length(_) {
      var t1 = {},
        future = new A._Future($.Zone__current, type$._Future_int);
      t1.count = 0;
      this.listen$4$cancelOnError$onDone$onError(new A.Stream_length_closure(t1, this), true, new A.Stream_length_closure0(t1, future), future.get$_completeError());
      return future;
    }
  };
  A.Stream_length_closure.prototype = {
    call$1(__wc0_formal) {
      A._instanceType(this.$this)._precomputed1._as(__wc0_formal);
      ++this._box_0.count;
    },
    $signature() {
      return A._instanceType(this.$this)._eval$1("~(1)");
    }
  };
  A.Stream_length_closure0.prototype = {
    call$0() {
      this.future._complete$1(this._box_0.count);
    },
    $signature: 0
  };
  A._StreamController.prototype = {
    get$_pendingEvents() {
      var t1, _this = this;
      if ((_this._state & 8) === 0)
        return A._instanceType(_this)._eval$1("_PendingEvents<1>?")._as(_this._varData);
      t1 = A._instanceType(_this);
      return t1._eval$1("_PendingEvents<1>?")._as(t1._eval$1("_StreamControllerAddStreamState<1>")._as(_this._varData).get$_varData());
    },
    _ensurePendingEvents$0() {
      var events, t1, _this = this;
      if ((_this._state & 8) === 0) {
        events = _this._varData;
        if (events == null)
          events = _this._varData = new A._PendingEvents(A._instanceType(_this)._eval$1("_PendingEvents<1>"));
        return A._instanceType(_this)._eval$1("_PendingEvents<1>")._as(events);
      }
      t1 = A._instanceType(_this);
      events = t1._eval$1("_StreamControllerAddStreamState<1>")._as(_this._varData).get$_varData();
      return t1._eval$1("_PendingEvents<1>")._as(events);
    },
    get$_subscription() {
      var varData = this._varData;
      if ((this._state & 8) !== 0)
        varData = type$._StreamControllerAddStreamState_nullable_Object._as(varData).get$_varData();
      return A._instanceType(this)._eval$1("_ControllerSubscription<1>")._as(varData);
    },
    _badEventState$0() {
      if ((this._state & 4) !== 0)
        return new A.StateError("Cannot add event after closing");
      return new A.StateError("Cannot add event while adding a stream");
    },
    _ensureDoneFuture$0() {
      var t1 = this._doneFuture;
      if (t1 == null)
        t1 = this._doneFuture = (this._state & 2) !== 0 ? $.$get$Future__nullFuture() : new A._Future($.Zone__current, type$._Future_void);
      return t1;
    },
    add$1(_, value) {
      var t2, _this = this,
        t1 = A._instanceType(_this);
      t1._precomputed1._as(value);
      t2 = _this._state;
      if (t2 >= 4)
        throw A.wrapException(_this._badEventState$0());
      if ((t2 & 1) !== 0)
        _this._sendData$1(value);
      else if ((t2 & 3) === 0)
        _this._ensurePendingEvents$0().add$1(0, new A._DelayedData(value, t1._eval$1("_DelayedData<1>")));
    },
    close$0() {
      var _this = this,
        t1 = _this._state;
      if ((t1 & 4) !== 0)
        return _this._ensureDoneFuture$0();
      if (t1 >= 4)
        throw A.wrapException(_this._badEventState$0());
      t1 = _this._state = t1 | 4;
      if ((t1 & 1) !== 0)
        _this._sendDone$0();
      else if ((t1 & 3) === 0)
        _this._ensurePendingEvents$0().add$1(0, B.C__DelayedDone);
      return _this._ensureDoneFuture$0();
    },
    _subscribe$4(onData, onError, onDone, cancelOnError) {
      var t2, t3, t4, t5, t6, subscription, pendingEvents, addState, _this = this,
        t1 = A._instanceType(_this);
      t1._eval$1("~(1)?")._as(onData);
      type$.nullable_void_Function._as(onDone);
      if ((_this._state & 3) !== 0)
        throw A.wrapException(A.StateError$("Stream has already been listened to."));
      t2 = $.Zone__current;
      t3 = cancelOnError ? 1 : 0;
      t4 = type$.void;
      t5 = t2.registerUnaryCallback$2$1(onData, t4, t1._precomputed1);
      t6 = A._BufferingStreamSubscription__registerErrorHandler(t2, onError);
      subscription = new A._ControllerSubscription(_this, t5, t6, t2.registerCallback$1$1(onDone, t4), t2, t3 | 32, t1._eval$1("_ControllerSubscription<1>"));
      pendingEvents = _this.get$_pendingEvents();
      if (((_this._state |= 1) & 8) !== 0) {
        addState = t1._eval$1("_StreamControllerAddStreamState<1>")._as(_this._varData);
        addState.set$_varData(subscription);
        addState.resume$0();
      } else
        _this._varData = subscription;
      subscription._setPendingEvents$1(pendingEvents);
      subscription._guardCallback$1(new A._StreamController__subscribe_closure(_this));
      return subscription;
    },
    _recordCancel$1(subscription) {
      var result, onCancel, cancelResult, e, s, exception, result0, t2, _this = this,
        t1 = A._instanceType(_this);
      t1._eval$1("StreamSubscription<1>")._as(subscription);
      result = null;
      if ((_this._state & 8) !== 0)
        result = t1._eval$1("_StreamControllerAddStreamState<1>")._as(_this._varData).cancel$0();
      _this._varData = null;
      _this._state = _this._state & 4294967286 | 2;
      onCancel = _this.onCancel;
      if (onCancel != null)
        if (result == null)
          try {
            cancelResult = onCancel.call$0();
            if (cancelResult instanceof A._Future)
              result = cancelResult;
          } catch (exception) {
            e = A.unwrapException(exception);
            s = A.getTraceFromException(exception);
            result0 = new A._Future($.Zone__current, type$._Future_void);
            t1 = type$.Object._as(e);
            t2 = type$.StackTrace._as(s);
            result0._asyncCompleteErrorObject$1(new A.AsyncError(t1, t2));
            result = result0;
          }
        else
          result = result.whenComplete$1(onCancel);
      t1 = new A._StreamController__recordCancel_complete(_this);
      if (result != null)
        result = result.whenComplete$1(t1);
      else
        t1.call$0();
      return result;
    },
    $isStreamController: 1,
    $is_StreamControllerLifecycle: 1,
    $is_EventDispatch: 1
  };
  A._StreamController__subscribe_closure.prototype = {
    call$0() {
      A._runGuarded(this.$this.onListen);
    },
    $signature: 0
  };
  A._StreamController__recordCancel_complete.prototype = {
    call$0() {
      var doneFuture = this.$this._doneFuture;
      if (doneFuture != null && (doneFuture._state & 30) === 0)
        doneFuture._asyncComplete$1(null);
    },
    $signature: 0
  };
  A._SyncStreamControllerDispatch.prototype = {
    _sendData$1(data) {
      this.$ti._precomputed1._as(data);
      this.get$_subscription()._add$1(data);
    },
    _sendError$2(error, stackTrace) {
      this.get$_subscription()._addError$2(error, stackTrace);
    },
    _sendDone$0() {
      this.get$_subscription()._close$0();
    }
  };
  A._SyncStreamController.prototype = {};
  A._ControllerStream.prototype = {
    get$hashCode(_) {
      return (A.Primitives_objectHashCode(this._controller) ^ 892482866) >>> 0;
    },
    $eq(_, other) {
      if (other == null)
        return false;
      if (this === other)
        return true;
      return other instanceof A._ControllerStream && other._controller === this._controller;
    }
  };
  A._ControllerSubscription.prototype = {
    _onCancel$0() {
      return this._controller._recordCancel$1(this);
    },
    _onPause$0() {
      var t1 = this._controller,
        t2 = A._instanceType(t1);
      t2._eval$1("StreamSubscription<1>")._as(this);
      if ((t1._state & 8) !== 0)
        t2._eval$1("_StreamControllerAddStreamState<1>")._as(t1._varData).pause$0();
      A._runGuarded(t1.onPause);
    },
    _onResume$0() {
      var t1 = this._controller,
        t2 = A._instanceType(t1);
      t2._eval$1("StreamSubscription<1>")._as(this);
      if ((t1._state & 8) !== 0)
        t2._eval$1("_StreamControllerAddStreamState<1>")._as(t1._varData).resume$0();
      A._runGuarded(t1.onResume);
    }
  };
  A._BufferingStreamSubscription.prototype = {
    _setPendingEvents$1(pendingEvents) {
      var _this = this;
      A._instanceType(_this)._eval$1("_PendingEvents<1>?")._as(pendingEvents);
      if (pendingEvents == null)
        return;
      _this._pending = pendingEvents;
      if (pendingEvents.lastPendingEvent != null) {
        _this._state = (_this._state | 128) >>> 0;
        pendingEvents.schedule$1(_this);
      }
    },
    pause$0() {
      var t2, t3, _this = this,
        t1 = _this._state;
      if ((t1 & 8) !== 0)
        return;
      t2 = (t1 + 256 | 4) >>> 0;
      _this._state = t2;
      if (t1 < 256) {
        t3 = _this._pending;
        if (t3 != null)
          if (t3._state === 1)
            t3._state = 3;
      }
      if ((t1 & 4) === 0 && (t2 & 64) === 0)
        _this._guardCallback$1(_this.get$_onPause());
    },
    resume$0() {
      var _this = this,
        t1 = _this._state;
      if ((t1 & 8) !== 0)
        return;
      if (t1 >= 256) {
        t1 = _this._state = t1 - 256;
        if (t1 < 256)
          if ((t1 & 128) !== 0 && _this._pending.lastPendingEvent != null)
            _this._pending.schedule$1(_this);
          else {
            t1 = (t1 & 4294967291) >>> 0;
            _this._state = t1;
            if ((t1 & 64) === 0)
              _this._guardCallback$1(_this.get$_onResume());
          }
      }
    },
    cancel$0() {
      var _this = this,
        t1 = (_this._state & 4294967279) >>> 0;
      _this._state = t1;
      if ((t1 & 8) === 0)
        _this._cancel$0();
      t1 = _this._cancelFuture;
      return t1 == null ? $.$get$Future__nullFuture() : t1;
    },
    _cancel$0() {
      var t2, _this = this,
        t1 = _this._state = (_this._state | 8) >>> 0;
      if ((t1 & 128) !== 0) {
        t2 = _this._pending;
        if (t2._state === 1)
          t2._state = 3;
      }
      if ((t1 & 64) === 0)
        _this._pending = null;
      _this._cancelFuture = _this._onCancel$0();
    },
    _add$1(data) {
      var t2, _this = this,
        t1 = A._instanceType(_this);
      t1._precomputed1._as(data);
      t2 = _this._state;
      if ((t2 & 8) !== 0)
        return;
      if (t2 < 64)
        _this._sendData$1(data);
      else
        _this._addPending$1(new A._DelayedData(data, t1._eval$1("_DelayedData<1>")));
    },
    _addError$2(error, stackTrace) {
      var t1;
      if (type$.Error._is(error))
        A.Primitives_trySetStackTrace(error, stackTrace);
      t1 = this._state;
      if ((t1 & 8) !== 0)
        return;
      if (t1 < 64)
        this._sendError$2(error, stackTrace);
      else
        this._addPending$1(new A._DelayedError(error, stackTrace));
    },
    _close$0() {
      var _this = this,
        t1 = _this._state;
      if ((t1 & 8) !== 0)
        return;
      t1 = (t1 | 2) >>> 0;
      _this._state = t1;
      if (t1 < 64)
        _this._sendDone$0();
      else
        _this._addPending$1(B.C__DelayedDone);
    },
    _onPause$0() {
    },
    _onResume$0() {
    },
    _onCancel$0() {
      return null;
    },
    _addPending$1($event) {
      var t1, _this = this,
        pending = _this._pending;
      if (pending == null)
        pending = _this._pending = new A._PendingEvents(A._instanceType(_this)._eval$1("_PendingEvents<1>"));
      pending.add$1(0, $event);
      t1 = _this._state;
      if ((t1 & 128) === 0) {
        t1 = (t1 | 128) >>> 0;
        _this._state = t1;
        if (t1 < 256)
          pending.schedule$1(_this);
      }
    },
    _sendData$1(data) {
      var t2, _this = this,
        t1 = A._instanceType(_this)._precomputed1;
      t1._as(data);
      t2 = _this._state;
      _this._state = (t2 | 64) >>> 0;
      _this._zone.runUnaryGuarded$1$2(_this._onData, data, t1);
      _this._state = (_this._state & 4294967231) >>> 0;
      _this._checkState$1((t2 & 4) !== 0);
    },
    _sendError$2(error, stackTrace) {
      var cancelFuture, _this = this,
        t1 = _this._state,
        t2 = new A._BufferingStreamSubscription__sendError_sendError(_this, error, stackTrace);
      if ((t1 & 1) !== 0) {
        _this._state = (t1 | 16) >>> 0;
        _this._cancel$0();
        cancelFuture = _this._cancelFuture;
        if (cancelFuture != null && cancelFuture !== $.$get$Future__nullFuture())
          cancelFuture.whenComplete$1(t2);
        else
          t2.call$0();
      } else {
        t2.call$0();
        _this._checkState$1((t1 & 4) !== 0);
      }
    },
    _sendDone$0() {
      var cancelFuture, _this = this,
        t1 = new A._BufferingStreamSubscription__sendDone_sendDone(_this);
      _this._cancel$0();
      _this._state = (_this._state | 16) >>> 0;
      cancelFuture = _this._cancelFuture;
      if (cancelFuture != null && cancelFuture !== $.$get$Future__nullFuture())
        cancelFuture.whenComplete$1(t1);
      else
        t1.call$0();
    },
    _guardCallback$1(callback) {
      var t1, _this = this;
      type$.void_Function._as(callback);
      t1 = _this._state;
      _this._state = (t1 | 64) >>> 0;
      callback.call$0();
      _this._state = (_this._state & 4294967231) >>> 0;
      _this._checkState$1((t1 & 4) !== 0);
    },
    _checkState$1(wasInputPaused) {
      var t2, isInputPaused, _this = this,
        t1 = _this._state;
      if ((t1 & 128) !== 0 && _this._pending.lastPendingEvent == null) {
        t1 = _this._state = (t1 & 4294967167) >>> 0;
        t2 = false;
        if ((t1 & 4) !== 0)
          if (t1 < 256) {
            t2 = _this._pending;
            t2 = t2 == null ? null : t2.lastPendingEvent == null;
            t2 = t2 !== false;
          }
        if (t2) {
          t1 = (t1 & 4294967291) >>> 0;
          _this._state = t1;
        }
      }
      for (; true; wasInputPaused = isInputPaused) {
        if ((t1 & 8) !== 0) {
          _this._pending = null;
          return;
        }
        isInputPaused = (t1 & 4) !== 0;
        if (wasInputPaused === isInputPaused)
          break;
        _this._state = (t1 ^ 64) >>> 0;
        if (isInputPaused)
          _this._onPause$0();
        else
          _this._onResume$0();
        t1 = (_this._state & 4294967231) >>> 0;
        _this._state = t1;
      }
      if ((t1 & 128) !== 0 && t1 < 256)
        _this._pending.schedule$1(_this);
    },
    $isStreamSubscription: 1,
    $is_EventDispatch: 1
  };
  A._BufferingStreamSubscription__sendError_sendError.prototype = {
    call$0() {
      var onError, t3, t4,
        t1 = this.$this,
        t2 = t1._state;
      if ((t2 & 8) !== 0 && (t2 & 16) === 0)
        return;
      t1._state = (t2 | 64) >>> 0;
      onError = t1._onError;
      t2 = this.error;
      t3 = type$.Object;
      t4 = t1._zone;
      if (type$.void_Function_Object_StackTrace._is(onError))
        t4.runBinaryGuarded$2$3(onError, t2, this.stackTrace, t3, type$.StackTrace);
      else
        t4.runUnaryGuarded$1$2(type$.void_Function_Object._as(onError), t2, t3);
      t1._state = (t1._state & 4294967231) >>> 0;
    },
    $signature: 0
  };
  A._BufferingStreamSubscription__sendDone_sendDone.prototype = {
    call$0() {
      var t1 = this.$this,
        t2 = t1._state;
      if ((t2 & 16) === 0)
        return;
      t1._state = (t2 | 74) >>> 0;
      t1._zone.runGuarded$1(t1._onDone);
      t1._state = (t1._state & 4294967231) >>> 0;
    },
    $signature: 0
  };
  A._StreamImpl.prototype = {
    listen$4$cancelOnError$onDone$onError(onData, cancelOnError, onDone, onError) {
      var t1 = this.$ti;
      t1._eval$1("~(1)?")._as(onData);
      type$.nullable_void_Function._as(onDone);
      return this._controller._subscribe$4(t1._eval$1("~(1)?")._as(onData), onError, onDone, true);
    }
  };
  A._DelayedEvent.prototype = {
    set$next(next) {
      this.next = type$.nullable__DelayedEvent_dynamic._as(next);
    },
    get$next() {
      return this.next;
    }
  };
  A._DelayedData.prototype = {
    perform$1(dispatch) {
      this.$ti._eval$1("_EventDispatch<1>")._as(dispatch)._sendData$1(this.value);
    }
  };
  A._DelayedError.prototype = {
    perform$1(dispatch) {
      dispatch._sendError$2(this.error, this.stackTrace);
    }
  };
  A._DelayedDone.prototype = {
    perform$1(dispatch) {
      dispatch._sendDone$0();
    },
    get$next() {
      return null;
    },
    set$next(__wc0_formal) {
      throw A.wrapException(A.StateError$("No events after a done."));
    },
    $is_DelayedEvent: 1
  };
  A._PendingEvents.prototype = {
    schedule$1(dispatch) {
      var t1, _this = this;
      _this.$ti._eval$1("_EventDispatch<1>")._as(dispatch);
      t1 = _this._state;
      if (t1 === 1)
        return;
      if (t1 >= 1) {
        _this._state = 1;
        return;
      }
      A.scheduleMicrotask(new A._PendingEvents_schedule_closure(_this, dispatch));
      _this._state = 1;
    },
    add$1(_, $event) {
      var _this = this,
        lastEvent = _this.lastPendingEvent;
      if (lastEvent == null)
        _this.firstPendingEvent = _this.lastPendingEvent = $event;
      else {
        lastEvent.set$next($event);
        _this.lastPendingEvent = $event;
      }
    }
  };
  A._PendingEvents_schedule_closure.prototype = {
    call$0() {
      var t2, $event, nextEvent,
        t1 = this.$this,
        oldState = t1._state;
      t1._state = 0;
      if (oldState === 3)
        return;
      t2 = t1.$ti._eval$1("_EventDispatch<1>")._as(this.dispatch);
      $event = t1.firstPendingEvent;
      nextEvent = $event.get$next();
      t1.firstPendingEvent = nextEvent;
      if (nextEvent == null)
        t1.lastPendingEvent = null;
      $event.perform$1(t2);
    },
    $signature: 0
  };
  A._StreamIterator.prototype = {
    get$current() {
      var _this = this;
      if (_this._async$_hasValue)
        return _this.$ti._precomputed1._as(_this._stateData);
      return _this.$ti._precomputed1._as(null);
    },
    moveNext$0() {
      var future, _this = this,
        subscription = _this._subscription;
      if (subscription != null) {
        if (_this._async$_hasValue) {
          future = new A._Future($.Zone__current, type$._Future_bool);
          _this._stateData = future;
          _this._async$_hasValue = false;
          subscription.resume$0();
          return future;
        }
        throw A.wrapException(A.StateError$("Already waiting for next."));
      }
      return _this._initializeOrDone$0();
    },
    _initializeOrDone$0() {
      var future, subscription, _this = this,
        stateData = _this._stateData;
      if (stateData != null) {
        _this.$ti._eval$1("Stream<1>")._as(stateData);
        future = new A._Future($.Zone__current, type$._Future_bool);
        _this._stateData = future;
        subscription = stateData.listen$4$cancelOnError$onDone$onError(_this.get$_onData(), true, _this.get$_onDone(), _this.get$_onError());
        if (_this._stateData != null)
          _this._subscription = subscription;
        return future;
      }
      return $.$get$Future__falseFuture();
    },
    cancel$0() {
      var _this = this,
        subscription = _this._subscription,
        stateData = _this._stateData;
      _this._stateData = null;
      if (subscription != null) {
        _this._subscription = null;
        if (!_this._async$_hasValue)
          type$._Future_bool._as(stateData)._asyncComplete$1(false);
        else
          _this._async$_hasValue = false;
        return subscription.cancel$0();
      }
      return $.$get$Future__nullFuture();
    },
    _onData$1(data) {
      var moveNextFuture, t1, _this = this;
      _this.$ti._precomputed1._as(data);
      if (_this._subscription == null)
        return;
      moveNextFuture = type$._Future_bool._as(_this._stateData);
      _this._stateData = data;
      _this._async$_hasValue = true;
      moveNextFuture._complete$1(true);
      if (_this._async$_hasValue) {
        t1 = _this._subscription;
        if (t1 != null)
          t1.pause$0();
      }
    },
    _onError$2(error, stackTrace) {
      var subscription, moveNextFuture, _this = this;
      type$.Object._as(error);
      type$.StackTrace._as(stackTrace);
      subscription = _this._subscription;
      moveNextFuture = type$._Future_bool._as(_this._stateData);
      _this._stateData = _this._subscription = null;
      if (subscription != null)
        moveNextFuture._completeErrorObject$1(new A.AsyncError(error, stackTrace));
      else
        moveNextFuture._asyncCompleteErrorObject$1(new A.AsyncError(error, stackTrace));
    },
    _onDone$0() {
      var _this = this,
        subscription = _this._subscription,
        moveNextFuture = type$._Future_bool._as(_this._stateData);
      _this._stateData = _this._subscription = null;
      if (subscription != null)
        moveNextFuture._completeWithValue$1(false);
      else
        moveNextFuture._asyncCompleteWithValue$1(false);
    }
  };
  A._ZoneFunction.prototype = {};
  A._Zone.prototype = {$isZone: 1};
  A._rootHandleError_closure.prototype = {
    call$0() {
      A.Error_throwWithStackTrace(this.error, this.stackTrace);
    },
    $signature: 0
  };
  A._RootZone.prototype = {
    get$_scheduleMicrotask() {
      return B._ZoneFunction__RootZone__rootScheduleMicrotask;
    },
    get$errorZone() {
      return this;
    },
    runGuarded$1(f) {
      var e, s, exception;
      type$.void_Function._as(f);
      try {
        if (B.C__RootZone === $.Zone__current) {
          f.call$0();
          return;
        }
        A._rootRun(null, null, this, f, type$.void);
      } catch (exception) {
        e = A.unwrapException(exception);
        s = A.getTraceFromException(exception);
        A._rootHandleError(type$.Object._as(e), type$.StackTrace._as(s));
      }
    },
    runUnaryGuarded$1$2(f, arg, $T) {
      var e, s, exception;
      $T._eval$1("~(0)")._as(f);
      $T._as(arg);
      try {
        if (B.C__RootZone === $.Zone__current) {
          f.call$1(arg);
          return;
        }
        A._rootRunUnary(null, null, this, f, arg, type$.void, $T);
      } catch (exception) {
        e = A.unwrapException(exception);
        s = A.getTraceFromException(exception);
        A._rootHandleError(type$.Object._as(e), type$.StackTrace._as(s));
      }
    },
    runBinaryGuarded$2$3(f, arg1, arg2, T1, T2) {
      var e, s, exception;
      T1._eval$1("@<0>")._bind$1(T2)._eval$1("~(1,2)")._as(f);
      T1._as(arg1);
      T2._as(arg2);
      try {
        if (B.C__RootZone === $.Zone__current) {
          f.call$2(arg1, arg2);
          return;
        }
        A._rootRunBinary(null, null, this, f, arg1, arg2, type$.void, T1, T2);
      } catch (exception) {
        e = A.unwrapException(exception);
        s = A.getTraceFromException(exception);
        A._rootHandleError(type$.Object._as(e), type$.StackTrace._as(s));
      }
    },
    bindCallback$1$1(f, $R) {
      return new A._RootZone_bindCallback_closure(this, $R._eval$1("0()")._as(f), $R);
    },
    bindCallbackGuarded$1(f) {
      return new A._RootZone_bindCallbackGuarded_closure(this, type$.void_Function._as(f));
    },
    bindUnaryCallbackGuarded$1$1(f, $T) {
      return new A._RootZone_bindUnaryCallbackGuarded_closure(this, $T._eval$1("~(0)")._as(f), $T);
    },
    handleUncaughtError$2(error, stackTrace) {
      A._rootHandleError(error, type$.StackTrace._as(stackTrace));
    },
    run$1$1(f, $R) {
      $R._eval$1("0()")._as(f);
      if ($.Zone__current === B.C__RootZone)
        return f.call$0();
      return A._rootRun(null, null, this, f, $R);
    },
    runUnary$2$2(f, arg, $R, $T) {
      $R._eval$1("@<0>")._bind$1($T)._eval$1("1(2)")._as(f);
      $T._as(arg);
      if ($.Zone__current === B.C__RootZone)
        return f.call$1(arg);
      return A._rootRunUnary(null, null, this, f, arg, $R, $T);
    },
    runBinary$3$3(f, arg1, arg2, $R, T1, T2) {
      $R._eval$1("@<0>")._bind$1(T1)._bind$1(T2)._eval$1("1(2,3)")._as(f);
      T1._as(arg1);
      T2._as(arg2);
      if ($.Zone__current === B.C__RootZone)
        return f.call$2(arg1, arg2);
      return A._rootRunBinary(null, null, this, f, arg1, arg2, $R, T1, T2);
    },
    registerCallback$1$1(f, $R) {
      return $R._eval$1("0()")._as(f);
    },
    registerUnaryCallback$2$1(f, $R, $T) {
      return $R._eval$1("@<0>")._bind$1($T)._eval$1("1(2)")._as(f);
    },
    registerBinaryCallback$3$1(f, $R, T1, T2) {
      return $R._eval$1("@<0>")._bind$1(T1)._bind$1(T2)._eval$1("1(2,3)")._as(f);
    },
    errorCallback$2(error, stackTrace) {
      return null;
    },
    scheduleMicrotask$1(f) {
      A._rootScheduleMicrotask(null, null, this, type$.void_Function._as(f));
    },
    createTimer$2(duration, f) {
      return A.Timer__createTimer(duration, type$.void_Function._as(f));
    }
  };
  A._RootZone_bindCallback_closure.prototype = {
    call$0() {
      return this.$this.run$1$1(this.f, this.R);
    },
    $signature() {
      return this.R._eval$1("0()");
    }
  };
  A._RootZone_bindCallbackGuarded_closure.prototype = {
    call$0() {
      return this.$this.runGuarded$1(this.f);
    },
    $signature: 0
  };
  A._RootZone_bindUnaryCallbackGuarded_closure.prototype = {
    call$1(arg) {
      var t1 = this.T;
      return this.$this.runUnaryGuarded$1$2(this.f, t1._as(arg), t1);
    },
    $signature() {
      return this.T._eval$1("~(0)");
    }
  };
  A._HashMap.prototype = {
    get$length(_) {
      return this._collection$_length;
    },
    get$isEmpty(_) {
      return this._collection$_length === 0;
    },
    get$isNotEmpty(_) {
      return this._collection$_length !== 0;
    },
    get$keys() {
      return new A._HashMapKeyIterable(this, A._instanceType(this)._eval$1("_HashMapKeyIterable<1>"));
    },
    get$values() {
      var t1 = A._instanceType(this);
      return A.MappedIterable_MappedIterable(new A._HashMapKeyIterable(this, t1._eval$1("_HashMapKeyIterable<1>")), new A._HashMap_values_closure(this), t1._precomputed1, t1._rest[1]);
    },
    containsKey$1(key) {
      var strings, nums;
      if (typeof key == "string" && key !== "__proto__") {
        strings = this._collection$_strings;
        return strings == null ? false : strings[key] != null;
      } else if (typeof key == "number" && (key & 1073741823) === key) {
        nums = this._collection$_nums;
        return nums == null ? false : nums[key] != null;
      } else
        return this._containsKey$1(key);
    },
    _containsKey$1(key) {
      var rest = this._collection$_rest;
      if (rest == null)
        return false;
      return this._findBucketIndex$2(this._getBucket$2(rest, key), key) >= 0;
    },
    $index(_, key) {
      var strings, t1, nums;
      if (typeof key == "string" && key !== "__proto__") {
        strings = this._collection$_strings;
        t1 = strings == null ? null : A._HashMap__getTableEntry(strings, key);
        return t1;
      } else if (typeof key == "number" && (key & 1073741823) === key) {
        nums = this._collection$_nums;
        t1 = nums == null ? null : A._HashMap__getTableEntry(nums, key);
        return t1;
      } else
        return this._get$1(key);
    },
    _get$1(key) {
      var bucket, index,
        rest = this._collection$_rest;
      if (rest == null)
        return null;
      bucket = this._getBucket$2(rest, key);
      index = this._findBucketIndex$2(bucket, key);
      return index < 0 ? null : bucket[index + 1];
    },
    $indexSet(_, key, value) {
      var strings, nums, _this = this,
        t1 = A._instanceType(_this);
      t1._precomputed1._as(key);
      t1._rest[1]._as(value);
      if (typeof key == "string" && key !== "__proto__") {
        strings = _this._collection$_strings;
        _this._collection$_addHashTableEntry$3(strings == null ? _this._collection$_strings = A._HashMap__newHashTable() : strings, key, value);
      } else if (typeof key == "number" && (key & 1073741823) === key) {
        nums = _this._collection$_nums;
        _this._collection$_addHashTableEntry$3(nums == null ? _this._collection$_nums = A._HashMap__newHashTable() : nums, key, value);
      } else
        _this._set$2(key, value);
    },
    _set$2(key, value) {
      var rest, hash, bucket, index, _this = this,
        t1 = A._instanceType(_this);
      t1._precomputed1._as(key);
      t1._rest[1]._as(value);
      rest = _this._collection$_rest;
      if (rest == null)
        rest = _this._collection$_rest = A._HashMap__newHashTable();
      hash = _this._computeHashCode$1(key);
      bucket = rest[hash];
      if (bucket == null) {
        A._HashMap__setTableEntry(rest, hash, [key, value]);
        ++_this._collection$_length;
        _this._keys = null;
      } else {
        index = _this._findBucketIndex$2(bucket, key);
        if (index >= 0)
          bucket[index + 1] = value;
        else {
          bucket.push(key, value);
          ++_this._collection$_length;
          _this._keys = null;
        }
      }
    },
    forEach$1(_, action) {
      var keys, $length, t2, i, key, t3, _this = this,
        t1 = A._instanceType(_this);
      t1._eval$1("~(1,2)")._as(action);
      keys = _this._computeKeys$0();
      for ($length = keys.length, t2 = t1._precomputed1, t1 = t1._rest[1], i = 0; i < $length; ++i) {
        key = keys[i];
        t2._as(key);
        t3 = _this.$index(0, key);
        action.call$2(key, t3 == null ? t1._as(t3) : t3);
        if (keys !== _this._keys)
          throw A.wrapException(A.ConcurrentModificationError$(_this));
      }
    },
    _computeKeys$0() {
      var strings, index, names, entries, i, nums, rest, bucket, $length, i0, _this = this,
        result = _this._keys;
      if (result != null)
        return result;
      result = A.List_List$filled(_this._collection$_length, null, false, type$.dynamic);
      strings = _this._collection$_strings;
      index = 0;
      if (strings != null) {
        names = Object.getOwnPropertyNames(strings);
        entries = names.length;
        for (i = 0; i < entries; ++i) {
          result[index] = names[i];
          ++index;
        }
      }
      nums = _this._collection$_nums;
      if (nums != null) {
        names = Object.getOwnPropertyNames(nums);
        entries = names.length;
        for (i = 0; i < entries; ++i) {
          result[index] = +names[i];
          ++index;
        }
      }
      rest = _this._collection$_rest;
      if (rest != null) {
        names = Object.getOwnPropertyNames(rest);
        entries = names.length;
        for (i = 0; i < entries; ++i) {
          bucket = rest[names[i]];
          $length = bucket.length;
          for (i0 = 0; i0 < $length; i0 += 2) {
            result[index] = bucket[i0];
            ++index;
          }
        }
      }
      return _this._keys = result;
    },
    _collection$_addHashTableEntry$3(table, key, value) {
      var t1 = A._instanceType(this);
      t1._precomputed1._as(key);
      t1._rest[1]._as(value);
      if (table[key] == null) {
        ++this._collection$_length;
        this._keys = null;
      }
      A._HashMap__setTableEntry(table, key, value);
    },
    _computeHashCode$1(key) {
      return J.get$hashCode$(key) & 1073741823;
    },
    _getBucket$2(table, key) {
      return table[this._computeHashCode$1(key)];
    },
    _findBucketIndex$2(bucket, key) {
      var $length, i;
      if (bucket == null)
        return -1;
      $length = bucket.length;
      for (i = 0; i < $length; i += 2)
        if (J.$eq$(bucket[i], key))
          return i;
      return -1;
    }
  };
  A._HashMap_values_closure.prototype = {
    call$1(each) {
      var t1 = this.$this,
        t2 = A._instanceType(t1);
      t1 = t1.$index(0, t2._precomputed1._as(each));
      return t1 == null ? t2._rest[1]._as(t1) : t1;
    },
    $signature() {
      return A._instanceType(this.$this)._eval$1("2(1)");
    }
  };
  A._IdentityHashMap.prototype = {
    _computeHashCode$1(key) {
      return A.objectHashCode(key) & 1073741823;
    },
    _findBucketIndex$2(bucket, key) {
      var $length, i, t1;
      if (bucket == null)
        return -1;
      $length = bucket.length;
      for (i = 0; i < $length; i += 2) {
        t1 = bucket[i];
        if (t1 == null ? key == null : t1 === key)
          return i;
      }
      return -1;
    }
  };
  A._CustomHashMap.prototype = {
    $index(_, key) {
      if (!this._validKey.call$1(key))
        return null;
      return this.super$_HashMap$_get(key);
    },
    $indexSet(_, key, value) {
      var t1 = this.$ti;
      this.super$_HashMap$_set(t1._precomputed1._as(key), t1._rest[1]._as(value));
    },
    containsKey$1(key) {
      if (!this._validKey.call$1(key))
        return false;
      return this.super$_HashMap$_containsKey(key);
    },
    _computeHashCode$1(key) {
      return this._hashCode.call$1(this.$ti._precomputed1._as(key)) & 1073741823;
    },
    _findBucketIndex$2(bucket, key) {
      var $length, t1, t2, i;
      if (bucket == null)
        return -1;
      $length = bucket.length;
      for (t1 = this.$ti._precomputed1, t2 = this._equals, i = 0; i < $length; i += 2)
        if (t2.call$2(bucket[i], t1._as(key)))
          return i;
      return -1;
    }
  };
  A._CustomHashMap_closure.prototype = {
    call$1(v) {
      return this.K._is(v);
    },
    $signature: 3
  };
  A._HashMapKeyIterable.prototype = {
    get$length(_) {
      return this._collection$_map._collection$_length;
    },
    get$isEmpty(_) {
      return this._collection$_map._collection$_length === 0;
    },
    get$isNotEmpty(_) {
      return this._collection$_map._collection$_length !== 0;
    },
    get$iterator(_) {
      var t1 = this._collection$_map;
      return new A._HashMapKeyIterator(t1, t1._computeKeys$0(), this.$ti._eval$1("_HashMapKeyIterator<1>"));
    },
    contains$1(_, element) {
      return this._collection$_map.containsKey$1(element);
    }
  };
  A._HashMapKeyIterator.prototype = {
    get$current() {
      var t1 = this._collection$_current;
      return t1 == null ? this.$ti._precomputed1._as(t1) : t1;
    },
    moveNext$0() {
      var _this = this,
        keys = _this._keys,
        offset = _this._offset,
        t1 = _this._collection$_map;
      if (keys !== t1._keys)
        throw A.wrapException(A.ConcurrentModificationError$(t1));
      else if (offset >= keys.length) {
        _this._collection$_current = null;
        return false;
      } else {
        _this._collection$_current = keys[offset];
        _this._offset = offset + 1;
        return true;
      }
    },
    $isIterator: 1
  };
  A._LinkedHashSet.prototype = {
    _newSimilarSet$1$0($R) {
      return new A._LinkedHashSet($R._eval$1("_LinkedHashSet<0>"));
    },
    _newSimilarSet$0() {
      return this._newSimilarSet$1$0(type$.dynamic);
    },
    get$iterator(_) {
      var _this = this,
        t1 = new A._LinkedHashSetIterator(_this, _this._collection$_modifications, A._instanceType(_this)._eval$1("_LinkedHashSetIterator<1>"));
      t1._collection$_cell = _this._collection$_first;
      return t1;
    },
    get$length(_) {
      return this._collection$_length;
    },
    get$isEmpty(_) {
      return this._collection$_length === 0;
    },
    get$isNotEmpty(_) {
      return this._collection$_length !== 0;
    },
    contains$1(_, object) {
      var strings, t1;
      if (object !== "__proto__") {
        strings = this._collection$_strings;
        if (strings == null)
          return false;
        return type$.nullable__LinkedHashSetCell._as(strings[object]) != null;
      } else {
        t1 = this._contains$1(object);
        return t1;
      }
    },
    _contains$1(object) {
      var rest = this._collection$_rest;
      if (rest == null)
        return false;
      return this._findBucketIndex$2(rest[this._computeHashCode$1(object)], object) >= 0;
    },
    get$first(_) {
      var first = this._collection$_first;
      if (first == null)
        throw A.wrapException(A.StateError$("No elements"));
      return A._instanceType(this)._precomputed1._as(first._element);
    },
    add$1(_, element) {
      var strings, nums, _this = this;
      A._instanceType(_this)._precomputed1._as(element);
      if (typeof element == "string" && element !== "__proto__") {
        strings = _this._collection$_strings;
        return _this._collection$_addHashTableEntry$2(strings == null ? _this._collection$_strings = A._LinkedHashSet__newHashTable() : strings, element);
      } else if (typeof element == "number" && (element & 1073741823) === element) {
        nums = _this._collection$_nums;
        return _this._collection$_addHashTableEntry$2(nums == null ? _this._collection$_nums = A._LinkedHashSet__newHashTable() : nums, element);
      } else
        return _this._collection$_add$1(element);
    },
    _collection$_add$1(element) {
      var rest, hash, bucket, _this = this;
      A._instanceType(_this)._precomputed1._as(element);
      rest = _this._collection$_rest;
      if (rest == null)
        rest = _this._collection$_rest = A._LinkedHashSet__newHashTable();
      hash = _this._computeHashCode$1(element);
      bucket = rest[hash];
      if (bucket == null)
        rest[hash] = [_this._collection$_newLinkedCell$1(element)];
      else {
        if (_this._findBucketIndex$2(bucket, element) >= 0)
          return false;
        bucket.push(_this._collection$_newLinkedCell$1(element));
      }
      return true;
    },
    _collection$_addHashTableEntry$2(table, element) {
      A._instanceType(this)._precomputed1._as(element);
      if (type$.nullable__LinkedHashSetCell._as(table[element]) != null)
        return false;
      table[element] = this._collection$_newLinkedCell$1(element);
      return true;
    },
    _collection$_newLinkedCell$1(element) {
      var _this = this,
        cell = new A._LinkedHashSetCell(A._instanceType(_this)._precomputed1._as(element));
      if (_this._collection$_first == null)
        _this._collection$_first = _this._collection$_last = cell;
      else
        _this._collection$_last = _this._collection$_last._collection$_next = cell;
      ++_this._collection$_length;
      _this._collection$_modifications = _this._collection$_modifications + 1 & 1073741823;
      return cell;
    },
    _computeHashCode$1(element) {
      return J.get$hashCode$(element) & 1073741823;
    },
    _findBucketIndex$2(bucket, element) {
      var $length, i;
      if (bucket == null)
        return -1;
      $length = bucket.length;
      for (i = 0; i < $length; ++i)
        if (J.$eq$(bucket[i]._element, element))
          return i;
      return -1;
    }
  };
  A._LinkedHashSetCell.prototype = {};
  A._LinkedHashSetIterator.prototype = {
    get$current() {
      var t1 = this._collection$_current;
      return t1 == null ? this.$ti._precomputed1._as(t1) : t1;
    },
    moveNext$0() {
      var _this = this,
        cell = _this._collection$_cell,
        t1 = _this._set;
      if (_this._collection$_modifications !== t1._collection$_modifications)
        throw A.wrapException(A.ConcurrentModificationError$(t1));
      else if (cell == null) {
        _this._collection$_current = null;
        return false;
      } else {
        _this._collection$_current = _this.$ti._eval$1("1?")._as(cell._element);
        _this._collection$_cell = cell._collection$_next;
        return true;
      }
    },
    $isIterator: 1
  };
  A.LinkedHashMap_LinkedHashMap$from_closure.prototype = {
    call$2(k, v) {
      this.result.$indexSet(0, this.K._as(k), this.V._as(v));
    },
    $signature: 4
  };
  A.ListBase.prototype = {
    get$iterator(receiver) {
      return new A.ListIterator(receiver, this.get$length(receiver), A.instanceType(receiver)._eval$1("ListIterator<ListBase.E>"));
    },
    elementAt$1(receiver, index) {
      return this.$index(receiver, index);
    },
    forEach$1(receiver, action) {
      var $length, i;
      A.instanceType(receiver)._eval$1("~(ListBase.E)")._as(action);
      $length = this.get$length(receiver);
      for (i = 0; i < $length; ++i) {
        action.call$1(this.$index(receiver, i));
        if ($length !== this.get$length(receiver))
          throw A.wrapException(A.ConcurrentModificationError$(receiver));
      }
    },
    get$isEmpty(receiver) {
      return this.get$length(receiver) === 0;
    },
    get$isNotEmpty(receiver) {
      return !this.get$isEmpty(receiver);
    },
    get$first(receiver) {
      if (this.get$length(receiver) === 0)
        throw A.wrapException(A.IterableElementError_noElement());
      return this.$index(receiver, 0);
    },
    contains$1(receiver, element) {
      var i,
        $length = this.get$length(receiver);
      for (i = 0; i < $length; ++i) {
        if (J.$eq$(this.$index(receiver, i), element))
          return true;
        if ($length !== this.get$length(receiver))
          throw A.wrapException(A.ConcurrentModificationError$(receiver));
      }
      return false;
    },
    map$1$1(receiver, f, $T) {
      var t1 = A.instanceType(receiver);
      return new A.MappedListIterable(receiver, t1._bind$1($T)._eval$1("1(ListBase.E)")._as(f), t1._eval$1("@<ListBase.E>")._bind$1($T)._eval$1("MappedListIterable<1,2>"));
    },
    skip$1(receiver, count) {
      return A.SubListIterable$(receiver, count, null, A.instanceType(receiver)._eval$1("ListBase.E"));
    },
    take$1(receiver, count) {
      return A.SubListIterable$(receiver, 0, A.checkNotNullable(count, "count", type$.int), A.instanceType(receiver)._eval$1("ListBase.E"));
    },
    toList$1$growable(receiver, growable) {
      var t1, first, result, i, _this = this;
      if (_this.get$isEmpty(receiver)) {
        t1 = A.instanceType(receiver)._eval$1("ListBase.E");
        return growable ? J.JSArray_JSArray$growable(0, t1) : J.JSArray_JSArray$fixed(0, t1);
      }
      first = _this.$index(receiver, 0);
      result = A.List_List$filled(_this.get$length(receiver), first, growable, A.instanceType(receiver)._eval$1("ListBase.E"));
      for (i = 1; i < _this.get$length(receiver); ++i)
        B.JSArray_methods.$indexSet(result, i, _this.$index(receiver, i));
      return result;
    },
    toList$0(receiver) {
      return this.toList$1$growable(receiver, true);
    },
    cast$1$0(receiver, $R) {
      return new A.CastList(receiver, A.instanceType(receiver)._eval$1("@<ListBase.E>")._bind$1($R)._eval$1("CastList<1,2>"));
    },
    toString$0(receiver) {
      return A.Iterable_iterableToFullString(receiver, "[", "]");
    },
    $isEfficientLengthIterable: 1,
    $isIterable: 1,
    $isList: 1
  };
  A.MapBase.prototype = {
    cast$2$0(_, RK, RV) {
      return new A.CastMap(this, A._instanceType(this)._eval$1("@<MapBase.K,MapBase.V>")._bind$1(RK)._bind$1(RV)._eval$1("CastMap<1,2,3,4>"));
    },
    forEach$1(_, action) {
      var t2, key, t3,
        t1 = A._instanceType(this);
      t1._eval$1("~(MapBase.K,MapBase.V)")._as(action);
      for (t2 = this.get$keys(), t2 = t2.get$iterator(t2), t1 = t1._eval$1("MapBase.V"); t2.moveNext$0();) {
        key = t2.get$current();
        t3 = this.$index(0, key);
        action.call$2(key, t3 == null ? t1._as(t3) : t3);
      }
    },
    map$2$1(_, transform, K2, V2) {
      var result, t2, key, t3, entry,
        t1 = A._instanceType(this);
      t1._bind$1(K2)._bind$1(V2)._eval$1("MapEntry<1,2>(MapBase.K,MapBase.V)")._as(transform);
      result = A.LinkedHashMap_LinkedHashMap$_empty(K2, V2);
      for (t2 = this.get$keys(), t2 = t2.get$iterator(t2), t1 = t1._eval$1("MapBase.V"); t2.moveNext$0();) {
        key = t2.get$current();
        t3 = this.$index(0, key);
        entry = transform.call$2(key, t3 == null ? t1._as(t3) : t3);
        result.$indexSet(0, entry.key, entry.value);
      }
      return result;
    },
    get$length(_) {
      var t1 = this.get$keys();
      return t1.get$length(t1);
    },
    get$isEmpty(_) {
      var t1 = this.get$keys();
      return t1.get$isEmpty(t1);
    },
    get$isNotEmpty(_) {
      var t1 = this.get$keys();
      return t1.get$isNotEmpty(t1);
    },
    get$values() {
      return new A._MapBaseValueIterable(this, A._instanceType(this)._eval$1("_MapBaseValueIterable<MapBase.K,MapBase.V>"));
    },
    toString$0(_) {
      return A.MapBase_mapToString(this);
    },
    $isMap: 1
  };
  A.MapBase_mapToString_closure.prototype = {
    call$2(k, v) {
      var t2,
        t1 = this._box_0;
      if (!t1.first)
        this.result._contents += ", ";
      t1.first = false;
      t1 = this.result;
      t2 = A.S(k);
      t1._contents = (t1._contents += t2) + ": ";
      t2 = A.S(v);
      t1._contents += t2;
    },
    $signature: 17
  };
  A._MapBaseValueIterable.prototype = {
    get$length(_) {
      var t1 = this._collection$_map;
      return t1.get$length(t1);
    },
    get$isEmpty(_) {
      var t1 = this._collection$_map;
      return t1.get$isEmpty(t1);
    },
    get$isNotEmpty(_) {
      var t1 = this._collection$_map;
      return t1.get$isNotEmpty(t1);
    },
    get$first(_) {
      var t1 = this._collection$_map,
        t2 = t1.get$keys();
      t2 = t1.$index(0, t2.get$first(t2));
      return t2 == null ? this.$ti._rest[1]._as(t2) : t2;
    },
    get$iterator(_) {
      var t1 = this._collection$_map,
        t2 = t1.get$keys();
      return new A._MapBaseValueIterator(t2.get$iterator(t2), t1, this.$ti._eval$1("_MapBaseValueIterator<1,2>"));
    }
  };
  A._MapBaseValueIterator.prototype = {
    moveNext$0() {
      var _this = this,
        t1 = _this._keys;
      if (t1.moveNext$0()) {
        _this._collection$_current = _this._collection$_map.$index(0, t1.get$current());
        return true;
      }
      _this._collection$_current = null;
      return false;
    },
    get$current() {
      var t1 = this._collection$_current;
      return t1 == null ? this.$ti._rest[1]._as(t1) : t1;
    },
    $isIterator: 1
  };
  A.SetBase.prototype = {
    get$isEmpty(_) {
      return this._collection$_length === 0;
    },
    get$isNotEmpty(_) {
      return this._collection$_length !== 0;
    },
    cast$1$0(_, $R) {
      return A.Set_castFrom(this, null, A._instanceType(this)._precomputed1, $R);
    },
    addAll$1(_, elements) {
      var t1;
      A._instanceType(this)._eval$1("Iterable<1>")._as(elements);
      for (t1 = elements.get$iterator(elements); t1.moveNext$0();)
        this.add$1(0, t1.get$current());
    },
    toList$1$growable(_, growable) {
      var t1 = A.List_List$_of(this, A._instanceType(this)._precomputed1);
      t1.$flags = 1;
      return t1;
    },
    map$1$1(_, f, $T) {
      var t1 = A._instanceType(this);
      return new A.EfficientLengthMappedIterable(this, t1._bind$1($T)._eval$1("1(2)")._as(f), t1._eval$1("@<1>")._bind$1($T)._eval$1("EfficientLengthMappedIterable<1,2>"));
    },
    toString$0(_) {
      return A.Iterable_iterableToFullString(this, "{", "}");
    },
    take$1(_, n) {
      return A.TakeIterable_TakeIterable(this, n, A._instanceType(this)._precomputed1);
    },
    skip$1(_, n) {
      return A.SkipIterable_SkipIterable(this, n, A._instanceType(this)._precomputed1);
    },
    get$first(_) {
      var t1,
        it = A._LinkedHashSetIterator$(this, this._collection$_modifications, A._instanceType(this)._precomputed1);
      if (!it.moveNext$0())
        throw A.wrapException(A.IterableElementError_noElement());
      t1 = it._collection$_current;
      return t1 == null ? it.$ti._precomputed1._as(t1) : t1;
    },
    elementAt$1(_, index) {
      var iterator, skipCount, t1, _this = this;
      A.RangeError_checkNotNegative(index, "index");
      iterator = A._LinkedHashSetIterator$(_this, _this._collection$_modifications, A._instanceType(_this)._precomputed1);
      for (skipCount = index; iterator.moveNext$0();) {
        if (skipCount === 0) {
          t1 = iterator._collection$_current;
          return t1 == null ? iterator.$ti._precomputed1._as(t1) : t1;
        }
        --skipCount;
      }
      throw A.wrapException(A.IndexError$withLength(index, index - skipCount, _this, null, "index"));
    },
    $isEfficientLengthIterable: 1,
    $isIterable: 1,
    $isSet: 1
  };
  A._SetBase.prototype = {
    cast$1$0(_, $R) {
      return A.Set_castFrom(this, this.get$_newSimilarSet(), A._instanceType(this)._precomputed1, $R);
    }
  };
  A._SplayTreeNode.prototype = {
    set$_left(_left) {
      this._left = this.$ti._eval$1("_SplayTreeNode.1?")._as(_left);
    },
    set$_right(_right) {
      this._right = this.$ti._eval$1("_SplayTreeNode.1?")._as(_right);
    }
  };
  A._SplayTreeMapNode.prototype = {
    set$value(value) {
      this.value = this.$ti._rest[1]._as(value);
    }
  };
  A._SplayTree.prototype = {
    _splay$1(key) {
      var root, compare, comparison, current, newTreeLeft, left, newTreeRight, right, currentLeft, currentLeft0, currentRight, currentRight0, _this = this, _null = null;
      _this.$ti._eval$1("_SplayTree.K")._as(key);
      root = _this._root;
      if (root == null) {
        _this._compare.call$2(key, key);
        return -1;
      }
      compare = _this._compare;
      for (comparison = _null, current = root, newTreeLeft = comparison, left = newTreeLeft, newTreeRight = left, right = newTreeRight; true;) {
        comparison = compare.call$2(current.key, key);
        if (comparison > 0) {
          currentLeft = current._left;
          if (currentLeft == null)
            break;
          comparison = compare.call$2(currentLeft.key, key);
          if (comparison > 0) {
            current.set$_left(currentLeft._right);
            currentLeft.set$_right(current);
            currentLeft0 = currentLeft._left;
            if (currentLeft0 == null) {
              current = currentLeft;
              break;
            }
            current = currentLeft;
            currentLeft = currentLeft0;
          }
          if (right == null)
            newTreeRight = current;
          else
            right.set$_left(current);
          right = current;
          current = currentLeft;
        } else {
          if (comparison < 0) {
            currentRight = current._right;
            if (currentRight == null)
              break;
            comparison = compare.call$2(currentRight.key, key);
            if (comparison < 0) {
              current.set$_right(currentRight._left);
              currentRight.set$_left(current);
              currentRight0 = currentRight._right;
              if (currentRight0 == null) {
                current = currentRight;
                break;
              }
              current = currentRight;
              currentRight = currentRight0;
            }
            if (left == null)
              newTreeLeft = current;
            else
              left.set$_right(current);
          } else
            break;
          left = current;
          current = currentRight;
        }
      }
      if (left != null) {
        left.set$_right(current._left);
        current.set$_left(newTreeLeft);
      }
      if (right != null) {
        right.set$_left(current._right);
        current.set$_right(newTreeRight);
      }
      if (_this._root !== current) {
        _this._root = current;
        ++_this._splayCount;
      }
      return comparison;
    },
    _splayMax$1(node) {
      var current, modified, right;
      this.$ti._eval$1("_SplayTree.1")._as(node);
      for (current = node, modified = 0; true; current = right, modified = 1) {
        right = current._right;
        if (right != null) {
          current.set$_right(right._left);
          right.set$_left(current);
        } else
          break;
      }
      this._splayCount += modified;
      return current;
    },
    _untypedLookup$1(key) {
      if (!this.$ti._eval$1("_SplayTree.K")._is(key))
        return null;
      if (this._splay$1(key) === 0)
        return this._root;
      return null;
    }
  };
  A.SplayTreeMap.prototype = {
    $index(_, key) {
      var t1 = this._untypedLookup$1(key);
      return t1 == null ? null : t1.value;
    },
    remove$1(_, key) {
      var root0, left, right, t1, _this = this,
        root = _this._untypedLookup$1(key);
      if (root == null)
        return null;
      root0 = _this._root;
      left = root0._left;
      right = root0._right;
      if (left == null)
        _this._root = right;
      else if (right == null)
        _this._root = left;
      else {
        t1 = _this._splayMax$1(left);
        t1.set$_right(right);
        _this._root = t1;
      }
      --_this._count;
      ++_this._modificationCount;
      return root.value;
    },
    $indexSet(_, key, value) {
      var comparison, root, _this = this,
        t1 = _this.$ti;
      t1._precomputed1._as(key);
      t1._rest[1]._as(value);
      comparison = _this._splay$1(key);
      if (comparison === 0) {
        _this._root.set$value(value);
        return;
      }
      t1 = t1._eval$1("_SplayTree.1")._as(new A._SplayTreeMapNode(value, key, t1._eval$1("_SplayTreeMapNode<1,2>")));
      root = _this._root;
      if (root != null)
        if (comparison < 0) {
          t1.set$_left(root);
          t1.set$_right(root._right);
          root.set$_right(null);
        } else {
          t1.set$_right(root);
          t1.set$_left(root._left);
          root.set$_left(null);
        }
      ++_this._modificationCount;
      ++_this._count;
      _this._root = t1;
    },
    get$isEmpty(_) {
      return this._root == null;
    },
    get$isNotEmpty(_) {
      return this._root != null;
    },
    forEach$1(_, f) {
      var nodes, node,
        t1 = this.$ti;
      t1._eval$1("~(1,2)")._as(f);
      nodes = new A._SplayTreeMapEntryIterator(this, A._setArrayType([], t1._eval$1("JSArray<_SplayTreeMapNode<1,2>>")), this._splayCount, t1._eval$1("_SplayTreeMapEntryIterator<1,2>"));
      for (; nodes._collection$_current = null, nodes.super$_SplayTreeIterator$moveNext();) {
        node = nodes.get$current();
        f.call$2(node.key, node.value);
      }
    },
    get$length(_) {
      return this._count;
    },
    get$keys() {
      return new A._SplayTreeKeyIterable(this, this.$ti._eval$1("_SplayTreeKeyIterable<1,_SplayTreeMapNode<1,2>>"));
    },
    get$values() {
      return new A._SplayTreeValueIterable(this, this.$ti._eval$1("_SplayTreeValueIterable<1,2>"));
    },
    $isMap: 1
  };
  A._SplayTreeIterator.prototype = {
    get$current() {
      var t1 = this._path;
      if (t1.length === 0) {
        A._instanceType(this)._eval$1("_SplayTreeIterator.T")._as(null);
        return null;
      }
      return this._getValue$1(B.JSArray_methods.get$last(t1));
    },
    _rebuildPath$1(key) {
      var t1, t2, t3, _this = this;
      A._instanceType(_this)._eval$1("_SplayTreeIterator.K")._as(key);
      t1 = _this._path;
      B.JSArray_methods.clear$0(t1);
      t2 = _this._tree;
      if (t2._splay$1(key) === 0) {
        t3 = t2._root;
        t3.toString;
        B.JSArray_methods.add$1(t1, t3);
        _this._splayCount = t2._splayCount;
        return;
      }
      throw A.wrapException(A.ConcurrentModificationError$(_this));
    },
    moveNext$0() {
      var node, next, _this = this,
        t1 = _this._modificationCount,
        t2 = _this._tree,
        t3 = t2._modificationCount;
      if (t1 !== t3) {
        if (t1 == null) {
          _this._modificationCount = t3;
          node = t2._root;
          for (t1 = _this._path; node != null;) {
            B.JSArray_methods.add$1(t1, node);
            node = node._left;
          }
          return t1.length !== 0;
        }
        throw A.wrapException(A.ConcurrentModificationError$(t2));
      }
      t1 = _this._path;
      if (t1.length === 0)
        return false;
      if (_this._splayCount !== t2._splayCount)
        _this._rebuildPath$1(B.JSArray_methods.get$last(t1).key);
      node = B.JSArray_methods.get$last(t1);
      next = node._right;
      if (next != null) {
        for (; next != null;) {
          B.JSArray_methods.add$1(t1, next);
          next = next._left;
        }
        return true;
      }
      if (0 >= t1.length)
        return A.ioore(t1, -1);
      t1.pop();
      while (true) {
        if (!(t1.length !== 0 && B.JSArray_methods.get$last(t1)._right === node))
          break;
        if (0 >= t1.length)
          return A.ioore(t1, -1);
        node = t1.pop();
      }
      return t1.length !== 0;
    },
    $isIterator: 1
  };
  A._SplayTreeKeyIterable.prototype = {
    get$length(_) {
      return this._tree._count;
    },
    get$isEmpty(_) {
      return this._tree._count === 0;
    },
    get$iterator(_) {
      var t1 = this._tree,
        t2 = this.$ti;
      return new A._SplayTreeKeyIterator(t1, A._setArrayType([], t2._eval$1("JSArray<2>")), t1._splayCount, t2._eval$1("_SplayTreeKeyIterator<1,2>"));
    },
    contains$1(_, element) {
      return this._tree._untypedLookup$1(element) != null;
    }
  };
  A._SplayTreeValueIterable.prototype = {
    get$length(_) {
      return this._collection$_map._count;
    },
    get$isEmpty(_) {
      return this._collection$_map._count === 0;
    },
    get$iterator(_) {
      var t1 = this._collection$_map,
        t2 = this.$ti;
      return new A._SplayTreeValueIterator(t1, A._setArrayType([], t2._eval$1("JSArray<_SplayTreeMapNode<1,2>>")), t1._splayCount, t2._eval$1("_SplayTreeValueIterator<1,2>"));
    }
  };
  A._SplayTreeKeyIterator.prototype = {
    _getValue$1(node) {
      return this.$ti._rest[1]._as(node).key;
    }
  };
  A._SplayTreeValueIterator.prototype = {
    moveNext$0() {
      var result = this.super$_SplayTreeIterator$moveNext();
      this._collection$_current = result ? B.JSArray_methods.get$last(this._path).value : null;
      return result;
    },
    _getValue$1(node) {
      var t2,
        t1 = this.$ti;
      t1._eval$1("_SplayTreeMapNode<1,2>")._as(node);
      t2 = this._collection$_current;
      return t2 == null ? t1._rest[1]._as(t2) : t2;
    }
  };
  A._SplayTreeMapEntryIterator.prototype = {
    _getValue$1(node) {
      var t2,
        t1 = this.$ti;
      t1._eval$1("_SplayTreeMapNode<1,2>")._as(node);
      t2 = this._collection$_current;
      return t2 == null ? this._collection$_current = new A.MapEntry(node.key, node.value, t1._eval$1("MapEntry<1,2>")) : t2;
    },
    moveNext$0() {
      this._collection$_current = null;
      return this.super$_SplayTreeIterator$moveNext();
    }
  };
  A._SplayTreeMap__SplayTree_MapMixin.prototype = {};
  A.Base64Codec.prototype = {
    get$encoder() {
      return B.C_Base64Encoder;
    }
  };
  A.Base64Encoder.prototype = {
    convert$1(input) {
      var t1;
      type$.List_int._as(input);
      t1 = J.getInterceptor$asx(input);
      if (t1.get$isEmpty(input))
        return "";
      t1 = new A._Base64Encoder("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/").encode$4(input, 0, t1.get$length(input), true);
      t1.toString;
      return A.String_String$fromCharCodes(t1, 0, null);
    }
  };
  A._Base64Encoder.prototype = {
    encode$4(bytes, start, end, isLast) {
      var t1, byteCount, fullChunks, bufferLength, output;
      type$.List_int._as(bytes);
      t1 = this._convert$_state;
      byteCount = (t1 & 3) + (end - start);
      fullChunks = B.JSInt_methods._tdivFast$1(byteCount, 3);
      bufferLength = fullChunks * 4;
      if (byteCount - fullChunks * 3 > 0)
        bufferLength += 4;
      output = new Uint8Array(bufferLength);
      this._convert$_state = A._Base64Encoder_encodeChunk(this._alphabet, bytes, start, end, true, output, 0, t1);
      if (bufferLength > 0)
        return output;
      return null;
    }
  };
  A.Base64Decoder.prototype = {
    convert$1(input) {
      var end, decoder, t1, t2;
      A._asString(input);
      end = A.RangeError_checkValidRange(0, null, input.length);
      if (0 === end)
        return new Uint8Array(0);
      decoder = new A._Base64Decoder();
      t1 = decoder.decode$3(input, 0, end);
      t1.toString;
      t2 = decoder._convert$_state;
      if (t2 < -1)
        A.throwExpression(A.FormatException$("Missing padding character", input, end));
      if (t2 > 0)
        A.throwExpression(A.FormatException$("Invalid length, must be multiple of four", input, end));
      decoder._convert$_state = -1;
      return t1;
    }
  };
  A._Base64Decoder.prototype = {
    decode$3(input, start, end) {
      var buffer, _this = this,
        t1 = _this._convert$_state;
      if (t1 < 0) {
        _this._convert$_state = A._Base64Decoder__checkPadding(input, start, end, t1);
        return null;
      }
      if (start === end)
        return new Uint8Array(0);
      buffer = A._Base64Decoder__allocateBuffer(input, start, end, t1);
      _this._convert$_state = A._Base64Decoder_decodeChunk(input, start, end, buffer, 0, _this._convert$_state);
      return buffer;
    }
  };
  A.Codec.prototype = {};
  A.Converter.prototype = {};
  A.JsonUnsupportedObjectError.prototype = {
    toString$0(_) {
      var safeString = A.Error_safeToString(this.unsupportedObject);
      return (this.cause != null ? "Converting object to an encodable object failed:" : "Converting object did not return an encodable object:") + " " + safeString;
    }
  };
  A.JsonCyclicError.prototype = {
    toString$0(_) {
      return "Cyclic error in JSON stringify";
    }
  };
  A.JsonCodec.prototype = {
    encode$1(value) {
      var t1 = A._JsonStringStringifier_stringify(value, this.get$encoder()._toEncodable, null);
      return t1;
    },
    get$encoder() {
      return B.JsonEncoder_null;
    }
  };
  A.JsonEncoder.prototype = {};
  A._JsonStringifier.prototype = {
    writeStringContent$1(s) {
      var t1, offset, i, charCode, t2, t3,
        $length = s.length;
      for (t1 = this._sink, offset = 0, i = 0; i < $length; ++i) {
        charCode = s.charCodeAt(i);
        if (charCode > 92) {
          if (charCode >= 55296) {
            t2 = charCode & 64512;
            if (t2 === 55296) {
              t3 = i + 1;
              t3 = !(t3 < $length && (s.charCodeAt(t3) & 64512) === 56320);
            } else
              t3 = false;
            if (!t3)
              if (t2 === 56320) {
                t2 = i - 1;
                t2 = !(t2 >= 0 && (s.charCodeAt(t2) & 64512) === 55296);
              } else
                t2 = false;
            else
              t2 = true;
            if (t2) {
              if (i > offset)
                t1._contents += B.JSString_methods.substring$2(s, offset, i);
              offset = i + 1;
              t2 = A.Primitives_stringFromCharCode(92);
              t1._contents += t2;
              t2 = A.Primitives_stringFromCharCode(117);
              t1._contents += t2;
              t2 = A.Primitives_stringFromCharCode(100);
              t1._contents += t2;
              t2 = charCode >>> 8 & 15;
              t2 = A.Primitives_stringFromCharCode(t2 < 10 ? 48 + t2 : 87 + t2);
              t1._contents += t2;
              t2 = charCode >>> 4 & 15;
              t2 = A.Primitives_stringFromCharCode(t2 < 10 ? 48 + t2 : 87 + t2);
              t1._contents += t2;
              t2 = charCode & 15;
              t2 = A.Primitives_stringFromCharCode(t2 < 10 ? 48 + t2 : 87 + t2);
              t1._contents += t2;
            }
          }
          continue;
        }
        if (charCode < 32) {
          if (i > offset)
            t1._contents += B.JSString_methods.substring$2(s, offset, i);
          offset = i + 1;
          t2 = A.Primitives_stringFromCharCode(92);
          t1._contents += t2;
          switch (charCode) {
            case 8:
              t2 = A.Primitives_stringFromCharCode(98);
              t1._contents += t2;
              break;
            case 9:
              t2 = A.Primitives_stringFromCharCode(116);
              t1._contents += t2;
              break;
            case 10:
              t2 = A.Primitives_stringFromCharCode(110);
              t1._contents += t2;
              break;
            case 12:
              t2 = A.Primitives_stringFromCharCode(102);
              t1._contents += t2;
              break;
            case 13:
              t2 = A.Primitives_stringFromCharCode(114);
              t1._contents += t2;
              break;
            default:
              t2 = A.Primitives_stringFromCharCode(117);
              t1._contents += t2;
              t2 = A.Primitives_stringFromCharCode(48);
              t1._contents += t2;
              t2 = A.Primitives_stringFromCharCode(48);
              t1._contents += t2;
              t2 = charCode >>> 4 & 15;
              t2 = A.Primitives_stringFromCharCode(t2 < 10 ? 48 + t2 : 87 + t2);
              t1._contents += t2;
              t2 = charCode & 15;
              t2 = A.Primitives_stringFromCharCode(t2 < 10 ? 48 + t2 : 87 + t2);
              t1._contents += t2;
              break;
          }
        } else if (charCode === 34 || charCode === 92) {
          if (i > offset)
            t1._contents += B.JSString_methods.substring$2(s, offset, i);
          offset = i + 1;
          t2 = A.Primitives_stringFromCharCode(92);
          t1._contents += t2;
          t2 = A.Primitives_stringFromCharCode(charCode);
          t1._contents += t2;
        }
      }
      if (offset === 0)
        t1._contents += s;
      else if (offset < $length)
        t1._contents += B.JSString_methods.substring$2(s, offset, $length);
    },
    _checkCycle$1(object) {
      var t1, t2, i, t3;
      for (t1 = this._seen, t2 = t1.length, i = 0; i < t2; ++i) {
        t3 = t1[i];
        if (object == null ? t3 == null : object === t3)
          throw A.wrapException(new A.JsonCyclicError(object, null));
      }
      B.JSArray_methods.add$1(t1, object);
    },
    writeObject$1(object) {
      var customJson, e, t1, exception, _this = this;
      if (_this.writeJsonValue$1(object))
        return;
      _this._checkCycle$1(object);
      try {
        customJson = _this._toEncodable.call$1(object);
        if (!_this.writeJsonValue$1(customJson)) {
          t1 = A.JsonUnsupportedObjectError$(object, null, _this.get$_partialResult());
          throw A.wrapException(t1);
        }
        t1 = _this._seen;
        if (0 >= t1.length)
          return A.ioore(t1, -1);
        t1.pop();
      } catch (exception) {
        e = A.unwrapException(exception);
        t1 = A.JsonUnsupportedObjectError$(object, e, _this.get$_partialResult());
        throw A.wrapException(t1);
      }
    },
    writeJsonValue$1(object) {
      var t1, t2, success, _this = this;
      if (typeof object == "number") {
        if (!isFinite(object))
          return false;
        t1 = _this._sink;
        t2 = B.JSNumber_methods.toString$0(object);
        t1._contents += t2;
        return true;
      } else if (object === true) {
        _this._sink._contents += "true";
        return true;
      } else if (object === false) {
        _this._sink._contents += "false";
        return true;
      } else if (object == null) {
        _this._sink._contents += "null";
        return true;
      } else if (typeof object == "string") {
        t1 = _this._sink;
        t1._contents += '"';
        _this.writeStringContent$1(object);
        t1._contents += '"';
        return true;
      } else if (type$.List_dynamic._is(object)) {
        _this._checkCycle$1(object);
        _this.writeList$1(object);
        t1 = _this._seen;
        if (0 >= t1.length)
          return A.ioore(t1, -1);
        t1.pop();
        return true;
      } else if (type$.Map_dynamic_dynamic._is(object)) {
        _this._checkCycle$1(object);
        success = _this.writeMap$1(object);
        t1 = _this._seen;
        if (0 >= t1.length)
          return A.ioore(t1, -1);
        t1.pop();
        return success;
      } else
        return false;
    },
    writeList$1(list) {
      var t2, i,
        t1 = this._sink;
      t1._contents += "[";
      t2 = J.getInterceptor$asx(list);
      if (t2.get$isNotEmpty(list)) {
        this.writeObject$1(t2.$index(list, 0));
        for (i = 1; i < t2.get$length(list); ++i) {
          t1._contents += ",";
          this.writeObject$1(t2.$index(list, i));
        }
      }
      t1._contents += "]";
    },
    writeMap$1(map) {
      var t1, keyValueList, i, t2, separator, t3, _this = this, _box_0 = {};
      if (map.get$isEmpty(map)) {
        _this._sink._contents += "{}";
        return true;
      }
      t1 = map.get$length(map) * 2;
      keyValueList = A.List_List$filled(t1, null, false, type$.nullable_Object);
      i = _box_0.i = 0;
      _box_0.allStringKeys = true;
      map.forEach$1(0, new A._JsonStringifier_writeMap_closure(_box_0, keyValueList));
      if (!_box_0.allStringKeys)
        return false;
      t2 = _this._sink;
      t2._contents += "{";
      for (separator = '"'; i < t1; i += 2, separator = ',"') {
        t2._contents += separator;
        _this.writeStringContent$1(A._asString(keyValueList[i]));
        t2._contents += '":';
        t3 = i + 1;
        if (!(t3 < t1))
          return A.ioore(keyValueList, t3);
        _this.writeObject$1(keyValueList[t3]);
      }
      t2._contents += "}";
      return true;
    }
  };
  A._JsonStringifier_writeMap_closure.prototype = {
    call$2(key, value) {
      var t1, t2;
      if (typeof key != "string")
        this._box_0.allStringKeys = false;
      t1 = this.keyValueList;
      t2 = this._box_0;
      B.JSArray_methods.$indexSet(t1, t2.i++, key);
      B.JSArray_methods.$indexSet(t1, t2.i++, value);
    },
    $signature: 17
  };
  A._JsonStringStringifier.prototype = {
    get$_partialResult() {
      var t1 = this._sink._contents;
      return t1.charCodeAt(0) == 0 ? t1 : t1;
    }
  };
  A.DateTime.prototype = {
    $eq(_, other) {
      if (other == null)
        return false;
      return other instanceof A.DateTime && this._core$_value === other._core$_value && this._microsecond === other._microsecond && this.isUtc === other.isUtc;
    },
    get$hashCode(_) {
      return A.Object_hash(this._core$_value, this._microsecond, B.C_SentinelValue, B.C_SentinelValue);
    },
    compareTo$1(_, other) {
      var r;
      type$.DateTime._as(other);
      r = B.JSInt_methods.compareTo$1(this._core$_value, other._core$_value);
      if (r !== 0)
        return r;
      return B.JSInt_methods.compareTo$1(this._microsecond, other._microsecond);
    },
    toString$0(_) {
      var _this = this,
        y = A.DateTime__fourDigits(A.Primitives_getYear(_this)),
        m = A.DateTime__twoDigits(A.Primitives_getMonth(_this)),
        d = A.DateTime__twoDigits(A.Primitives_getDay(_this)),
        h = A.DateTime__twoDigits(A.Primitives_getHours(_this)),
        min = A.DateTime__twoDigits(A.Primitives_getMinutes(_this)),
        sec = A.DateTime__twoDigits(A.Primitives_getSeconds(_this)),
        ms = A.DateTime__threeDigits(A.Primitives_getMilliseconds(_this)),
        t1 = _this._microsecond,
        us = t1 === 0 ? "" : A.DateTime__threeDigits(t1);
      t1 = y + "-" + m;
      if (_this.isUtc)
        return t1 + "-" + d + " " + h + ":" + min + ":" + sec + "." + ms + us + "Z";
      else
        return t1 + "-" + d + " " + h + ":" + min + ":" + sec + "." + ms + us;
    },
    toIso8601String$0() {
      var _this = this,
        y = A.Primitives_getYear(_this) >= -9999 && A.Primitives_getYear(_this) <= 9999 ? A.DateTime__fourDigits(A.Primitives_getYear(_this)) : A.DateTime__sixDigits(A.Primitives_getYear(_this)),
        m = A.DateTime__twoDigits(A.Primitives_getMonth(_this)),
        d = A.DateTime__twoDigits(A.Primitives_getDay(_this)),
        h = A.DateTime__twoDigits(A.Primitives_getHours(_this)),
        min = A.DateTime__twoDigits(A.Primitives_getMinutes(_this)),
        sec = A.DateTime__twoDigits(A.Primitives_getSeconds(_this)),
        ms = A.DateTime__threeDigits(A.Primitives_getMilliseconds(_this)),
        t1 = _this._microsecond,
        us = t1 === 0 ? "" : A.DateTime__threeDigits(t1);
      t1 = y + "-" + m;
      if (_this.isUtc)
        return t1 + "-" + d + "T" + h + ":" + min + ":" + sec + "." + ms + us + "Z";
      else
        return t1 + "-" + d + "T" + h + ":" + min + ":" + sec + "." + ms + us;
    },
    $isComparable: 1
  };
  A.DateTime_parse_parseIntOrZero.prototype = {
    call$1(matched) {
      if (matched == null)
        return 0;
      return A.int_parse(matched, null);
    },
    $signature: 18
  };
  A.DateTime_parse_parseMilliAndMicroseconds.prototype = {
    call$1(matched) {
      var t1, result, i;
      if (matched == null)
        return 0;
      for (t1 = matched.length, result = 0, i = 0; i < 6; ++i) {
        result *= 10;
        if (i < t1) {
          if (!(i < t1))
            return A.ioore(matched, i);
          result += matched.charCodeAt(i) ^ 48;
        }
      }
      return result;
    },
    $signature: 18
  };
  A.Duration.prototype = {
    $eq(_, other) {
      if (other == null)
        return false;
      return other instanceof A.Duration && this._duration === other._duration;
    },
    get$hashCode(_) {
      return B.JSInt_methods.get$hashCode(this._duration);
    },
    compareTo$1(_, other) {
      return B.JSInt_methods.compareTo$1(this._duration, type$.Duration._as(other)._duration);
    },
    toString$0(_) {
      var minutes, minutesPadding, seconds, secondsPadding,
        microseconds = this._duration,
        hours = B.JSInt_methods._tdivFast$1(microseconds, 3600000000);
      microseconds %= 3600000000;
      minutes = B.JSInt_methods._tdivFast$1(microseconds, 60000000);
      microseconds %= 60000000;
      minutesPadding = minutes < 10 ? "0" : "";
      seconds = B.JSInt_methods._tdivFast$1(microseconds, 1000000);
      secondsPadding = seconds < 10 ? "0" : "";
      return "" + hours + ":" + minutesPadding + minutes + ":" + secondsPadding + seconds + "." + B.JSString_methods.padLeft$2(B.JSInt_methods.toString$0(microseconds % 1000000), 6, "0");
    },
    $isComparable: 1
  };
  A.Error.prototype = {
    get$stackTrace() {
      return A.Primitives_extractStackTrace(this);
    }
  };
  A.AssertionError.prototype = {
    toString$0(_) {
      var t1 = this.message;
      if (t1 != null)
        return "Assertion failed: " + A.Error_safeToString(t1);
      return "Assertion failed";
    }
  };
  A.TypeError.prototype = {};
  A.ArgumentError.prototype = {
    get$_errorName() {
      return "Invalid argument" + (!this._hasValue ? "(s)" : "");
    },
    get$_errorExplanation() {
      return "";
    },
    toString$0(_) {
      var _this = this,
        $name = _this.name,
        nameString = $name == null ? "" : " (" + $name + ")",
        message = _this.message,
        messageString = message == null ? "" : ": " + A.S(message),
        prefix = _this.get$_errorName() + nameString + messageString;
      if (!_this._hasValue)
        return prefix;
      return prefix + _this.get$_errorExplanation() + ": " + A.Error_safeToString(_this.get$invalidValue());
    },
    get$invalidValue() {
      return this.invalidValue;
    }
  };
  A.RangeError.prototype = {
    get$invalidValue() {
      return A._asNumQ(this.invalidValue);
    },
    get$_errorName() {
      return "RangeError";
    },
    get$_errorExplanation() {
      var explanation,
        start = this.start,
        end = this.end;
      if (start == null)
        explanation = end != null ? ": Not less than or equal to " + A.S(end) : "";
      else if (end == null)
        explanation = ": Not greater than or equal to " + A.S(start);
      else if (end > start)
        explanation = ": Not in inclusive range " + A.S(start) + ".." + A.S(end);
      else
        explanation = end < start ? ": Valid value range is empty" : ": Only valid value is " + A.S(start);
      return explanation;
    }
  };
  A.IndexError.prototype = {
    get$invalidValue() {
      return A._asInt(this.invalidValue);
    },
    get$_errorName() {
      return "RangeError";
    },
    get$_errorExplanation() {
      if (A._asInt(this.invalidValue) < 0)
        return ": index must not be negative";
      var t1 = this.length;
      if (t1 === 0)
        return ": no indices are valid";
      return ": index should be less than " + t1;
    },
    get$length(receiver) {
      return this.length;
    }
  };
  A.UnsupportedError.prototype = {
    toString$0(_) {
      return "Unsupported operation: " + this.message;
    }
  };
  A.UnimplementedError.prototype = {
    toString$0(_) {
      return "UnimplementedError: " + this.message;
    }
  };
  A.StateError.prototype = {
    toString$0(_) {
      return "Bad state: " + this.message;
    }
  };
  A.ConcurrentModificationError.prototype = {
    toString$0(_) {
      var t1 = this.modifiedObject;
      if (t1 == null)
        return "Concurrent modification during iteration.";
      return "Concurrent modification during iteration: " + A.Error_safeToString(t1) + ".";
    }
  };
  A.OutOfMemoryError.prototype = {
    toString$0(_) {
      return "Out of Memory";
    },
    get$stackTrace() {
      return null;
    },
    $isError: 1
  };
  A.StackOverflowError.prototype = {
    toString$0(_) {
      return "Stack Overflow";
    },
    get$stackTrace() {
      return null;
    },
    $isError: 1
  };
  A._Exception.prototype = {
    toString$0(_) {
      return "Exception: " + this.message;
    },
    $isException: 1
  };
  A.FormatException.prototype = {
    toString$0(_) {
      var t1, lineEnd, lineNum, lineStart, previousCharWasCR, i, char, prefix, postfix, end, start,
        message = this.message,
        report = "" !== message ? "FormatException: " + message : "FormatException",
        offset = this.offset,
        source = this.source;
      if (typeof source == "string") {
        if (offset != null)
          t1 = offset < 0 || offset > source.length;
        else
          t1 = false;
        if (t1)
          offset = null;
        if (offset == null) {
          if (source.length > 78)
            source = B.JSString_methods.substring$2(source, 0, 75) + "...";
          return report + "\n" + source;
        }
        for (lineEnd = source.length, lineNum = 1, lineStart = 0, previousCharWasCR = false, i = 0; i < offset; ++i) {
          if (!(i < lineEnd))
            return A.ioore(source, i);
          char = source.charCodeAt(i);
          if (char === 10) {
            if (lineStart !== i || !previousCharWasCR)
              ++lineNum;
            lineStart = i + 1;
            previousCharWasCR = false;
          } else if (char === 13) {
            ++lineNum;
            lineStart = i + 1;
            previousCharWasCR = true;
          }
        }
        report = lineNum > 1 ? report + (" (at line " + lineNum + ", character " + (offset - lineStart + 1) + ")\n") : report + (" (at character " + (offset + 1) + ")\n");
        for (i = offset; i < lineEnd; ++i) {
          if (!(i >= 0))
            return A.ioore(source, i);
          char = source.charCodeAt(i);
          if (char === 10 || char === 13) {
            lineEnd = i;
            break;
          }
        }
        prefix = "";
        if (lineEnd - lineStart > 78) {
          postfix = "...";
          if (offset - lineStart < 75) {
            end = lineStart + 75;
            start = lineStart;
          } else {
            if (lineEnd - offset < 75) {
              start = lineEnd - 75;
              end = lineEnd;
              postfix = "";
            } else {
              start = offset - 36;
              end = offset + 36;
            }
            prefix = "...";
          }
        } else {
          end = lineEnd;
          start = lineStart;
          postfix = "";
        }
        return report + prefix + B.JSString_methods.substring$2(source, start, end) + postfix + "\n" + B.JSString_methods.$mul(" ", offset - start + prefix.length) + "^\n";
      } else
        return offset != null ? report + (" (at offset " + A.S(offset) + ")") : report;
    },
    $isException: 1
  };
  A.Iterable.prototype = {
    cast$1$0(_, $R) {
      return A.CastIterable_CastIterable(this, A._instanceType(this)._eval$1("Iterable.E"), $R);
    },
    map$1$1(_, toElement, $T) {
      var t1 = A._instanceType(this);
      return A.MappedIterable_MappedIterable(this, t1._bind$1($T)._eval$1("1(Iterable.E)")._as(toElement), t1._eval$1("Iterable.E"), $T);
    },
    contains$1(_, element) {
      var t1;
      for (t1 = this.get$iterator(this); t1.moveNext$0();)
        if (J.$eq$(t1.get$current(), element))
          return true;
      return false;
    },
    forEach$1(_, action) {
      var t1;
      A._instanceType(this)._eval$1("~(Iterable.E)")._as(action);
      for (t1 = this.get$iterator(this); t1.moveNext$0();)
        action.call$1(t1.get$current());
    },
    toList$1$growable(_, growable) {
      var t1 = A._instanceType(this)._eval$1("Iterable.E");
      if (growable)
        t1 = A.List_List$_of(this, t1);
      else {
        t1 = A.List_List$_of(this, t1);
        t1.$flags = 1;
        t1 = t1;
      }
      return t1;
    },
    toList$0(_) {
      return this.toList$1$growable(0, true);
    },
    get$length(_) {
      var count,
        it = this.get$iterator(this);
      for (count = 0; it.moveNext$0();)
        ++count;
      return count;
    },
    get$isEmpty(_) {
      return !this.get$iterator(this).moveNext$0();
    },
    get$isNotEmpty(_) {
      return !this.get$isEmpty(this);
    },
    take$1(_, count) {
      return A.TakeIterable_TakeIterable(this, count, A._instanceType(this)._eval$1("Iterable.E"));
    },
    skip$1(_, count) {
      return A.SkipIterable_SkipIterable(this, count, A._instanceType(this)._eval$1("Iterable.E"));
    },
    get$first(_) {
      var it = this.get$iterator(this);
      if (!it.moveNext$0())
        throw A.wrapException(A.IterableElementError_noElement());
      return it.get$current();
    },
    elementAt$1(_, index) {
      var iterator, skipCount;
      A.RangeError_checkNotNegative(index, "index");
      iterator = this.get$iterator(this);
      for (skipCount = index; iterator.moveNext$0();) {
        if (skipCount === 0)
          return iterator.get$current();
        --skipCount;
      }
      throw A.wrapException(A.IndexError$withLength(index, index - skipCount, this, null, "index"));
    },
    toString$0(_) {
      return A.Iterable_iterableToShortString(this, "(", ")");
    }
  };
  A._GeneratorIterable.prototype = {
    elementAt$1(_, index) {
      var t1 = this.length;
      if (0 > index || index >= t1)
        A.throwExpression(A.IndexError$withLength(index, t1, this, null, "index"));
      return this._generator.call$1(index);
    },
    get$length(receiver) {
      return this.length;
    }
  };
  A.MapEntry.prototype = {
    toString$0(_) {
      return "MapEntry(" + A.S(this.key) + ": " + A.S(this.value) + ")";
    }
  };
  A.Null.prototype = {
    get$hashCode(_) {
      return A.Object.prototype.get$hashCode.call(this, 0);
    },
    toString$0(_) {
      return "null";
    }
  };
  A.Object.prototype = {$isObject: 1,
    $eq(_, other) {
      return this === other;
    },
    get$hashCode(_) {
      return A.Primitives_objectHashCode(this);
    },
    toString$0(_) {
      return "Instance of '" + A.Primitives_objectTypeName(this) + "'";
    },
    get$runtimeType(_) {
      return A.getRuntimeTypeOfDartObject(this);
    },
    toString() {
      return this.toString$0(this);
    }
  };
  A._StringStackTrace.prototype = {
    toString$0(_) {
      return "";
    },
    $isStackTrace: 1
  };
  A.Stopwatch.prototype = {
    get$elapsedMicroseconds() {
      var ticks,
        t1 = this._stop;
      if (t1 == null)
        t1 = $.Primitives_timerTicks.call$0();
      ticks = t1 - this._core$_start;
      if ($.$get$Stopwatch__frequency() === 1000000)
        return ticks;
      return ticks * 1000;
    },
    start$0() {
      var _this = this,
        $stop = _this._stop;
      if ($stop != null) {
        _this._core$_start = _this._core$_start + ($.Primitives_timerTicks.call$0() - $stop);
        _this._stop = null;
      }
    }
  };
  A.StringBuffer.prototype = {
    get$length(_) {
      return this._contents.length;
    },
    toString$0(_) {
      var t1 = this._contents;
      return t1.charCodeAt(0) == 0 ? t1 : t1;
    },
    $isStringSink: 1
  };
  A.jsify__convert.prototype = {
    call$1(o) {
      var t1, convertedMap, key, convertedList;
      if (A._noJsifyRequired(o))
        return o;
      t1 = this._convertedObjects;
      if (t1.containsKey$1(o))
        return t1.$index(0, o);
      if (type$.Map_dynamic_dynamic._is(o)) {
        convertedMap = {};
        t1.$indexSet(0, o, convertedMap);
        for (t1 = o.get$keys(), t1 = t1.get$iterator(t1); t1.moveNext$0();) {
          key = t1.get$current();
          convertedMap[key] = this.call$1(o.$index(0, key));
        }
        return convertedMap;
      } else if (type$.Iterable_dynamic._is(o)) {
        convertedList = [];
        t1.$indexSet(0, o, convertedList);
        B.JSArray_methods.addAll$1(convertedList, J.map$1$1$ax(o, this, type$.dynamic));
        return convertedList;
      } else
        return o;
    },
    $signature: 45
  };
  A._JSRandom.prototype = {
    nextInt$1(max) {
      if (max <= 0 || max > 4294967296)
        throw A.wrapException(A.RangeError$("max must be in range 0 < max \u2264 2^32, was " + max));
      return Math.random() * max >>> 0;
    }
  };
  A.DefaultEquality.prototype = {$isEquality: 1};
  A.IterableEquality.prototype = {
    equals$2(elements1, elements2) {
      var it1, it2, hasNext,
        t1 = this.$ti._eval$1("Iterable<1>?");
      t1._as(elements1);
      t1._as(elements2);
      if (elements1 === elements2)
        return true;
      it1 = J.get$iterator$ax(elements1);
      it2 = J.get$iterator$ax(elements2);
      for (t1 = this._elementEquality; true;) {
        hasNext = it1.moveNext$0();
        if (hasNext !== it2.moveNext$0())
          return false;
        if (!hasNext)
          return true;
        if (!t1.equals$2(it1.get$current(), it2.get$current()))
          return false;
      }
    },
    hash$1(elements) {
      var t1, t2, hash;
      this.$ti._eval$1("Iterable<1>?")._as(elements);
      for (t1 = J.get$iterator$ax(elements), t2 = this._elementEquality, hash = 0; t1.moveNext$0();) {
        hash = hash + t2.hash$1(t1.get$current()) & 2147483647;
        hash = hash + (hash << 10 >>> 0) & 2147483647;
        hash ^= hash >>> 6;
      }
      hash = hash + (hash << 3 >>> 0) & 2147483647;
      hash ^= hash >>> 11;
      return hash + (hash << 15 >>> 0) & 2147483647;
    },
    $isEquality: 1
  };
  A.ListEquality.prototype = {
    equals$2(list1, list2) {
      var $length, t2, t3, i,
        t1 = this.$ti._eval$1("List<1>?");
      t1._as(list1);
      t1._as(list2);
      if (list1 === list2)
        return true;
      t1 = J.getInterceptor$asx(list1);
      $length = t1.get$length(list1);
      t2 = J.getInterceptor$asx(list2);
      if ($length !== t2.get$length(list2))
        return false;
      for (t3 = this._elementEquality, i = 0; i < $length; ++i)
        if (!t3.equals$2(t1.$index(list1, i), t2.$index(list2, i)))
          return false;
      return true;
    },
    hash$1(list) {
      var t1, t2, hash, i;
      this.$ti._eval$1("List<1>?")._as(list);
      for (t1 = J.getInterceptor$asx(list), t2 = this._elementEquality, hash = 0, i = 0; i < t1.get$length(list); ++i) {
        hash = hash + t2.hash$1(t1.$index(list, i)) & 2147483647;
        hash = hash + (hash << 10 >>> 0) & 2147483647;
        hash ^= hash >>> 6;
      }
      hash = hash + (hash << 3 >>> 0) & 2147483647;
      hash ^= hash >>> 11;
      return hash + (hash << 15 >>> 0) & 2147483647;
    },
    $isEquality: 1
  };
  A._UnorderedEquality.prototype = {
    equals$2(elements1, elements2) {
      var counts, $length, e, count,
        t1 = A._instanceType(this),
        t2 = t1._eval$1("_UnorderedEquality.T?");
      t2._as(elements1);
      t2._as(elements2);
      if (elements1 === elements2)
        return true;
      t2 = this._elementEquality;
      counts = A.HashMap_HashMap(t1._eval$1("bool(_UnorderedEquality.E,_UnorderedEquality.E)")._as(t2.get$equals()), t1._eval$1("int(_UnorderedEquality.E)")._as(t2.get$hash()), t2.get$isValidKey(), t1._eval$1("_UnorderedEquality.E"), type$.int);
      for (t1 = J.get$iterator$ax(elements1), $length = 0; t1.moveNext$0();) {
        e = t1.get$current();
        count = counts.$index(0, e);
        counts.$indexSet(0, e, (count == null ? 0 : count) + 1);
        ++$length;
      }
      for (t1 = J.get$iterator$ax(elements2); t1.moveNext$0();) {
        e = t1.get$current();
        count = counts.$index(0, e);
        if (count == null || count === 0)
          return false;
        counts.$indexSet(0, e, count - 1);
        --$length;
      }
      return $length === 0;
    },
    hash$1(elements) {
      var t1, t2, hash;
      A._instanceType(this)._eval$1("_UnorderedEquality.T?")._as(elements);
      for (t1 = J.get$iterator$ax(elements), t2 = this._elementEquality, hash = 0; t1.moveNext$0();)
        hash = hash + t2.hash$1(t1.get$current()) & 2147483647;
      hash = hash + (hash << 3 >>> 0) & 2147483647;
      hash ^= hash >>> 11;
      return hash + (hash << 15 >>> 0) & 2147483647;
    },
    $isEquality: 1
  };
  A.SetEquality.prototype = {};
  A._MapEntry.prototype = {
    get$hashCode(_) {
      var t1 = this.equality;
      return 3 * t1._keyEquality.hash$1(this.key) + 7 * t1._valueEquality.hash$1(this.value) & 2147483647;
    },
    $eq(_, other) {
      var t1;
      if (other == null)
        return false;
      if (other instanceof A._MapEntry) {
        t1 = this.equality;
        t1 = t1._keyEquality.equals$2(this.key, other.key) && t1._valueEquality.equals$2(this.value, other.value);
      } else
        t1 = false;
      return t1;
    }
  };
  A.MapEquality.prototype = {
    equals$2(map1, map2) {
      var equalElementCounts, key, entry, count,
        t1 = this.$ti._eval$1("Map<1,2>?");
      t1._as(map1);
      t1._as(map2);
      if (map1 === map2)
        return true;
      if (map1.get$length(map1) !== map2.get$length(map2))
        return false;
      equalElementCounts = A.HashMap_HashMap(null, null, null, type$._MapEntry, type$.int);
      for (t1 = map1.get$keys(), t1 = t1.get$iterator(t1); t1.moveNext$0();) {
        key = t1.get$current();
        entry = new A._MapEntry(this, key, map1.$index(0, key));
        count = equalElementCounts.$index(0, entry);
        equalElementCounts.$indexSet(0, entry, (count == null ? 0 : count) + 1);
      }
      for (t1 = map2.get$keys(), t1 = t1.get$iterator(t1); t1.moveNext$0();) {
        key = t1.get$current();
        entry = new A._MapEntry(this, key, map2.$index(0, key));
        count = equalElementCounts.$index(0, entry);
        if (count == null || count === 0)
          return false;
        equalElementCounts.$indexSet(0, entry, count - 1);
      }
      return true;
    },
    hash$1(map) {
      var t2, t3, t4, hash, key, keyHash, t5,
        t1 = this.$ti;
      t1._eval$1("Map<1,2>?")._as(map);
      for (t2 = map.get$keys(), t2 = t2.get$iterator(t2), t3 = this._keyEquality, t4 = this._valueEquality, t1 = t1._rest[1], hash = 0; t2.moveNext$0();) {
        key = t2.get$current();
        keyHash = t3.hash$1(key);
        t5 = map.$index(0, key);
        hash = hash + 3 * keyHash + 7 * t4.hash$1(t5 == null ? t1._as(t5) : t5) & 2147483647;
      }
      hash = hash + (hash << 3 >>> 0) & 2147483647;
      hash ^= hash >>> 11;
      return hash + (hash << 15 >>> 0) & 2147483647;
    },
    $isEquality: 1
  };
  A.DeepCollectionEquality.prototype = {
    equals$2(e1, e2) {
      var _this = this,
        t1 = type$.Set_dynamic;
      if (t1._is(e1))
        return t1._is(e2) && new A.SetEquality(_this, type$.SetEquality_dynamic).equals$2(e1, e2);
      t1 = type$.Map_dynamic_dynamic;
      if (t1._is(e1))
        return t1._is(e2) && new A.MapEquality(_this, _this, type$.MapEquality_dynamic_dynamic).equals$2(e1, e2);
      t1 = type$.List_dynamic;
      if (t1._is(e1))
        return t1._is(e2) && new A.ListEquality(_this, type$.ListEquality_dynamic).equals$2(e1, e2);
      t1 = type$.Iterable_dynamic;
      if (t1._is(e1))
        return t1._is(e2) && new A.IterableEquality(_this, type$.IterableEquality_dynamic).equals$2(e1, e2);
      return J.$eq$(e1, e2);
    },
    hash$1(o) {
      var _this = this;
      if (type$.Set_dynamic._is(o))
        return new A.SetEquality(_this, type$.SetEquality_dynamic).hash$1(o);
      if (type$.Map_dynamic_dynamic._is(o))
        return new A.MapEquality(_this, _this, type$.MapEquality_dynamic_dynamic).hash$1(o);
      if (type$.List_dynamic._is(o))
        return new A.ListEquality(_this, type$.ListEquality_dynamic).hash$1(o);
      if (type$.Iterable_dynamic._is(o))
        return new A.IterableEquality(_this, type$.IterableEquality_dynamic).hash$1(o);
      return J.get$hashCode$(o);
    },
    isValidKey$1(o) {
      return true;
    },
    $isEquality: 1
  };
  A.ObjectStore.prototype = {
    toString$0(_) {
      return this.get$name() + " (key " + A.S(this.get$keyPath()) + " auto " + this.get$autoIncrement() + ")";
    }
  };
  A.Request.prototype = {};
  A.OpenDBRequest.prototype = {};
  A.DatabaseError.prototype = {
    get$stackTrace() {
      var t1 = A.Error.prototype.get$stackTrace.call(this);
      return t1;
    },
    toString$0(_) {
      return this._idb$_message;
    }
  };
  A.DatabaseReadOnlyError.prototype = {};
  A.DatabaseStoreNotFoundError.prototype = {};
  A.DatabaseTransactionStoreNotFoundError.prototype = {};
  A.IdbDatabaseBase.prototype = {
    get$factory() {
      return this._factory;
    },
    $isDatabase: 1
  };
  A.IdbVersionChangeEventBase.prototype = {$isVersionChangeEvent: 1};
  A.IdbFactoryBase.prototype = {$isIdbFactory: 1};
  A.TransactionWithMetaMixin.prototype = {};
  A.IdbTransactionMeta.prototype = {
    checkObjectStore$1(storeName) {
      if (!B.JSArray_methods.contains$1(this.storeNames, storeName))
        throw A.wrapException(new A.DatabaseTransactionStoreNotFoundError("NotFoundError: store '" + storeName + "' not found in transaction."));
    },
    toString$0(_) {
      return this.mode + " " + A.S(this.storeNames);
    }
  };
  A.IdbVersionChangeTransactionMeta.prototype = {
    checkObjectStore$1(storeName) {
    }
  };
  A.DatabaseWithMetaMixin.prototype = {
    toString$0(_) {
      return A.MapBase_mapToString(this.meta.toDebugMap$0());
    }
  };
  A.IdbDatabaseMeta.prototype = {
    onUpgradeNeeded$1(action) {
      return this.onUpgradeNeeded$body$IdbDatabaseMeta(type$.dynamic_Function._as(action));
    },
    onUpgradeNeeded$body$IdbDatabaseMeta(action) {
      var $async$goto = 0,
        $async$completer = A._makeAsyncAwaitCompleter(type$.dynamic),
        $async$handler = 1, $async$errorStack = [], $async$next = [], $async$self = this, result, exception, t1, t2, t3, $async$exception;
      var $async$onUpgradeNeeded$1 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1) {
          $async$errorStack.push($async$result);
          $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = type$.String;
              t2 = type$.List_IdbIndexMeta;
              t3 = type$.IdbObjectStoreMeta;
              $async$self._versionChangeTransaction = new A.IdbVersionChangeTransactionMeta(A.LinkedHashMap_LinkedHashMap$_empty(t1, t2), A.LinkedHashMap_LinkedHashMap$_empty(t1, t2), A.LinkedHashSet_LinkedHashSet(t3), A.LinkedHashSet_LinkedHashSet(t3), A.LinkedHashSet_LinkedHashSet(t3), "readwrite", A._setArrayType([], type$.JSArray_String));
              $async$handler = 3;
              result = action.call$0();
              $async$goto = result instanceof A._Future ? 6 : 7;
              break;
            case 6:
              // then
              $async$goto = 8;
              return A._asyncAwait(result, $async$onUpgradeNeeded$1);
            case 8:
              // returning from await.
            case 7:
              // join
              $async$next.push(5);
              // goto finally
              $async$goto = 4;
              break;
            case 3:
              // catch
              $async$handler = 2;
              $async$exception = $async$errorStack.pop();
              throw $async$exception;
              $async$next.push(5);
              // goto finally
              $async$goto = 4;
              break;
            case 2:
              // uncaught
              $async$next = [1];
            case 4:
              // finally
              $async$handler = 1;
              $async$self._versionChangeTransaction = null;
              // goto the next finally handler
              $async$goto = $async$next.pop();
              break;
            case 5:
              // after finally
              // implicit return
              return A._asyncReturn(null, $async$completer);
            case 1:
              // rethrow
              return A._asyncRethrow($async$errorStack.at(-1), $async$completer);
          }
      });
      return A._asyncStartSync($async$onUpgradeNeeded$1, $async$completer);
    },
    transaction$2(storeNameOrStoreNames, mode) {
      if (!this._stores.containsKey$1(storeNameOrStoreNames))
        throw A.wrapException(A.DatabaseStoreNotFoundError$(A.DatabaseStoreNotFoundError_storeMessage(storeNameOrStoreNames)));
      return new A.IdbTransactionMeta(mode, A._setArrayType([storeNameOrStoreNames], type$.JSArray_String));
    },
    toDebugMap$0() {
      return A.LinkedHashMap_LinkedHashMap$_literal(["stores", this._stores, "version", this.version], type$.String, type$.nullable_Object);
    },
    toString$0(_) {
      return A.MapBase_mapToString(this.toDebugMap$0());
    },
    get$hashCode(_) {
      var t1 = this.version;
      t1.toString;
      return t1;
    },
    $eq(_, other) {
      if (other == null)
        return false;
      if (other instanceof A.IdbDatabaseMeta)
        return this.version == other.version;
      return false;
    },
    set$version(version) {
      this.version = A._asIntQ(version);
    }
  };
  A.ObjectStoreWithMetaMixin.prototype = {
    get$keyPath() {
      return this.meta.keyPath;
    },
    get$autoIncrement() {
      return this.meta.autoIncrement;
    },
    get$name() {
      return this.meta.name;
    }
  };
  A.IdbObjectStoreMeta.prototype = {
    IdbObjectStoreMeta$4($name, keyPath, autoIncrement, indecies) {
      var t1, t2, _i, indexMeta;
      if (indecies != null)
        for (t1 = indecies.length, t2 = this._indecies, _i = 0; _i < indecies.length; indecies.length === t1 || (0, A.throwConcurrentModificationError)(indecies), ++_i) {
          indexMeta = indecies[_i];
          t2.$indexSet(0, indexMeta.name, indexMeta);
        }
    },
    toMap$0() {
      var t2, indecies, indexMetas, _i, _this = this,
        map = A.LinkedHashMap_LinkedHashMap$_literal(["name", _this.name], type$.String, type$.nullable_Object),
        t1 = _this.keyPath;
      if (t1 != null)
        map.$indexSet(0, "keyPath", t1);
      if (_this.autoIncrement)
        map.$indexSet(0, "autoIncrement", true);
      t1 = _this._indecies;
      t2 = A._instanceType(t1)._eval$1("LinkedHashMapValuesIterable<2>");
      if (!new A.LinkedHashMapValuesIterable(t1, t2).get$isEmpty(0)) {
        indecies = A._setArrayType([], type$.JSArray_Map_dynamic_dynamic);
        indexMetas = A.List_List$from(new A.LinkedHashMapValuesIterable(t1, t2), true, type$.IdbIndexMeta);
        B.JSArray_methods.sort$1(indexMetas, new A.IdbObjectStoreMeta_toMap_closure());
        for (t1 = indexMetas.length, _i = 0; _i < indexMetas.length; indexMetas.length === t1 || (0, A.throwConcurrentModificationError)(indexMetas), ++_i)
          B.JSArray_methods.add$1(indecies, indexMetas[_i].toMap$0());
        map.$indexSet(0, "indecies", indecies);
      }
      return map;
    },
    toString$0(_) {
      return A.MapBase_mapToString(this.toMap$0());
    },
    get$hashCode(_) {
      return B.JSString_methods.get$hashCode(this.name);
    },
    $eq(_, other) {
      if (other == null)
        return false;
      if (other instanceof A.IdbObjectStoreMeta)
        return B.C_DeepCollectionEquality.equals$2(this.toMap$0(), other.toMap$0());
      return false;
    }
  };
  A.IdbObjectStoreMeta_toMap_closure.prototype = {
    call$2(meta1, meta2) {
      var t1 = type$.IdbIndexMeta;
      return B.JSString_methods.compareTo$1(t1._as(meta1).name, t1._as(meta2).name);
    },
    $signature: 67
  };
  A.IdbCursorMeta.prototype = {
    IdbCursorMeta$4(key, range, direction, autoAdvance) {
      switch ("next") {
        case "prev":
          this.__IdbCursorMeta__ascending_A = false;
          break;
        case "next":
          this.__IdbCursorMeta__ascending_A = true;
          break;
        default:
          throw A.wrapException(A.ArgumentError$("direction 'next' not supported", null));
      }
    },
    toString$0(_) {
      var map,
        t1 = this.__IdbCursorMeta__ascending_A;
      t1 === $ && A.throwLateFieldNI("_ascending");
      map = A.LinkedHashMap_LinkedHashMap$_literal(["direction", t1 ? "next" : "prev"], type$.String, type$.nullable_Object);
      return A.MapBase_mapToString(map);
    }
  };
  A.IdbIndexMeta.prototype = {
    toMap$0() {
      var keyPath, map, _this = this,
        t1 = _this.keyPath;
      if (type$.Iterable_dynamic._is(t1)) {
        t1 = new A.CastList(t1, A._arrayInstanceType(t1)._eval$1("CastList<1,String>"));
        keyPath = t1.toList$0(t1);
      } else
        keyPath = J.toString$0$(t1);
      map = A.LinkedHashMap_LinkedHashMap$_literal(["name", _this.name, "keyPath", keyPath], type$.String, type$.nullable_Object);
      if (_this.unique)
        map.$indexSet(0, "unique", true);
      if (_this.multiEntry)
        map.$indexSet(0, "multiEntry", true);
      return map;
    },
    toString$0(_) {
      return A.MapBase_mapToString(this.toMap$0());
    },
    get$hashCode(_) {
      return B.JSString_methods.get$hashCode(this.name);
    },
    $eq(_, other) {
      if (other == null)
        return false;
      if (other instanceof A.IdbIndexMeta)
        return B.C_DeepCollectionEquality.equals$2(this.toMap$0(), other.toMap$0());
      return false;
    }
  };
  A.IdbTransactionBase.prototype = {$isTransaction0: 1};
  A.IdbTransactionMixin.prototype = {};
  A._IdbTransactionBase_Object_IdbTransactionMixin.prototype = {};
  A._cloneMap_closure.prototype = {
    call$2(key, value) {
      this.map.$indexSet(0, A._asString(key), A._cloneValue(value));
    },
    $signature: 4
  };
  A.IdbValueMapExt_getKeyValue_closure.prototype = {
    call$1(element) {
      return element == null;
    },
    $signature: 3
  };
  A.IdbCursor.prototype = {};
  A.IdbCursorWithValue.prototype = {};
  A.DatabaseException0.prototype = {
    toString$0(_) {
      return "DatabaseException: " + this._database_exception$_message;
    },
    $isException: 1
  };
  A.DOMStringListExt_toStringIterable_closure.prototype = {
    call$1(i) {
      var t1 = A._asStringQ(this._this.item(A._asInt(i)));
      t1.toString;
      return t1;
    },
    $signature: 73
  };
  A.IDBRequestExt_handleOnError_closure.prototype = {
    call$1($event) {
      var t1, t2;
      type$.JSObject._as($event);
      t1 = this.completer;
      if ((t1.future._state & 30) === 0) {
        t2 = type$.nullable_JSObject._as(this._this.error);
        t1.completeError$1(new A.DatabaseErrorNative(A._asString(t2.name), A._asString(t2.message)));
      }
    },
    $signature: 2
  };
  A.IDBRequestExt_handleOnSuccess_closure.prototype = {
    call$1($event) {
      var t1;
      type$.JSObject._as($event);
      t1 = this.completer;
      if ((t1.future._state & 30) === 0)
        t1.complete$1(this._this.result);
    },
    $signature: 2
  };
  A.IDBRequestExt_dartFutureNullable_closure.prototype = {
    call$1(value) {
      var t1 = value == null ? null : A.IDBDartifyExtension_dartifyValueStrict(value);
      return this.T._as(t1);
    },
    $signature() {
      return this.T._eval$1("0(Object?)");
    }
  };
  A.IDBRequestExt_dartFuture_closure.prototype = {
    call$1(value) {
      value.toString;
      return this.T._as(A.IDBDartifyExtension_dartifyValueStrict(value));
    },
    $signature() {
      return this.T._eval$1("0(Object?)");
    }
  };
  A.IDBJsifyExtension_jsifyValueStrict_closure.prototype = {
    call$2(key, value) {
      var t1;
      A._asString(key);
      t1 = value == null ? null : A.IDBJsifyExtension_jsifyValueStrict(value);
      this.jsObject[key] = t1;
    },
    $signature: 4
  };
  A.IDBDartifyExtension_dartifyStringOrStringList_closure.prototype = {
    call$1(e) {
      return A.IDBDartifyExtension_dartifyStringOrStringList(e == null ? type$.Object._as(e) : e);
    },
    $signature: 80
  };
  A.CursorWithValueNative.prototype = {
    get$value() {
      var t1 = this._cwv.value;
      t1.toString;
      return A.IDBDartifyExtension_dartifyValueStrict(t1);
    },
    get$key() {
      var t1 = this._cwv.key;
      t1.toString;
      return A.IDBDartifyExtension_dartifyValueStrict(t1);
    },
    toString$0(_) {
      var t3,
        t1 = this._cwv,
        t2 = t1.primaryKey;
      t2.toString;
      t2 = A.logTruncateAny(A.IDBDartifyExtension_dartifyValueStrict(t2));
      t3 = t1.key;
      t3.toString;
      t3 = A.logTruncateAny(A.IDBDartifyExtension_dartifyValueStrict(t3));
      t1 = t1.value;
      t1.toString;
      return "CursorWithValue(" + t2 + ", " + t3 + ", " + A.logTruncateAny(A.IDBDartifyExtension_dartifyValueStrict(t1));
    }
  };
  A.VersionChangeEventNative.prototype = {
    get$target() {
      var t1, t2, t3, t4, _this = this,
        value = _this.__VersionChangeEventNative_request_AI;
      if (value === $) {
        t1 = _this.get$database();
        if (_this.__VersionChangeEventNative_transaction_AI === $) {
          t2 = _this.get$database();
          t3 = type$.nullable_JSObject;
          t4 = t3._as(_this.idbVersionChangeEvent.target);
          if (t4 == null)
            t4 = type$.JSObject._as(t4);
          t4 = t3._as(t4.transaction);
          t4.toString;
          _this.__VersionChangeEventNative_transaction_AI = new A.TransactionNative(t4, t2);
        }
        value = _this.__VersionChangeEventNative_request_AI = new A.OpenDBRequest(t1);
      }
      return value;
    },
    get$database() {
      var t1, _this = this,
        value = _this.__VersionChangeEventNative_database_AI;
      if (value === $) {
        t1 = type$.nullable_JSObject._as(_this.idbVersionChangeEvent.target);
        if (t1 == null)
          t1 = type$.JSObject._as(t1);
        value = _this.__VersionChangeEventNative_database_AI = new A.DatabaseNative(type$.JSObject._as(t1.result), _this.factory);
      }
      return value;
    }
  };
  A.DatabaseNative.prototype = {
    createObjectStore$2$keyPath($name, keyPath) {
      var t1 = A.catchNativeError(new A.DatabaseNative_createObjectStore_closure(this, $name, keyPath, null), type$.nullable_ObjectStore);
      t1.toString;
      return t1;
    },
    transaction$2(storeNameOrStoreNames, mode) {
      var e, t1, exception;
      try {
        t1 = A.catchNativeError(new A.DatabaseNative_transaction_closure(this, storeNameOrStoreNames, mode), type$.nullable_TransactionNativeBase);
        t1.toString;
        return t1;
      } catch (exception) {
        e = A.unwrapException(exception);
        throw exception;
      }
    },
    get$objectStoreNames() {
      var t1 = A.catchNativeError(new A.DatabaseNative_objectStoreNames_closure(this), type$.nullable_Iterable_String);
      t1.toString;
      return t1;
    },
    get$name() {
      var t1 = A.catchNativeError(new A.DatabaseNative_name_closure(this), type$.nullable_String);
      t1.toString;
      return t1;
    },
    toString$0(_) {
      return "DatabaseNative(" + this.get$name() + ")";
    }
  };
  A.DatabaseNative_createObjectStore_closure.prototype = {
    call$0() {
      var t1 = A.IDBJsifyExtension_jsifyValueStrict(this.keyPath);
      return new A.ObjectStoreNative(type$.JSObject._as(this.$this.idbDatabase.createObjectStore(this.name, {keyPath: t1, autoIncrement: false})));
    },
    $signature: 19
  };
  A.DatabaseNative_transaction_closure.prototype = {
    call$0() {
      var t1 = this.$this,
        idbTransaction = type$.JSObject._as(t1.idbDatabase.transaction(A.IDBJsifyExtension_jsifyValueStrict(this.storeNameOrStoreNames), this.mode));
      return new A.TransactionNative(idbTransaction, t1);
    },
    $signature: 27
  };
  A.DatabaseNative_objectStoreNames_closure.prototype = {
    call$0() {
      return A.DOMStringListExt_toStringIterable(type$.JSObject._as(this.$this.idbDatabase.objectStoreNames));
    },
    $signature: 29
  };
  A.DatabaseNative_name_closure.prototype = {
    call$0() {
      return A._asString(this.$this.idbDatabase.name);
    },
    $signature: 30
  };
  A.DatabaseErrorNative.prototype = {
    get$stackTrace() {
      return null;
    },
    toString$0(_) {
      return this.name + ": " + this._idb$_message;
    }
  };
  A.IdbFactoryNativeBrowserWrapperImpl.prototype = {};
  A.IdbFactoryNativeWrapperImpl.prototype = {
    open$3$onUpgradeNeeded$version(dbName, onUpgradeNeeded, version) {
      return this.open$body$IdbFactoryNativeWrapperImpl(dbName, type$.nullable_void_Function_VersionChangeEvent._as(onUpgradeNeeded), version);
    },
    open$body$IdbFactoryNativeWrapperImpl(dbName, onUpgradeNeeded, version) {
      var $async$goto = 0,
        $async$completer = A._makeAsyncAwaitCompleter(type$.Database),
        $async$returnValue, $async$handler = 2, $async$errorStack = [], $async$self = this, e, t4, exception, idbDatabase, t1, t2, completer, t3, openRequest, $async$exception;
      var $async$open$3$onUpgradeNeeded$version = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1) {
          $async$errorStack.push($async$result);
          $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = {};
              t2 = new A._Future($.Zone__current, type$._Future_Object);
              completer = new A._SyncCompleter(t2, type$._SyncCompleter_Object);
              t3 = type$.JSObject;
              openRequest = t3._as($async$self.nativeFactory.open(dbName, version));
              t1.onUpdateNeededException = t1.onUpdateNeededFutureOr = null;
              A._EventStreamSubscription$(openRequest, "upgradeneeded", type$.nullable_void_Function_JSObject._as(new A.IdbFactoryNativeWrapperImpl_open_closure(t1, $async$self, onUpgradeNeeded)), false, t3);
              A.IDBRequestExt_handleOnSuccess(openRequest, completer);
              A.IDBRequestExt_handleOnError(openRequest, completer);
              $async$goto = 3;
              return A._asyncAwait(t2, $async$open$3$onUpgradeNeeded$version);
            case 3:
              // returning from await.
              t2 = t1.onUpdateNeededFutureOr;
              t4 = t2 instanceof A._Future;
              $async$goto = t4 && t1.onUpdateNeededException == null ? 4 : 5;
              break;
            case 4:
              // then
              $async$handler = 7;
              $async$goto = 10;
              return A._asyncAwait(t4 ? t2 : A._Future$value(t2, type$.dynamic), $async$open$3$onUpgradeNeeded$version);
            case 10:
              // returning from await.
              $async$handler = 2;
              // goto after finally
              $async$goto = 9;
              break;
            case 7:
              // catch
              $async$handler = 6;
              $async$exception = $async$errorStack.pop();
              e = A.unwrapException($async$exception);
              t1.onUpdateNeededException = e;
              // goto after finally
              $async$goto = 9;
              break;
            case 6:
              // uncaught
              // goto rethrow
              $async$goto = 2;
              break;
            case 9:
              // after finally
            case 5:
              // join
              idbDatabase = t3._as(openRequest.result);
              if (t1.onUpdateNeededException != null) {
                idbDatabase.close();
                t1 = t1.onUpdateNeededException;
                t1.toString;
                throw A.wrapException(t1);
              }
              $async$returnValue = new A.DatabaseNative(idbDatabase, $async$self);
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return A._asyncReturn($async$returnValue, $async$completer);
            case 2:
              // rethrow
              return A._asyncRethrow($async$errorStack.at(-1), $async$completer);
          }
      });
      return A._asyncStartSync($async$open$3$onUpgradeNeeded$version, $async$completer);
    },
    deleteDatabase$1(dbName) {
      var t1 = new A._Future($.Zone__current, type$._Future_nullable_Object),
        completer = new A._SyncCompleter(t1, type$._SyncCompleter_nullable_Object),
        deleteRequest = type$.JSObject._as(this.nativeFactory.deleteDatabase(dbName));
      A.IDBRequestExt_handleOnSuccess(deleteRequest, completer);
      A.IDBRequestExt_handleOnError(deleteRequest, completer);
      return t1.then$1$1(new A.IdbFactoryNativeWrapperImpl_deleteDatabase_closure(this), type$.IdbFactory);
    }
  };
  A.IdbFactoryNativeWrapperImpl_open_closure.prototype = {
    call$1($event) {
      var e, exception, _this = this;
      try {
        _this._box_0.onUpdateNeededFutureOr = _this.onUpgradeNeeded.call$1(new A.VersionChangeEventNative(_this.$this, $event));
      } catch (exception) {
        e = A.unwrapException(exception);
        _this._box_0.onUpdateNeededException = e;
      }
    },
    $signature: 20
  };
  A.IdbFactoryNativeWrapperImpl_deleteDatabase_closure.prototype = {
    call$1(__wc0_formal) {
      return this.$this;
    },
    $signature: 32
  };
  A.cursorWithValueStreamFromResult_closure.prototype = {
    call$1($event) {
      var t1, t2, t3, _0_0, error, stackTrace;
      type$.JSObject._as($event);
      t1 = this.controller;
      t2 = type$.nullable_JSObject._as(this.request.error);
      t3 = A._asString(t2.name);
      t2 = A._asString(t2.message);
      if (t1._state >= 4)
        A.throwExpression(t1._badEventState$0());
      _0_0 = A._interceptUserError(new A.DatabaseErrorNative(t3, t2), null);
      error = _0_0.error;
      stackTrace = _0_0.stackTrace;
      t2 = t1._state;
      if ((t2 & 1) !== 0)
        t1._sendError$2(error, stackTrace);
      else if ((t2 & 3) === 0)
        t1._ensurePendingEvents$0().add$1(0, new A._DelayedError(error, stackTrace));
    },
    $signature: 2
  };
  A.cursorWithValueStreamFromResult_closure0.prototype = {
    call$1($event) {
      var cursor, t1;
      type$.JSObject._as($event);
      cursor = type$.nullable_JSObject._as(this.request.result);
      t1 = this.controller;
      if (cursor == null)
        t1.close$0();
      else
        t1.add$1(0, new A.CursorWithValueNative(cursor));
    },
    $signature: 2
  };
  A.ObjectStoreNative.prototype = {
    getObject$1(key) {
      return A.catchAsyncNativeError(new A.ObjectStoreNative_getObject_closure(this, key), type$.nullable_Object);
    },
    clear$0(_) {
      return A.catchAsyncNativeError(new A.ObjectStoreNative_clear_closure(this), type$.dynamic);
    },
    put$2(value, key) {
      return A.catchAsyncNativeError(new A.ObjectStoreNative_put_closure(this, key, value), type$.Object);
    },
    delete$1(keyOrRange) {
      return A.catchAsyncNativeError(new A.ObjectStoreNative_delete_closure(this, keyOrRange), type$.dynamic);
    },
    openCursor$0() {
      var request,
        query = A.keyOrKeyRangeToNativeQuery(null, null);
      if (query == null)
        request = type$.JSObject._as(this.idbObjectStore.openCursor());
      else
        request = type$.JSObject._as(this.idbObjectStore.openCursor(query));
      return A.cursorWithValueStreamFromResult(request, null);
    },
    get$keyPath() {
      var t1 = this.idbObjectStore.keyPath;
      return t1 == null ? null : A.IDBDartifyExtension_dartifyStringOrStringList(t1);
    },
    get$autoIncrement() {
      return A._asBool(this.idbObjectStore.autoIncrement);
    },
    get$name() {
      return A._asString(this.idbObjectStore.name);
    }
  };
  A.ObjectStoreNative_getObject_closure.prototype = {
    call$0() {
      var t1 = A.jsify(this.key);
      t1.toString;
      return A.IDBRequestExt_dartFutureNullable(type$.JSObject._as(this.$this.idbObjectStore.get(t1)), type$.nullable_Object);
    },
    $signature: 5
  };
  A.ObjectStoreNative_clear_closure.prototype = {
    call$0() {
      return A.IDBRequestExt_get_future(type$.JSObject._as(this.$this.idbObjectStore.clear()));
    },
    $signature: 5
  };
  A.ObjectStoreNative_put_closure.prototype = {
    call$0() {
      var t1 = A.IDBJsifyExtension_jsifyValueStrict(this.value),
        t2 = A.jsify(this.key);
      t2.toString;
      return A.IDBRequestExt_dartFuture(type$.JSObject._as(this.$this.idbObjectStore.put(t1, t2)), type$.Object);
    },
    $signature: 21
  };
  A.ObjectStoreNative_delete_closure.prototype = {
    call$0() {
      return A.IDBRequestExt_get_future(type$.JSObject._as(this.$this.idbObjectStore.delete(A.toNativeQuery(this.keyOrRange))));
    },
    $signature: 5
  };
  A.TransactionNativeBase.prototype = {};
  A.TransactionNative.prototype = {
    get$_completer() {
      var result, _this = this,
        value = _this.__TransactionNative__completer_FI;
      if (value === $) {
        result = new A.TransactionNative__completer_closure(_this).call$0();
        _this.__TransactionNative__completer_FI !== $ && A.throwLateFieldADI("_completer");
        _this.__TransactionNative__completer_FI = result;
        value = result;
      }
      return value;
    },
    objectStore$1($name) {
      var t1 = A.catchNativeError(new A.TransactionNative_objectStore_closure(this, $name), type$.nullable_ObjectStore);
      t1.toString;
      return t1;
    },
    get$completed() {
      var $async$goto = 0,
        $async$completer = A._makeAsyncAwaitCompleter(type$.Database),
        $async$returnValue, $async$self = this;
      var $async$get$completed = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return A._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$returnValue = $async$self.get$_completer().get$future().then$1$1(new A.TransactionNative_completed_closure($async$self), type$.Database);
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return A._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return A._asyncStartSync($async$get$completed, $async$completer);
    }
  };
  A.TransactionNative__completer_closure.prototype = {
    call$0() {
      var completer = new A._SyncCompleter(new A._Future($.Zone__current, type$._Future_nullable_Object), type$._SyncCompleter_nullable_Object),
        t1 = this.$this,
        t2 = t1.idbTransaction;
      t2.onerror = A._functionToJS1(new A.TransactionNative__completer__closure(t1, completer));
      t2.onabort = A._functionToJS1(new A.TransactionNative__completer__closure0(completer));
      t2.oncomplete = A._functionToJS1(new A.TransactionNative__completer__closure1(completer));
      return completer;
    },
    $signature: 35
  };
  A.TransactionNative__completer__closure.prototype = {
    call$1($event) {
      var t1, t2;
      type$.JSObject._as($event);
      t1 = this.completer;
      if ((t1.future._state & 30) === 0) {
        t2 = type$.nullable_JSObject._as(this.$this.idbTransaction.error);
        t1.completeError$1(new A.DatabaseErrorNative(A._asString(t2.name), A._asString(t2.message)));
      }
    },
    $signature: 2
  };
  A.TransactionNative__completer__closure0.prototype = {
    call$1($event) {
      var t1;
      type$.JSObject._as($event);
      t1 = this.completer;
      if ((t1.future._state & 30) === 0)
        t1.completeError$1(new A.DatabaseErrorNative("abort", "Transaction was aborted"));
    },
    $signature: 2
  };
  A.TransactionNative__completer__closure1.prototype = {
    call$1($event) {
      var t1;
      type$.JSObject._as($event);
      t1 = this.completer;
      if ((t1.future._state & 30) === 0)
        t1.complete$0();
    },
    $signature: 2
  };
  A.TransactionNative_objectStore_closure.prototype = {
    call$0() {
      return new A.ObjectStoreNative(type$.JSObject._as(this.$this.idbTransaction.objectStore(this.name)));
    },
    $signature: 19
  };
  A.TransactionNative_completed_closure.prototype = {
    call$1(__wc0_formal) {
      return this.$this.database;
    },
    $signature: 36
  };
  A.KeyCursorSembastMixin.prototype = {
    get$key() {
      var t2,
        t1 = this.KeyCursorSembastMixin___KeyCursorSembastMixin_ctlr_A;
      t1 === $ && A.throwLateFieldNI("ctlr");
      t1 = t1.BaseCursorControllerSembastMixin_records;
      t1.toString;
      t2 = this.KeyCursorSembastMixin___KeyCursorSembastMixin_recordIndex_A;
      t2 === $ && A.throwLateFieldNI("recordIndex");
      if (!(t2 >= 0 && t2 < t1.length))
        return A.ioore(t1, t2);
      t2 = t1[t2];
      t1 = t2.idbStore;
      t2 = t2.snapshot;
      if (type$.Iterable_dynamic._is(t1.meta.keyPath)) {
        t1 = t1.getKeyImpl$1(t2.get$value());
        t1.toString;
      } else
        t1 = t2.get$key();
      return t1;
    }
  };
  A.CursorWithValueSembastMixin.prototype = {
    get$value() {
      var t2, t3,
        t1 = this.KeyCursorSembastMixin___KeyCursorSembastMixin_ctlr_A;
      t1 === $ && A.throwLateFieldNI("ctlr");
      t2 = t1.BaseCursorControllerSembastMixin_records;
      t2.toString;
      t3 = this.KeyCursorSembastMixin___KeyCursorSembastMixin_recordIndex_A;
      t3 === $ && A.throwLateFieldNI("recordIndex");
      if (!(t3 >= 0 && t3 < t2.length))
        return A.ioore(t2, t3);
      t3 = t1.store.recordToValue$1(t2[t3].snapshot);
      t3.toString;
      return t3;
    }
  };
  A.StoreCursorWithValueSembast.prototype = {$isIdbCursor: 1, $isIdbCursorWithValue: 1};
  A.RecordSnapshotSembast.prototype = {
    toString$0(_) {
      return this.snapshot.toString$0(0);
    }
  };
  A.StoreCursorControllerSembastMixin.prototype = {};
  A.BaseCursorControllerSembastMixin.prototype = {
    autoNext$0() {
      this._advance$1(1);
      this.BaseCursorControllerSembastMixin___BaseCursorControllerSembastMixin_meta_A === $ && A.throwLateFieldNI("meta");
    },
    _advance$1(count) {
      var t2, cursor, _this = this,
        t1 = _this.BaseCursorControllerSembastMixin_currentIndex;
      t1.toString;
      t1 = _this.BaseCursorControllerSembastMixin_currentIndex = t1 + count;
      if (t1 >= _this.BaseCursorControllerSembastMixin_records.length) {
        _this.BaseCursorControllerSembastMixin_currentIndex = null;
        t1 = _this.BaseCursorControllerSembastMixin___BaseCursorControllerSembastMixin_ctlr_A;
        t1 === $ && A.throwLateFieldNI("ctlr");
        t1.close$0();
        return;
      }
      t2 = _this.BaseCursorControllerSembastMixin___BaseCursorControllerSembastMixin_ctlr_A;
      t2 === $ && A.throwLateFieldNI("ctlr");
      cursor = new A.StoreCursorWithValueSembast($, $);
      cursor.KeyCursorSembastMixin___KeyCursorSembastMixin_ctlr_A = type$.BaseCursorControllerSembastMixin_IdbCursor._as(_this);
      cursor.KeyCursorSembastMixin___KeyCursorSembastMixin_recordIndex_A = t1;
      t2.add$1(0, cursor);
    },
    openCursor$0() {
      var $async$goto = 0,
        $async$completer = A._makeAsyncAwaitCompleter(type$.dynamic),
        $async$returnValue, $async$self = this, filter, t3, finder, t1, t2;
      var $async$openCursor$0 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return A._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = $async$self.store;
              t2 = $async$self.BaseCursorControllerSembastMixin___BaseCursorControllerSembastMixin_meta_A;
              t2 === $ && A.throwLateFieldNI("meta");
              filter = t1.cursorFilter$2(t2.key, t2.range);
              t2 = $async$self.BaseCursorControllerSembastMixin___BaseCursorControllerSembastMixin_meta_A.__IdbCursorMeta__ascending_A;
              t2 === $ && A.throwLateFieldNI("_ascending");
              t3 = t1.meta.keyPath;
              finder = A.Finder_Finder(filter, null, A.keyPathSortOrders(t3 == null ? "_key" : t3, t2));
              t2 = type$.Object;
              $async$goto = 3;
              return A._asyncAwait(A.SembastStoreRefExtension_find(t1.get$sembastStore(), t1.get$sembastClient(), finder, t2, t2), $async$openCursor$0);
            case 3:
              // returning from await.
              $async$self.setRecords$1($async$result);
              $async$returnValue = $async$self.autoNext$0();
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return A._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return A._asyncStartSync($async$openCursor$0, $async$completer);
    },
    setRecords$1(records) {
      var t1 = J.map$1$1$ax(type$.List_RecordSnapshot_Object_Object._as(records), new A.BaseCursorControllerSembastMixin_setRecords_closure(this), type$.RecordSnapshotSembast);
      t1 = A.List_List$_of(t1, t1.$ti._eval$1("ListIterable.E"));
      t1.$flags = 1;
      this.BaseCursorControllerSembastMixin_records = t1;
    }
  };
  A.BaseCursorControllerSembastMixin_setRecords_closure.prototype = {
    call$1(snapshot) {
      return new A.RecordSnapshotSembast(this.$this.store, type$.RecordSnapshot_Object_Object._as(snapshot));
    },
    $signature: 37
  };
  A.CursorWithValueControllerSembastMixin.prototype = {};
  A.StoreCursorWithValueControllerSembast.prototype = {};
  A._StoreCursorWithValueControllerSembast_Object_CursorWithValueControllerSembastMixin.prototype = {};
  A._StoreCursorWithValueControllerSembast_Object_CursorWithValueControllerSembastMixin_BaseCursorControllerSembastMixin.prototype = {};
  A._StoreCursorWithValueControllerSembast_Object_CursorWithValueControllerSembastMixin_BaseCursorControllerSembastMixin_StoreCursorControllerSembastMixin.prototype = {};
  A._StoreCursorWithValueSembast_Object_KeyCursorSembastMixin.prototype = {};
  A._StoreCursorWithValueSembast_Object_KeyCursorSembastMixin_CursorWithValueSembastMixin.prototype = {};
  A._SembastVersionChangeEvent.prototype = {
    get$target() {
      var t1 = this.___SembastVersionChangeEvent_request_A;
      t1 === $ && A.throwLateFieldNI("request");
      return t1;
    },
    toString$0(_) {
      return "" + this.oldVersion + " => " + this.newVersion;
    }
  };
  A.DatabaseSembast.prototype = {
    _loadStoresMeta$1(storeNames) {
      var keys, t1, t2, t3, t4;
      type$.List_String._as(storeNames);
      keys = A._setArrayType([], type$.JSArray_String);
      storeNames.forEach$1(storeNames, new A.DatabaseSembast__loadStoresMeta_closure(keys));
      t1 = this.mainStore;
      t2 = t1.$ti;
      t2._eval$1("Iterable<1>")._as(keys);
      t2 = t2._eval$1("SembastRecordsRef<1,2>");
      t3 = new A.SembastRecordsRef($, $, t2);
      t3.RecordsRefMixin___RecordsRefMixin_store_A = t2._eval$1("StoreRef<1,2>")._as(t1);
      t1 = type$.String;
      t4 = J.JSArray_JSArray$markFixed(keys.slice(0), t1);
      t3.RecordsRefMixin___RecordsRefMixin_keys_A = t2._eval$1("List<1>")._as(t4);
      t2 = this.db;
      t2.toString;
      return A.SembastRecordsRefExtension_getSnapshots(t3, t2, t1, type$.Object).then$1$1(new A.DatabaseSembast__loadStoresMeta_closure0(), type$.List_IdbObjectStoreMeta);
    },
    _readMetaVersion$0() {
      var $async$goto = 0,
        $async$completer = A._makeAsyncAwaitCompleter(type$.int),
        $async$returnValue, $async$self = this;
      var $async$_readMetaVersion$0 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return A._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$returnValue = $async$self.db.transaction$1$1(new A.DatabaseSembast__readMetaVersion_closure($async$self), type$.int);
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return A._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return A._asyncStartSync($async$_readMetaVersion$0, $async$completer);
    },
    open$2(newVersion, onUpgradeNeeded) {
      return this.open$body$DatabaseSembast(newVersion, type$.nullable_void_Function_VersionChangeEvent._as(onUpgradeNeeded));
    },
    open$body$DatabaseSembast(newVersion, onUpgradeNeeded) {
      var $async$goto = 0,
        $async$completer = A._makeAsyncAwaitCompleter(type$.nullable_Database),
        $async$returnValue, $async$handler = 2, $async$errorStack = [], $async$self = this, previousVersion, changedStores, deletedStores, t2, t3, t4, exception, exception0, t1, $async$exception, $async$exception0, $async$temp1;
      var $async$open$2 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1) {
          $async$errorStack.push($async$result);
          $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = {};
              t1.newVersion = newVersion;
              previousVersion = A._Cell$named("previousVersion");
              t2 = type$.IdbFactorySembast;
              t3 = t2._as(A.IdbDatabaseBase.prototype.get$factory.call($async$self));
              t2._as(A.IdbDatabaseBase.prototype.get$factory.call($async$self));
              t2 = $async$self.meta;
              t4 = t2.__IdbDatabaseMeta_name_A;
              t4 === $ && A.throwLateFieldNI("name");
              $async$goto = 3;
              return A._asyncAwait(t3._databaseFactory.openDatabaseWithOptions$2(t4, new A.DatabaseOpenOptions(1, type$.nullable_dynamic_Function_Database_int_int._as(new A.DatabaseSembast_open_closure()), null, null)), $async$open$2);
            case 3:
              // returning from await.
              $async$self.db = $async$result;
              $async$handler = 5;
              $async$temp1 = previousVersion;
              $async$goto = 8;
              return A._asyncAwait($async$self._readMetaVersion$0(), $async$open$2);
            case 8:
              // returning from await.
              $async$temp1._value = $async$result;
              J.$eq$(previousVersion._readLocal$0(), 0);
              t3 = previousVersion._readLocal$0();
              $async$goto = newVersion !== t3 ? 9 : 11;
              break;
            case 9:
              // then
              changedStores = A._Cell$named("changedStores");
              deletedStores = A._Cell$named("deletedStores");
              $async$goto = 12;
              return A._asyncAwait(t2.onUpgradeNeeded$1(new A.DatabaseSembast_open_closure0(t1, $async$self, onUpgradeNeeded, previousVersion, changedStores, deletedStores)), $async$open$2);
            case 12:
              // returning from await.
              $async$goto = 13;
              return A._asyncAwait($async$self.db.transaction$1$1(new A.DatabaseSembast_open_closure1(t1, $async$self, deletedStores, changedStores), type$.Null), $async$open$2);
            case 13:
              // returning from await.
              t2.version = t1.newVersion;
              // goto join
              $async$goto = 10;
              break;
            case 11:
              // else
              t2.set$version(previousVersion._readLocal$0());
            case 10:
              // join
              t1 = $async$self.db;
              $async$returnValue = t1;
              // goto return
              $async$goto = 1;
              break;
              $async$handler = 2;
              // goto after finally
              $async$goto = 7;
              break;
            case 5:
              // catch
              $async$handler = 4;
              $async$exception = $async$errorStack.pop();
              $async$handler = 15;
              t1 = $async$self.db;
              t1 = t1 == null ? null : t1.close$0();
              $async$goto = 18;
              return A._asyncAwait(t1 instanceof A._Future ? t1 : A._Future$value(t1, type$.dynamic), $async$open$2);
            case 18:
              // returning from await.
              $async$handler = 4;
              // goto after finally
              $async$goto = 17;
              break;
            case 15:
              // catch
              $async$handler = 14;
              $async$exception0 = $async$errorStack.pop();
              // goto after finally
              $async$goto = 17;
              break;
            case 14:
              // uncaught
              // goto uncaught
              $async$goto = 4;
              break;
            case 17:
              // after finally
              throw $async$exception;
              // goto after finally
              $async$goto = 7;
              break;
            case 4:
              // uncaught
              // goto rethrow
              $async$goto = 2;
              break;
            case 7:
              // after finally
            case 1:
              // return
              return A._asyncReturn($async$returnValue, $async$completer);
            case 2:
              // rethrow
              return A._asyncRethrow($async$errorStack.at(-1), $async$completer);
          }
      });
      return A._asyncStartSync($async$open$2, $async$completer);
    },
    createObjectStore$2$keyPath($name, keyPath) {
      var storeMeta = A.IdbObjectStoreMeta$($name, keyPath, null, null),
        t1 = this.meta,
        t2 = t1._versionChangeTransaction;
      if (t2 == null)
        A.throwExpression(A.StateError$("cannot create objectStore outside of a versionChangedEvent"));
      t2.createdStores.add$1(0, storeMeta);
      t1._stores.$indexSet(0, storeMeta.name, storeMeta);
      return new A.ObjectStoreSembast(storeMeta, this.versionChangeTransaction);
    },
    get$objectStoreNames() {
      var t1 = this.meta._stores;
      return new A.LinkedHashMapKeysIterable(t1, A._instanceType(t1)._eval$1("LinkedHashMapKeysIterable<1>"));
    },
    transaction$2(storeNameOrStoreNames, mode) {
      return A.TransactionSembast$(this, this.meta.transaction$2(storeNameOrStoreNames, mode));
    },
    toString$0(_) {
      return A.MapBase_mapToString(this.meta.toDebugMap$0());
    }
  };
  A.DatabaseSembast__loadStoresMeta_closure.prototype = {
    call$1(storeName) {
      B.JSArray_methods.add$1(this.keys, "store_" + A._asString(storeName));
    },
    $signature: 38
  };
  A.DatabaseSembast__loadStoresMeta_closure0.prototype = {
    call$1(records) {
      var list;
      type$.List_nullable_RecordSnapshot_String_Object._as(records);
      list = A._setArrayType([], type$.JSArray_IdbObjectStoreMeta);
      J.forEach$1$ax(records, new A.DatabaseSembast__loadStoresMeta__closure(list));
      return list;
    },
    $signature: 39
  };
  A.DatabaseSembast__loadStoresMeta__closure.prototype = {
    call$1(record) {
      var store,
        t1 = type$.Map_dynamic_dynamic,
        map = t1._as(type$.nullable_RecordSnapshot_String_Object._as(record).get$value()).cast$2$0(0, type$.String, type$.nullable_Object),
        t2 = map._source,
        t3 = map.$ti._eval$1("4?"),
        t4 = A._asString(t3._as(t2.$index(0, "name"))),
        t5 = A.IdbObjectStoreMeta__keyPathAsStringOrList(t3._as(t2.$index(0, "keyPath"))),
        t6 = A._asBoolQ(t3._as(t2.$index(0, "autoIncrement")));
      t2 = type$.nullable_List_dynamic._as(t3._as(t2.$index(0, "indecies")));
      store = new A.IdbObjectStoreMeta(t4, t5, t6 === true, A.LinkedHashMap_LinkedHashMap$_empty(type$.nullable_String, type$.IdbIndexMeta));
      store.IdbObjectStoreMeta$4(t4, t5, t6, A.IdbIndexMeta_fromMapList(t2 == null ? null : J.cast$1$0$ax(t2, t1)));
      B.JSArray_methods.add$1(this.list, store);
    },
    $signature: 40
  };
  A.DatabaseSembast__readMetaVersion_closure.prototype = {
    call$1(txn) {
      return this.$call$body$DatabaseSembast__readMetaVersion_closure(txn);
    },
    $call$body$DatabaseSembast__readMetaVersion_closure(txn) {
      var $async$goto = 0,
        $async$completer = A._makeAsyncAwaitCompleter(type$.int),
        $async$returnValue, $async$self = this, t6, t7, t8, storeList, t1, t2, t3, t4, t5, $async$temp1;
      var $async$call$1 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return A._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = $async$self.$this;
              t2 = t1.meta;
              t3 = t1.mainStore;
              t4 = t3.$ti;
              t5 = t4._precomputed1;
              t4 = t4._rest[1];
              t6 = type$.String;
              t7 = type$.Object;
              $async$temp1 = A;
              $async$goto = 3;
              return A._asyncAwait(A.SembastRecordRefExtension_get(A.SembastRecordRef$(t3, t5._as("version"), t5, t4), txn, t6, t7), $async$call$1);
            case 3:
              // returning from await.
              t8 = $async$temp1._asIntQ($async$result);
              t2.version = t8 == null ? 0 : t8;
              $async$goto = 4;
              return A._asyncAwait(A.SembastRecordRefExtension_get(A.SembastRecordRef$(t3, t5._as("stores"), t5, t4), txn, t6, t7), $async$call$1);
            case 4:
              // returning from await.
              storeList = $async$result;
              $async$goto = storeList != null ? 5 : 6;
              break;
            case 5:
              // then
              $async$goto = 7;
              return A._asyncAwait(t1._loadStoresMeta$1(J.cast$1$0$ax(type$.List_dynamic._as(storeList), t6)).then$1$1(new A.DatabaseSembast__readMetaVersion__closure(t1), type$.Null), $async$call$1);
            case 7:
              // returning from await.
            case 6:
              // join
              t1 = t2.version;
              t1.toString;
              $async$returnValue = t1;
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return A._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return A._asyncStartSync($async$call$1, $async$completer);
    },
    $signature: 41
  };
  A.DatabaseSembast__readMetaVersion__closure.prototype = {
    call$1(storeMetas) {
      J.forEach$1$ax(type$.List_IdbObjectStoreMeta._as(storeMetas), new A.DatabaseSembast__readMetaVersion___closure(this.$this));
    },
    $signature: 42
  };
  A.DatabaseSembast__readMetaVersion___closure.prototype = {
    call$1(store) {
      type$.IdbObjectStoreMeta._as(store);
      this.$this.meta._stores.$indexSet(0, store.name, store);
    },
    $signature: 43
  };
  A.DatabaseSembast_open_closure.prototype = {
    call$3(db, oldVersion, newVersion) {
    },
    $signature: 44
  };
  A.DatabaseSembast_open_closure0.prototype = {
    call$0() {
      var $async$goto = 0,
        $async$completer = A._makeAsyncAwaitCompleter(type$.Null),
        $async$self = this, t3, t4, t5, t6, t7, t1, t2;
      var $async$call$0 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return A._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = $async$self.$this;
              t2 = t1.meta;
              t1.versionChangeTransaction = A.TransactionSembast$(t1, t2._versionChangeTransaction);
              t3 = $async$self.onUpgradeNeeded;
              $async$goto = t3 != null ? 2 : 3;
              break;
            case 2:
              // then
              t4 = $async$self.previousVersion._readLocal$0();
              t5 = $async$self._box_0.newVersion;
              t5.toString;
              t6 = t4 == null ? 0 : t4;
              t7 = new A._SembastVersionChangeEvent(t6, t5);
              if (t6 >= t5)
                A.throwExpression(A.StateError$("cannot downgrade from " + A.S(t4) + " to " + t5));
              t1.versionChangeTransaction.toString;
              t7.___SembastVersionChangeEvent_request_A = new A.OpenDBRequest(t1);
              t3 = t3.call$1(t7);
              $async$goto = 4;
              return A._asyncAwait(t3 instanceof A._Future ? t3 : A._Future$value(t3, type$.void), $async$call$0);
            case 4:
              // returning from await.
            case 3:
              // join
              $async$goto = 5;
              return A._asyncAwait(t1.versionChangeTransaction.get$completed(), $async$call$0);
            case 5:
              // returning from await.
              t1 = $async$self.changedStores;
              t1._value = A.LinkedHashSet_LinkedHashSet$from(t2._versionChangeTransaction.createdStores, type$.IdbObjectStoreMeta);
              J.addAll$1$ax(t1._readLocal$0(), t2._versionChangeTransaction.updatedStores);
              $async$self.deletedStores._value = t2._versionChangeTransaction.deletedStores;
              // implicit return
              return A._asyncReturn(null, $async$completer);
          }
      });
      return A._asyncStartSync($async$call$0, $async$completer);
    },
    $signature: 10
  };
  A.DatabaseSembast_open_closure1.prototype = {
    call$1(txn) {
      return this.$call$body$DatabaseSembast_open_closure(txn);
    },
    $call$body$DatabaseSembast_open_closure(txn) {
      var $async$goto = 0,
        $async$completer = A._makeAsyncAwaitCompleter(type$.Null),
        $async$self = this, storeMeta, storeMeta0, t8, t9, t10, t11, t1, t2, t3, t4, t5, t6, t7;
      var $async$call$1 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return A._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = $async$self.$this;
              t2 = t1.mainStore;
              t3 = t2.$ti;
              t4 = t3._precomputed1;
              t5 = t3._rest[1];
              t6 = A.SembastRecordRef$(t2, t4._as("version"), t4, t5);
              t7 = $async$self._box_0.newVersion;
              t7.toString;
              t8 = type$.String;
              t9 = type$.Object;
              $async$goto = 2;
              return A._asyncAwait(A.SembastRecordRefExtension_put(t6, txn, t7, t8, t9), $async$call$1);
            case 2:
              // returning from await.
              t6 = $async$self.deletedStores, t7 = J.get$iterator$ax(t6._readLocal$0()), t10 = type$.int, t11 = type$.Map_of_String_and_nullable_Object;
            case 3:
              // for condition
              if (!t7.moveNext$0()) {
                // goto after for
                $async$goto = 4;
                break;
              }
              storeMeta = t7.get$current();
              $async$goto = 5;
              return A._asyncAwait(A.SembastStoreRefExtension_drop($.$get$intMapStoreFactory().store$1(storeMeta.name), txn, t10, t11), $async$call$1);
            case 5:
              // returning from await.
              // goto for condition
              $async$goto = 3;
              break;
            case 4:
              // after for
              t7 = $async$self.changedStores;
              $async$goto = J.get$isNotEmpty$asx(t7._readLocal$0()) || J.get$isNotEmpty$asx(t6._readLocal$0()) ? 6 : 7;
              break;
            case 6:
              // then
              t5 = A.SembastRecordRef$(t2, t4._as("stores"), t4, t5);
              t1 = t1.meta._stores;
              t1 = A.List_List$from(new A.LinkedHashMapKeysIterable(t1, A._instanceType(t1)._eval$1("LinkedHashMapKeysIterable<1>")), true, t8);
              B.JSArray_methods.sort$0(t1);
              $async$goto = 8;
              return A._asyncAwait(A.SembastRecordRefExtension_put(t5, txn, t1, t8, t9), $async$call$1);
            case 8:
              // returning from await.
            case 7:
              // join
              t1 = J.get$iterator$ax(t7._readLocal$0()), t3 = t3._eval$1("SembastRecordRef<1,2>"), t5 = t3._eval$1("StoreRef<1,2>"), t6 = t3._precomputed1;
            case 9:
              // for condition
              if (!t1.moveNext$0()) {
                // goto after for
                $async$goto = 10;
                break;
              }
              storeMeta0 = t1.get$current();
              t7 = t4._as("store_" + storeMeta0.name);
              t10 = new A.SembastRecordRef($, $, t3);
              t10.RecordRefMixin___RecordRefMixin_store_A = t5._as(t2);
              t10.RecordRefMixin___RecordRefMixin_key_A = t6._as(t7);
              $async$goto = 11;
              return A._asyncAwait(A.SembastRecordRefExtension_put(t10, txn, storeMeta0.toMap$0(), t8, t9), $async$call$1);
            case 11:
              // returning from await.
              // goto for condition
              $async$goto = 9;
              break;
            case 10:
              // after for
              // implicit return
              return A._asyncReturn(null, $async$completer);
          }
      });
      return A._asyncStartSync($async$call$1, $async$completer);
    },
    $signature: 46
  };
  A._DatabaseSembast_IdbDatabaseBase_DatabaseWithMetaMixin.prototype = {};
  A.IdbFactorySembastImpl.prototype = {
    open$3$onUpgradeNeeded$version(dbName, onUpgradeNeeded, version) {
      return this.open$body$IdbFactorySembastImpl(dbName, type$.nullable_void_Function_VersionChangeEvent._as(onUpgradeNeeded), version);
    },
    open$body$IdbFactorySembastImpl(dbName, onUpgradeNeeded, version) {
      var $async$goto = 0,
        $async$completer = A._makeAsyncAwaitCompleter(type$.Database),
        $async$returnValue, $async$self = this, t1, t2, db;
      var $async$open$3$onUpgradeNeeded$version = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return A._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              type$.nullable_void_Function_VersionChangeEvent._as(onUpgradeNeeded);
              if (version === 0)
                A.throwExpression(A.ArgumentError$("version cannot be 0", null));
              t1 = type$.String;
              t2 = new A.IdbDatabaseMeta(A.LinkedHashMap_LinkedHashMap$_empty(t1, type$.IdbObjectStoreMeta));
              db = new A.DatabaseSembast(t2, A.SembastStoreRef$("_main", t1, type$.Object), $async$self);
              t2.__IdbDatabaseMeta_name_A = dbName;
              $async$goto = 3;
              return A._asyncAwait(db.open$2(version, onUpgradeNeeded), $async$open$3$onUpgradeNeeded$version);
            case 3:
              // returning from await.
              $async$returnValue = db;
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return A._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return A._asyncStartSync($async$open$3$onUpgradeNeeded$version, $async$completer);
    },
    deleteDatabase$1(dbName) {
      return this.deleteDatabase$body$IdbFactorySembastImpl(dbName);
    },
    deleteDatabase$body$IdbFactorySembastImpl(dbName) {
      var $async$goto = 0,
        $async$completer = A._makeAsyncAwaitCompleter(type$.IdbFactory),
        $async$returnValue, $async$self = this;
      var $async$deleteDatabase$1 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return A._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$goto = 3;
              return A._asyncAwait($async$self._databaseFactory.deleteDatabase$1(dbName), $async$deleteDatabase$1);
            case 3:
              // returning from await.
              $async$returnValue = $async$self;
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return A._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return A._asyncStartSync($async$deleteDatabase$1, $async$completer);
    },
    toString$0(_) {
      return "IdbFactorySembast(" + this._databaseFactory.toString$0(0) + ")";
    },
    $isIdbFactorySembast: 1
  };
  A.keyFilter_closure.prototype = {
    call$1(record) {
      return false;
    },
    $signature: 47
  };
  A.ObjectStoreSembast.prototype = {
    get$sembastStore() {
      var t1 = this._sembastStore;
      if (t1 == null) {
        t1 = type$.Object;
        t1 = this._sembastStore = A.SembastStoreRef$(this.meta.name, t1, t1);
      }
      return t1;
    },
    get$sembastClient() {
      var t2,
        t1 = this._sembastClient;
      if (t1 == null) {
        t1 = this.transaction;
        t2 = t1.sembastTransaction;
        t1 = this._sembastClient = t2 == null ? type$.DatabaseSembast._as(t1.database).db : t2;
      }
      t1.toString;
      return t1;
    },
    _inWritableTransaction$1$1(computation, $T) {
      var t1, t2;
      $T._eval$1("0/()")._as(computation);
      if (this.transaction.meta.mode !== "readwrite") {
        t1 = A._interceptUserError(new A.DatabaseReadOnlyError("ReadOnlyError: The transaction is read-only."), null);
        t2 = new A._Future($.Zone__current, $T._eval$1("_Future<0>"));
        t2._asyncCompleteErrorObject$1(t1);
        return t2;
      }
      return this.inTransaction$1$1(computation, $T);
    },
    inTransaction$1$1(computation, $T) {
      return this.transaction.execute$1$1($T._eval$1("0/()")._as(computation), $T);
    },
    getKeyImpl$2(value, key) {
      var t1 = this.meta,
        t2 = t1.keyPath;
      if (t2 != null) {
        if (key != null)
          throw A.wrapException(A.ArgumentError$("The object store uses in-line keys and the key parameter '" + key + "' was provided", null));
        if (type$.Map_dynamic_dynamic._is(value))
          key = A.IdbValueMapExt_getKeyValue(value, t2);
      }
      if (key == null && !t1.autoIncrement)
        throw A.wrapException(A.DatabaseError$("neither keyPath nor autoIncrement set and trying to add object without key"));
      return key;
    },
    getKeyImpl$1(value) {
      return this.getKeyImpl$2(value, null);
    },
    fixKeyInValueImpl$2(value, key) {
      var t2,
        t1 = this.meta.keyPath;
      if (t1 != null && type$.Map_dynamic_dynamic._is(value)) {
        A._asString(t1);
        t2 = A._cloneValue(value);
        t2.toString;
        type$.Map_dynamic_dynamic._as(t2);
        A.setPartsMapValue(t2, A._setArrayType(t1.split("."), type$.JSArray_String), key);
        return t2;
      }
      return value;
    },
    putImpl$2(value, key) {
      var t1, t2, t3, t4, t5, t6, t7, t8, t9, fieldValue, t10, t11, _this = this, _null = null,
        futures = A._setArrayType([], type$.JSArray_Future_dynamic);
      if (type$.Map_dynamic_dynamic._is(value))
        for (t1 = _this.meta, t2 = t1._indecies, t2 = new A.LinkedHashMapValueIterator(t2, t2._modifications, t2._first, A._instanceType(t2)._eval$1("LinkedHashMapValueIterator<2>")), t3 = type$.Object, t4 = type$.dynamic, t5 = type$.SembastStoreRef_Object_Object, t6 = _this.transaction, t7 = type$.DatabaseSembast, t1 = t1.name; t2.moveNext$0();) {
          t8 = t2.__js_helper$_current;
          t9 = t8.keyPath;
          fieldValue = A.IdbValueMapExt_getKeyValue(value, t9);
          if (fieldValue != null) {
            t9 = A.keyFilter(t9, fieldValue, false);
            t10 = _this._sembastStore;
            if (t10 == null) {
              t10 = new A.SembastStoreRef($, t5);
              t10.StoreRefMixin___StoreRefMixin_name_A = t1;
              _this._sembastStore = t10;
            }
            t11 = _this._sembastClient;
            if (t11 == null) {
              t11 = t6.sembastTransaction;
              t11 = _this._sembastClient = t11 == null ? t7._as(t6.database).db : t11;
            }
            t11.toString;
            B.JSArray_methods.add$1(futures, A.SembastStoreRefExtension_findFirst(t10, t11, new A.SembastFinder(t9, _null, 1, _null, _null, _null), t3, t3).then$1$1(new A.ObjectStoreSembast_putImpl_closure(key, t8, fieldValue), t4));
          }
        }
      return A.Future_wait(futures, type$.dynamic).then$1$1(new A.ObjectStoreSembast_putImpl_closure0(_this, key, value), type$.Object);
    },
    txnCompositeFindIdByKey$1(key) {
      return this.txnCompositeFindIdByKey$body$ObjectStoreSembast(key);
    },
    txnCompositeFindIdByKey$body$ObjectStoreSembast(key) {
      var $async$goto = 0,
        $async$completer = A._makeAsyncAwaitCompleter(type$.nullable_Object),
        $async$returnValue, $async$self = this, t1;
      var $async$txnCompositeFindIdByKey$1 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return A._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = type$.Object;
              $async$goto = 3;
              return A._asyncAwait(A.SembastStoreRefExtension_findKey($async$self.get$sembastStore(), $async$self.get$sembastClient(), A.Finder_Finder(A.keyFilter($async$self.meta.keyPath, key, false), null, null), t1, t1), $async$txnCompositeFindIdByKey$1);
            case 3:
              // returning from await.
              $async$returnValue = $async$result;
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return A._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return A._asyncStartSync($async$txnCompositeFindIdByKey$1, $async$completer);
    },
    clear$0(_) {
      return this._inWritableTransaction$1$1(new A.ObjectStoreSembast_clear_closure(this), type$.int).then$1$1(new A.ObjectStoreSembast_clear_closure0(), type$.dynamic);
    },
    txnCompositeGetSnapshot$1(key) {
      return this.txnCompositeGetSnapshot$body$ObjectStoreSembast(key);
    },
    txnCompositeGetSnapshot$body$ObjectStoreSembast(key) {
      var $async$goto = 0,
        $async$completer = A._makeAsyncAwaitCompleter(type$.nullable_RecordSnapshot_Object_Object),
        $async$returnValue, $async$self = this, t1;
      var $async$txnCompositeGetSnapshot$1 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return A._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = type$.Object;
              $async$goto = 3;
              return A._asyncAwait(A.SembastStoreRefExtension_findFirst($async$self.get$sembastStore(), $async$self.get$sembastClient(), A.Finder_Finder(A.keyFilter($async$self.meta.keyPath, key, false), null, null), t1, t1), $async$txnCompositeGetSnapshot$1);
            case 3:
              // returning from await.
              $async$returnValue = $async$result;
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return A._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return A._asyncStartSync($async$txnCompositeGetSnapshot$1, $async$completer);
    },
    delete$1(keyOrRange) {
      return this._inWritableTransaction$1$1(new A.ObjectStoreSembast_delete_closure(this, keyOrRange), type$.nullable_Object);
    },
    txnDelete$1(keyOrRange) {
      var t3, t4, _this = this,
        t1 = _this.meta.keyPath,
        t2 = type$.Object;
      if (type$.Iterable_dynamic._is(t1))
        return A.SembastStoreRefExtension_delete(_this.get$sembastStore(), _this.get$sembastClient(), A.Finder_Finder(A.keyFilter(t1, keyOrRange, false), null, null), t2, t2);
      else {
        t1 = _this.get$sembastStore();
        t3 = t1.$ti;
        t4 = t3._precomputed1;
        return A.SembastRecordRefExtension_delete(A.SembastRecordRef$(t1, t4._as(keyOrRange), t4, t3._rest[1]), _this.get$sembastClient(), t2, t2);
      }
    },
    recordToValue$1(record) {
      type$.nullable_RecordSnapshot_Object_Object._as(record);
      if (record == null)
        return null;
      else
        return A.fromSembastValue(record.get$value());
    },
    txnGetSnapshot$1(key) {
      return this.txnGetSnapshot$body$ObjectStoreSembast(key);
    },
    txnGetSnapshot$body$ObjectStoreSembast(key) {
      var $async$goto = 0,
        $async$completer = A._makeAsyncAwaitCompleter(type$.nullable_RecordSnapshot_Object_Object),
        $async$returnValue, $async$self = this, record, t1, t2, t3, t4;
      var $async$txnGetSnapshot$1 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return A._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$goto = type$.Iterable_dynamic._is($async$self.meta.keyPath) ? 3 : 5;
              break;
            case 3:
              // then
              $async$goto = 6;
              return A._asyncAwait($async$self.txnCompositeGetSnapshot$1(key), $async$txnGetSnapshot$1);
            case 6:
              // returning from await.
              record = $async$result;
              // goto join
              $async$goto = 4;
              break;
            case 5:
              // else
              t1 = $async$self.get$sembastStore();
              t2 = t1.$ti;
              t3 = t2._precomputed1;
              t4 = type$.Object;
              $async$goto = 7;
              return A._asyncAwait(A.SembastRecordRefExtension_getSnapshot(A.SembastRecordRef$(t1, t3._as(key), t3, t2._rest[1]), $async$self.get$sembastClient(), t4, t4), $async$txnGetSnapshot$1);
            case 7:
              // returning from await.
              record = $async$result;
            case 4:
              // join
              $async$returnValue = record;
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return A._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return A._asyncStartSync($async$txnGetSnapshot$1, $async$completer);
    },
    getObject$1(key) {
      A.checkKeyParam(key);
      return this.inTransaction$1$1(new A.ObjectStoreSembast_getObject_closure(this, key), type$.nullable_Object);
    },
    cursorFilter$2(key, range) {
      var t1 = this.meta.keyPath;
      return A.keyFilter(t1 == null ? "_key" : t1, key, false);
    },
    openCursor$0() {
      var ctlr, t1, _null = null,
        cursorMeta = new A.IdbCursorMeta(_null, false, _null);
      cursorMeta.IdbCursorMeta$4(_null, _null, _null, _null);
      ctlr = new A.StoreCursorWithValueControllerSembast(this, $, _null, -1, $);
      ctlr.BaseCursorControllerSembastMixin___BaseCursorControllerSembastMixin_meta_A = cursorMeta;
      t1 = type$.StoreCursorWithValueControllerSembast;
      ctlr.BaseCursorControllerSembastMixin___BaseCursorControllerSembastMixin_ctlr_A = t1._eval$1("StreamController<BaseCursorControllerSembastMixin.T>")._as(A.StreamController_StreamController(true, t1._eval$1("BaseCursorControllerSembastMixin.T")));
      this.inTransaction$1$1(new A.ObjectStoreSembast_openCursor_closure(ctlr), type$.dynamic);
      t1 = ctlr.BaseCursorControllerSembastMixin___BaseCursorControllerSembastMixin_ctlr_A;
      t1 === $ && A.throwLateFieldNI("ctlr");
      return new A._ControllerStream(t1, A._instanceType(t1)._eval$1("_ControllerStream<1>"));
    },
    put$2(value, key) {
      return this._inWritableTransaction$1$1(new A.ObjectStoreSembast_put_closure(this, value, key), type$.Object);
    }
  };
  A.ObjectStoreSembast_putImpl_closure.prototype = {
    call$1(record) {
      var t1, _this = this;
      type$.nullable_RecordSnapshot_Object_Object._as(record);
      t1 = false;
      if (record != null)
        if (!J.$eq$(record.get$key(), _this.key)) {
          t1 = _this.indexMeta;
          t1 = !t1.multiEntry && t1.unique;
        }
      if (t1)
        throw A.wrapException(A.DatabaseError$("key '" + A.S(_this.fieldValue) + "' already exists in " + record.toString$0(0) + " for index " + _this.indexMeta.toString$0(0)));
    },
    $signature: 48
  };
  A.ObjectStoreSembast_putImpl_closure0.prototype = {
    call$1(__wc0_formal) {
      return this.$call$body$ObjectStoreSembast_putImpl_closure(type$.List_dynamic._as(__wc0_formal));
    },
    $call$body$ObjectStoreSembast_putImpl_closure(__wc0_formal) {
      var $async$goto = 0,
        $async$completer = A._makeAsyncAwaitCompleter(type$.Object),
        $async$returnValue, $async$self = this, t1, t2, generatedKey, fixedValue, t3, t4, t5, existing, id0, id;
      var $async$call$1 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return A._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              id = $async$self.key;
              $async$goto = id == null ? 3 : 5;
              break;
            case 3:
              // then
              t1 = $async$self.$this;
              t2 = type$.Object;
              $async$goto = 6;
              return A._asyncAwait(A.SembastStoreRefExtension_generateIntKey(t1.get$sembastStore(), t1.get$sembastClient(), t2, t2), $async$call$1);
            case 6:
              // returning from await.
              generatedKey = $async$result;
              fixedValue = t1.fixKeyInValueImpl$2($async$self.value, generatedKey);
              t3 = t1.get$sembastStore();
              t4 = t3.$ti;
              t5 = t4._precomputed1;
              $async$goto = 7;
              return A._asyncAwait(A.SembastRecordRefExtension_add(A.SembastRecordRef$(t3, t5._as(generatedKey), t5, t4._rest[1]), t1.get$sembastClient(), fixedValue, t2, t2), $async$call$1);
            case 7:
              // returning from await.
              $async$returnValue = generatedKey;
              // goto return
              $async$goto = 1;
              break;
              // goto join
              $async$goto = 4;
              break;
            case 5:
              // else
              t1 = $async$self.$this;
              $async$goto = type$.Iterable_dynamic._is(t1.meta.keyPath) ? 8 : 10;
              break;
            case 8:
              // then
              $async$goto = 11;
              return A._asyncAwait(t1.txnCompositeFindIdByKey$1(id), $async$call$1);
            case 11:
              // returning from await.
              existing = $async$result;
              $async$goto = existing == null ? 12 : 14;
              break;
            case 12:
              // then
              t2 = type$.Object;
              $async$goto = 15;
              return A._asyncAwait(A.SembastStoreRefExtension_generateIntKey(t1.get$sembastStore(), t1.get$sembastClient(), t2, t2), $async$call$1);
            case 15:
              // returning from await.
              generatedKey = $async$result;
              id0 = generatedKey;
              // goto join
              $async$goto = 13;
              break;
            case 14:
              // else
              id0 = existing;
            case 13:
              // join
              // goto join
              $async$goto = 9;
              break;
            case 10:
              // else
              id0 = id;
            case 9:
              // join
              t2 = t1.get$sembastStore();
              t3 = t2.$ti;
              t4 = t3._precomputed1;
              t3 = A.SembastRecordRef$(t2, t4._as(id0), t4, t3._rest[1]);
              t1 = t1.get$sembastClient();
              t2 = type$.Object;
              $async$returnValue = A.SembastRecordRefExtension_put(t3, t1, $async$self.value, t2, t2).then$1$1(new A.ObjectStoreSembast_putImpl__closure(id), t2);
              // goto return
              $async$goto = 1;
              break;
            case 4:
              // join
            case 1:
              // return
              return A._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return A._asyncStartSync($async$call$1, $async$completer);
    },
    $signature: 49
  };
  A.ObjectStoreSembast_putImpl__closure.prototype = {
    call$1(__wc1_formal) {
      type$.Object._as(__wc1_formal);
      return this.key;
    },
    $signature: 50
  };
  A.ObjectStoreSembast_clear_closure.prototype = {
    call$0() {
      var t1 = this.$this,
        t2 = type$.Object;
      return A.SembastStoreRefExtension_delete(t1.get$sembastStore(), t1.get$sembastClient(), null, t2, t2);
    },
    $signature: 51
  };
  A.ObjectStoreSembast_clear_closure0.prototype = {
    call$1(__wc0_formal) {
      A._asInt(__wc0_formal);
      return null;
    },
    $signature: 52
  };
  A.ObjectStoreSembast_delete_closure.prototype = {
    call$0() {
      return this.$this.txnDelete$1(this.keyOrRange);
    },
    $signature: 5
  };
  A.ObjectStoreSembast_getObject_closure.prototype = {
    call$0() {
      var $async$goto = 0,
        $async$completer = A._makeAsyncAwaitCompleter(type$.nullable_Object),
        $async$returnValue, $async$self = this, t1, $async$temp1;
      var $async$call$0 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return A._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = $async$self.$this;
              $async$temp1 = t1;
              $async$goto = 3;
              return A._asyncAwait(t1.txnGetSnapshot$1($async$self.key), $async$call$0);
            case 3:
              // returning from await.
              $async$returnValue = $async$temp1.recordToValue$1($async$result);
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return A._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return A._asyncStartSync($async$call$0, $async$completer);
    },
    $signature: 5
  };
  A.ObjectStoreSembast_openCursor_closure.prototype = {
    call$0() {
      return this.ctlr.openCursor$0();
    },
    $signature: 1
  };
  A.ObjectStoreSembast_put_closure.prototype = {
    call$0() {
      var t1 = this.$this,
        value = A.toSembastValue(this.value);
      return t1.putImpl$2(value, t1.getKeyImpl$2(value, this.key));
    },
    $signature: 21
  };
  A._ObjectStoreSembast_ObjectStore_ObjectStoreWithMetaMixin.prototype = {};
  A.TransactionSembast.prototype = {
    _execute$1(i) {
      var completer,
        t1 = this._completers;
      if (!(i < t1.length))
        return A.ioore(t1, i);
      completer = t1[i];
      t1 = this._actions;
      if (!(i < t1.length))
        return A.ioore(t1, i);
      t1 = A.Future_Future$sync(type$.dynamic_Function._as(t1[i]), type$.dynamic).then$1$1(new A.TransactionSembast__execute_closure(i, completer), type$.Null).catchError$1(new A.TransactionSembast__execute_closure0(i, completer));
      return t1;
    },
    _sembast_transaction$_next$0() {
      var _this = this,
        t1 = _this._sembast_transaction$_index;
      if (t1 < _this._actions.length) {
        _this._sembast_transaction$_index = t1 + 1;
        return _this._execute$1(t1).then$1$1(new A.TransactionSembast__next_closure(_this), type$.dynamic);
      } else {
        t1 = new A.TransactionSembast__next_checkNextAction(_this).call$0();
        return t1;
      }
    },
    execute$1$1(action, $T) {
      var _this = this,
        actionFuture = _this._enqueue$1$1($T._eval$1("0/()")._as(action), $T);
      B.JSArray_methods.add$1(_this._futures, actionFuture);
      if (_this._lazyExecution == null)
        _this._lazyExecution = A.Future_Future$sync(new A.TransactionSembast_execute_sembastAction(_this), type$.dynamic);
      return actionFuture;
    },
    _enqueue$1$1(action, $T) {
      var t1, t2;
      $T._eval$1("0/()")._as(action);
      if (this._inactive) {
        t1 = A._interceptUserError(new A.DatabaseError("TransactionInactiveError"), null);
        t2 = new A._Future($.Zone__current, $T._eval$1("_Future<0>"));
        t2._asyncCompleteErrorObject$1(t1);
        return t2;
      }
      t1 = new A._Future($.Zone__current, $T._eval$1("_Future<0>"));
      B.JSArray_methods.add$1(this._completers, new A._SyncCompleter(t1, $T._eval$1("_SyncCompleter<0>")));
      B.JSArray_methods.add$1(this._actions, action);
      return t1.then$1$1(new A.TransactionSembast__enqueue_closure($T), $T);
    },
    TransactionSembast$2(database, meta) {
      A._delayedInit().then$1$1(new A.TransactionSembast_closure(this), type$.Null);
    },
    get$_completed() {
      var $async$goto = 0,
        $async$completer = A._makeAsyncAwaitCompleter(type$.void),
        $async$handler = 1, $async$errorStack = [], $async$self = this, e, t1, exception, $async$exception;
      var $async$get$_completed = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1) {
          $async$errorStack.push($async$result);
          $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$handler = 3;
              t1 = $async$self._lazyExecution;
              $async$goto = t1 == null ? 6 : 8;
              break;
            case 6:
              // then
              $async$self._inactive = true;
              // goto join
              $async$goto = 7;
              break;
            case 8:
              // else
              $async$goto = 9;
              return A._asyncAwait(t1.then$1$1(new A.TransactionSembast__completed_closure($async$self), type$.Null), $async$get$_completed);
            case 9:
              // returning from await.
            case 7:
              // join
              $async$handler = 1;
              // goto after finally
              $async$goto = 5;
              break;
            case 3:
              // catch
              $async$handler = 2;
              $async$exception = $async$errorStack.pop();
              e = A.unwrapException($async$exception);
              throw $async$exception;
              // goto after finally
              $async$goto = 5;
              break;
            case 2:
              // uncaught
              // goto rethrow
              $async$goto = 1;
              break;
            case 5:
              // after finally
              // implicit return
              return A._asyncReturn(null, $async$completer);
            case 1:
              // rethrow
              return A._asyncRethrow($async$errorStack.at(-1), $async$completer);
          }
      });
      return A._asyncStartSync($async$get$_completed, $async$completer);
    },
    get$completed() {
      var $async$goto = 0,
        $async$completer = A._makeAsyncAwaitCompleter(type$.Database),
        $async$returnValue, $async$handler = 2, $async$errorStack = [], $async$self = this, exception, $async$exception;
      var $async$get$completed = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1) {
          $async$errorStack.push($async$result);
          $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$goto = 3;
              return A._asyncAwait(A.Future_Future$value(null, type$.void), $async$get$completed);
            case 3:
              // returning from await.
              $async$handler = 5;
              $async$goto = 8;
              return A._asyncAwait($async$self.get$_completed(), $async$get$completed);
            case 8:
              // returning from await.
              $async$handler = 2;
              // goto after finally
              $async$goto = 7;
              break;
            case 5:
              // catch
              $async$handler = 4;
              $async$exception = $async$errorStack.pop();
              // goto after finally
              $async$goto = 7;
              break;
            case 4:
              // uncaught
              // goto rethrow
              $async$goto = 2;
              break;
            case 7:
              // after finally
              $async$returnValue = $async$self._completedCompleter.future;
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return A._asyncReturn($async$returnValue, $async$completer);
            case 2:
              // rethrow
              return A._asyncRethrow($async$errorStack.at(-1), $async$completer);
          }
      });
      return A._asyncStartSync($async$get$completed, $async$completer);
    },
    objectStore$1($name) {
      this.meta.checkObjectStore$1($name);
      return new A.ObjectStoreSembast(type$.DatabaseSembast._as(this.database).meta._stores.$index(0, $name), this);
    }
  };
  A.TransactionSembast__execute_closure.prototype = {
    call$1(result) {
      this.completer.complete$1(result);
    },
    $signature: 7
  };
  A.TransactionSembast__execute_closure0.prototype = {
    call$2(e, st) {
      type$.Object._as(e);
      type$.StackTrace._as(st);
      this.completer.completeError$2(e, st);
    },
    $signature: 16
  };
  A.TransactionSembast__next_closure.prototype = {
    call$1(__wc0_formal) {
      return this.$this._sembast_transaction$_next$0();
    },
    $signature: 82
  };
  A.TransactionSembast__next_checkNextAction.prototype = {
    call$0() {
      var t1 = this.$this;
      if (t1._sembast_transaction$_index < t1._actions.length)
        return t1._sembast_transaction$_next$0();
      t1._inactive = true;
      return A.Future_Future$value(null, type$.dynamic);
    },
    $signature: 1
  };
  A.TransactionSembast_execute_sembastAction.prototype = {
    call$0() {
      var t1 = this.$this;
      return type$.DatabaseSembast._as(t1.database).db.transaction$1$1(new A.TransactionSembast_execute_sembastAction_closure(t1), type$.dynamic).whenComplete$1(new A.TransactionSembast_execute_sembastAction_closure0(t1)).catchError$1(new A.TransactionSembast_execute_sembastAction_closure1(t1));
    },
    $signature: 1
  };
  A.TransactionSembast_execute_sembastAction_closure.prototype = {
    call$1(txn) {
      return this.$call$body$TransactionSembast_execute_sembastAction_closure(txn);
    },
    $call$body$TransactionSembast_execute_sembastAction_closure(txn) {
      var $async$goto = 0,
        $async$completer = A._makeAsyncAwaitCompleter(type$.dynamic),
        $async$returnValue, $async$self = this, result, t1;
      var $async$call$1 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return A._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = $async$self.$this;
              t1.sembastTransaction = txn;
              $async$goto = 3;
              return A._asyncAwait(t1._sembast_transaction$_next$0(), $async$call$1);
            case 3:
              // returning from await.
              result = $async$result;
              t1 = t1._endException;
              if (t1 != null)
                throw A.wrapException(t1);
              $async$returnValue = result;
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return A._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return A._asyncStartSync($async$call$1, $async$completer);
    },
    $signature: 55
  };
  A.TransactionSembast_execute_sembastAction_closure0.prototype = {
    call$0() {
      var t1 = this.$this._transactionCompleter;
      if ((t1.future._state & 30) === 0)
        t1.complete$0();
    },
    $signature: 8
  };
  A.TransactionSembast_execute_sembastAction_closure1.prototype = {
    call$1(e) {
      var t1;
      type$.Object._as(e);
      t1 = this.$this._transactionCompleter;
      if ((t1.future._state & 30) === 0)
        t1.completeError$1(e);
    },
    $signature: 56
  };
  A.TransactionSembast__enqueue_closure.prototype = {
    call$1(result) {
      return this.T._as(result);
    },
    $signature() {
      return this.T._eval$1("0(0)");
    }
  };
  A.TransactionSembast_closure.prototype = {
    call$1(__wc0_formal) {
      var $async$goto = 0,
        $async$completer = A._makeAsyncAwaitCompleter(type$.Null),
        $async$handler = 1, $async$errorStack = [], $async$self = this, e, exception, t1, t2, $async$exception;
      var $async$call$1 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1) {
          $async$errorStack.push($async$result);
          $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$handler = 3;
              $async$goto = 6;
              return A._asyncAwait($async$self.$this.get$_completed(), $async$call$1);
            case 6:
              // returning from await.
              $async$handler = 1;
              // goto after finally
              $async$goto = 5;
              break;
            case 3:
              // catch
              $async$handler = 2;
              $async$exception = $async$errorStack.pop();
              e = A.unwrapException($async$exception);
              // goto after finally
              $async$goto = 5;
              break;
            case 2:
              // uncaught
              // goto rethrow
              $async$goto = 1;
              break;
            case 5:
              // after finally
              t1 = $async$self.$this;
              t1._inactive = true;
              $async$goto = 7;
              return A._asyncAwait(A.Future_Future$value(null, type$.void), $async$call$1);
            case 7:
              // returning from await.
              t2 = t1._completedCompleter;
              if ((t2.future._state & 30) === 0)
                t2.complete$1(type$.DatabaseSembast._as(t1.database));
              // implicit return
              return A._asyncReturn(null, $async$completer);
            case 1:
              // rethrow
              return A._asyncRethrow($async$errorStack.at(-1), $async$completer);
          }
      });
      return A._asyncStartSync($async$call$1, $async$completer);
    },
    $signature: 57
  };
  A.TransactionSembast__completed_closure.prototype = {
    call$1(__wc0_formal) {
      var $async$goto = 0,
        $async$completer = A._makeAsyncAwaitCompleter(type$.Null),
        $async$handler = 1, $async$errorStack = [], $async$self = this, t1, e, t2, exception, $async$exception;
      var $async$call$1 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1) {
          $async$errorStack.push($async$result);
          $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$handler = 3;
              t2 = $async$self.$this;
              t1 = A._setArrayType([t2._transactionCompleter.future], type$.JSArray_Future_dynamic);
              J.addAll$1$ax(t1, t2._futures);
              $async$goto = 6;
              return A._asyncAwait(A.Future_wait(t1, type$.dynamic), $async$call$1);
            case 6:
              // returning from await.
              $async$handler = 1;
              // goto after finally
              $async$goto = 5;
              break;
            case 3:
              // catch
              $async$handler = 2;
              $async$exception = $async$errorStack.pop();
              e = A.unwrapException($async$exception);
              $async$self.$this._endException = new A.DatabaseException0(J.toString$0$(e));
              // goto after finally
              $async$goto = 5;
              break;
            case 2:
              // uncaught
              // goto rethrow
              $async$goto = 1;
              break;
            case 5:
              // after finally
              // implicit return
              return A._asyncReturn(null, $async$completer);
            case 1:
              // rethrow
              return A._asyncRethrow($async$errorStack.at(-1), $async$completer);
          }
      });
      return A._asyncStartSync($async$call$1, $async$completer);
    },
    $signature: 58
  };
  A._TransactionSembast_IdbTransactionBase_TransactionWithMetaMixin.prototype = {};
  A._toSembastValue_closure.prototype = {
    call$2(key, item) {
      var t1, t2,
        converted = A._toSembastValue(item);
      if (converted == null ? item != null : converted !== item) {
        t1 = this._box_0;
        t2 = t1.clone;
        (t2 == null ? t1.clone = A.LinkedHashMap_LinkedHashMap$from(this.map, type$.String, type$.nullable_Object) : t2).$indexSet(0, key, converted);
      }
    },
    $signature: 4
  };
  A._fromSembastValue_closure.prototype = {
    call$2(key, item) {
      var t1, t2,
        converted = A._fromSembastValue(item);
      if (converted == null ? item != null : converted !== item) {
        t1 = this._box_0;
        t2 = t1.clone;
        (t2 == null ? t1.clone = A.LinkedHashMap_LinkedHashMap$from(this.map, type$.String, type$.nullable_Object) : t2).$indexSet(0, key, converted);
      }
    },
    $signature: 4
  };
  A.DatabaseMode.prototype = {
    get$hashCode(_) {
      return this._mode;
    },
    $eq(_, other) {
      if (other == null)
        return false;
      if (other instanceof A.DatabaseMode)
        return other._mode === this._mode;
      return false;
    },
    toString$0(_) {
      var _this = this;
      if (B.DatabaseMode_0.$eq(0, _this))
        return "DatabaseMode.create";
      else if (B.DatabaseMode_1.$eq(0, _this))
        return "DatabaseMode.existing";
      else if (B.DatabaseMode_2.$eq(0, _this))
        return "DatabaseMode.empty";
      else if (B.DatabaseMode_3.$eq(0, _this))
        return "DatabaseMode.neverFails";
      return _this.super$Object$toString(0);
    }
  };
  A.DatabaseException.prototype = {
    toString$0(_) {
      return "[" + this._code + "] " + this._exception$_message;
    },
    $isException: 1
  };
  A.SortOrder.prototype = {};
  A.Blob.prototype = {
    get$length(_) {
      return this.bytes.length;
    },
    get$hashCode(_) {
      return this.bytes.length;
    },
    $eq(_, other) {
      if (other == null)
        return false;
      return other instanceof A.Blob && new A.Blob_operator$eq_closure(this, other).call$0();
    },
    toString$0(_) {
      return "Blob(len: " + this.bytes.length + ")";
    },
    compareTo$1(_, other) {
      var t1, t2, t3, t4, i, cmp;
      for (t1 = this.bytes, t2 = t1.length, t3 = type$.Blob._as(other).bytes, t4 = t3.length, i = 0; i < t2; ++i)
        if (i < t4) {
          if (!(i < t2))
            return A.ioore(t1, i);
          cmp = t1[i] - t3[i];
          if (cmp !== 0)
            return cmp;
        } else
          return 1;
      return t2 - t4;
    },
    $isComparable: 1
  };
  A.Blob_operator$eq_closure.prototype = {
    call$0() {
      var i, t5,
        t1 = this.other.bytes,
        t2 = t1.length,
        t3 = this.$this.bytes,
        t4 = t3.length;
      if (t2 !== t4)
        return false;
      for (i = 0; i < t4; ++i) {
        t5 = t3[i];
        if (!(i < t2))
          return A.ioore(t1, i);
        if (t5 !== t1[i])
          return false;
      }
      return true;
    },
    $signature: 59
  };
  A.DatabaseChangesListener.prototype = {
    get$_allStoresChangesListeners() {
      null.toString;
      return null;
    },
    get$hasStoreChanges() {
      for (var t1 = this._changes_listener$_stores, t1 = new A.LinkedHashMapValueIterator(t1, t1._modifications, t1._first, A._instanceType(t1)._eval$1("LinkedHashMapValueIterator<2>")); t1.moveNext$0();)
        if (t1.__js_helper$_current.get$hasChanges())
          return true;
      return false;
    },
    get$hasGlobalChanges() {
      return false;
    },
    addChange$2(oldSnapshot, newSnapshot) {
      var store, t1;
      if (oldSnapshot == null)
        store = null;
      else {
        t1 = oldSnapshot.RecordSnapshotMixin___RecordSnapshotMixin_ref_A;
        t1 === $ && A.throwLateFieldNI("ref");
        t1 = t1.RecordRefMixin___RecordRefMixin_store_A;
        t1 === $ && A.throwLateFieldNI("store");
        store = t1;
      }
      if (store == null)
        if (newSnapshot == null)
          store = null;
        else {
          t1 = newSnapshot.RecordSnapshotMixin___RecordSnapshotMixin_ref_A;
          t1 === $ && A.throwLateFieldNI("ref");
          t1 = t1.RecordRefMixin___RecordRefMixin_store_A;
          t1 === $ && A.throwLateFieldNI("store");
          store = t1;
        }
      this._changes_listener$_stores.$index(0, store);
    },
    _hasGlobalChangeListener$1(ref) {
      return false;
    },
    txnClearChanges$0() {
      for (var t1 = this._changes_listener$_stores, t1 = new A.LinkedHashMapValueIterator(t1, t1._modifications, t1._first, A._instanceType(t1)._eval$1("LinkedHashMapValueIterator<2>")); t1.moveNext$0();)
        t1.__js_helper$_current.txnClearChanges$0();
    },
    handleGlobalChanges$1(txn) {
      return this.handleGlobalChanges$body$DatabaseChangesListener(txn);
    },
    handleGlobalChanges$body$DatabaseChangesListener(txn) {
      var $async$goto = 0,
        $async$completer = A._makeAsyncAwaitCompleter(type$.void),
        $async$self = this;
      var $async$handleGlobalChanges$1 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return A._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$goto = 2;
              return A._asyncAwait($async$self.get$_allStoresChangesListeners().handleChanges$1(txn), $async$handleGlobalChanges$1);
            case 2:
              // returning from await.
              // implicit return
              return A._asyncReturn(null, $async$completer);
          }
      });
      return A._asyncStartSync($async$handleGlobalChanges$1, $async$completer);
    }
  };
  A.Cooperator.prototype = {
    get$needCooperate() {
      var t1 = this._paused || this._cooperateStopWatch.get$elapsedMicroseconds() > 24000;
      return t1;
    },
    cooperate$0() {
      var t1, _this = this;
      if (_this.get$needCooperate()) {
        t1 = type$.dynamic;
        if (!_this._paused) {
          _this._paused = true;
          return A.Future_Future$delayed(A.Duration$(1, 0), null, t1).then$1$1(new A.Cooperator_cooperate_closure(_this), t1);
        } else
          return A.Future_Future$delayed(A.Duration$(1, 0), null, t1);
      } else
        return null;
    }
  };
  A.Cooperator_cooperate_closure.prototype = {
    call$1(__wc0_formal) {
      var t1 = this.$this,
        t2 = t1._cooperateStopWatch,
        t3 = t2._stop;
      if (t3 == null)
        t3 = t2._stop = $.Primitives_timerTicks.call$0();
      t2._core$_start = t3;
      t2.start$0();
      t1._paused = false;
    },
    $signature: 7
  };
  A.StoreContent.prototype = {
    addAll$1(_, records) {
      var t1, t2, t3, t4;
      type$.Iterable_ImmutableSembastRecord._as(records);
      for (t1 = records.get$iterator(records), t2 = this._database_content$_map; t1.moveNext$0();) {
        t3 = t1.get$current();
        t4 = A.RecordSnapshotMixin.prototype.get$key.call(t3);
        t2.$indexSet(0, t4, t3);
      }
    },
    toString$0(_) {
      var t1 = this.store.StoreRefMixin___StoreRefMixin_name_A;
      t1 === $ && A.throwLateFieldNI("name");
      return t1 + " " + this._database_content$_map.__js_helper$_length;
    }
  };
  A.DatabaseContent.prototype = {
    addStore$1(store) {
      var t1 = this._database_content$_map,
        $content = t1.$index(0, store);
      if ($content == null) {
        $content = new A.StoreContent(store, A.LinkedHashMap_LinkedHashMap$_empty(type$.nullable_Object, type$.ImmutableSembastRecord));
        t1.$indexSet(0, store, $content);
      }
      return $content;
    },
    toString$0(_) {
      var t1 = this._database_content$_map;
      return new A.LinkedHashMapValuesIterable(t1, A._instanceType(t1)._eval$1("LinkedHashMapValuesIterable<2>")).toString$0(0);
    }
  };
  A.DatabaseListenerContent.prototype = {
    getAndRemoveFirstStore$0() {
      var storeContent,
        t1 = this._database_content$_map;
      if (t1.__js_helper$_length !== 0) {
        storeContent = new A.LinkedHashMapValuesIterable(t1, A._instanceType(t1)._eval$1("LinkedHashMapValuesIterable<2>")).get$first(0);
        t1.remove$1(0, storeContent.store);
        return storeContent;
      }
      return null;
    }
  };
  A.TxnDatabaseContent.prototype = {
    addTxnStoreRecords$2(store, records) {
      var t1;
      type$.Iterable_TxnRecord._as(records);
      t1 = A._arrayInstanceType(records);
      this.addStore$1(store).addAll$1(0, new A.MappedListIterable(records, t1._eval$1("ImmutableSembastRecord(1)")._as(new A.TxnDatabaseContent_addTxnStoreRecords_closure()), t1._eval$1("MappedListIterable<1,ImmutableSembastRecord>")));
      B.JSArray_methods.addAll$1(this._records, records);
    }
  };
  A.TxnDatabaseContent_addTxnStoreRecords_closure.prototype = {
    call$1(record) {
      return type$.TxnRecord._as(record).record;
    },
    $signature: 22
  };
  A.SembastDatabaseFactory.prototype = {$isDatabaseFactory: 1};
  A.SembastDatabaseFactoryMixin.prototype = {
    openDatabaseWithOptions$2(path, options) {
      var helper = this.SembastDatabaseFactoryMixin__databaseOpenHelpers.$index(0, path);
      if (helper == null) {
        helper = A.DatabaseOpenHelper$(this, path, options);
        this.setDatabaseOpenHelper$2(path, helper);
      }
      return helper.openDatabase$0();
    },
    setDatabaseOpenHelper$2(path, helper) {
      var t1 = this.SembastDatabaseFactoryMixin__databaseOpenHelpers;
      t1.remove$1(0, path);
      t1.$indexSet(0, path, helper);
    },
    deleteDatabase$1(path) {
      return this.deleteDatabase$body$SembastDatabaseFactoryMixin(path);
    },
    deleteDatabase$body$SembastDatabaseFactoryMixin(path) {
      var $async$goto = 0,
        $async$completer = A._makeAsyncAwaitCompleter(type$.dynamic),
        $async$returnValue, $async$self = this, helper;
      var $async$deleteDatabase$1 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return A._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              helper = $async$self.SembastDatabaseFactoryMixin__databaseOpenHelpers.$index(0, path);
              $async$goto = helper != null && helper.database != null ? 3 : 4;
              break;
            case 3:
              // then
              $async$goto = 5;
              return A._asyncAwait(helper.lock.synchronized$1$1(new A.SembastDatabaseFactoryMixin_deleteDatabase_closure(helper), type$.dynamic), $async$deleteDatabase$1);
            case 5:
              // returning from await.
            case 4:
              // join
              $async$returnValue = $async$self.doDeleteDatabase$1(path);
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return A._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return A._asyncStartSync($async$deleteDatabase$1, $async$completer);
    }
  };
  A.SembastDatabaseFactoryMixin_deleteDatabase_closure.prototype = {
    call$0() {
      return this.helper.lockedCloseDatabase$0();
    },
    $signature: 1
  };
  A.CommitEntries.prototype = {
    get$hasWriteData() {
      var t1 = this.txnRecords;
      t1 = t1 == null ? null : t1.length !== 0;
      return t1 === true;
    },
    set$txnRecords(txnRecords) {
      this.txnRecords = type$.nullable_List_TxnRecord._as(txnRecords);
    }
  };
  A.CommitData.prototype = {};
  A.SembastDatabaseMixin.prototype = {};
  A.SembastDatabase.prototype = {
    get$path() {
      return this._storageBase.path;
    },
    _clearTxnData$0() {
      var t1, _this = this;
      B.JSArray_methods.clear$0(_this._txnDroppedStores);
      _this._txnStoreLastIntKeys.clear$0(0);
      _this.changesListener.txnClearChanges$0();
      for (t1 = _this._database_impl$_stores, t1 = new A.LinkedHashMapValueIterator(t1, t1._modifications, t1._first, A._instanceType(t1)._eval$1("LinkedHashMapValueIterator<2>")); t1.moveNext$0();)
        t1.__js_helper$_current.txnRecords = null;
    },
    generateUniqueIntKey$1(store) {
      return this.generateUniqueIntKey$body$SembastDatabase(store);
    },
    generateUniqueIntKey$body$SembastDatabase(store) {
      var $async$goto = 0,
        $async$completer = A._makeAsyncAwaitCompleter(type$.nullable_int),
        $async$returnValue;
      var $async$generateUniqueIntKey$1 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return A._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$returnValue = null;
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return A._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return A._asyncStartSync($async$generateUniqueIntKey$1, $async$completer);
    },
    generateUniqueStringKey$1(store) {
      return this.generateUniqueStringKey$body$SembastDatabase(store);
    },
    generateUniqueStringKey$body$SembastDatabase(store) {
      var $async$goto = 0,
        $async$completer = A._makeAsyncAwaitCompleter(type$.nullable_String),
        $async$returnValue;
      var $async$generateUniqueStringKey$1 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return A._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$returnValue = null;
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return A._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return A._asyncStartSync($async$generateUniqueStringKey$1, $async$completer);
    },
    txnCompact$0() {
      var $async$goto = 0,
        $async$completer = A._makeAsyncAwaitCompleter(type$.dynamic),
        $async$handler = 1, $async$errorStack = [], $async$next = [], $async$self = this, exportStat, sink, lines, writeCurrent, addStringLine, hasAsyncCodec, addLine, stores, store, records, record, _box_0, exportStat0, t3, _i, records0, t4, t5, _i0, t6, map, t1, t2;
      var $async$txnCompact$0 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1) {
          $async$errorStack.push($async$result);
          $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = $async$self._storageFs;
              t2 = t1 == null && null;
              $async$goto = t2 === true ? 2 : 3;
              break;
            case 2:
              // then
              _box_0 = {};
              t1.toString;
              null.toString;
              exportStat0 = new A.DatabaseExportStat();
              exportStat0.compactCount = $async$self._exportStat.compactCount + 1;
              exportStat = exportStat0;
              $async$goto = 4;
              return A._asyncAwait(null.delete$0(), $async$txnCompact$0);
            case 4:
              // returning from await.
              $async$goto = 5;
              return A._asyncAwait(null.findOrCreate$0(), $async$txnCompact$0);
            case 5:
              // returning from await.
              _box_0.currentWriteSize = 0;
              $async$goto = 6;
              return A._asyncAwait(null.openAppend$0(), $async$txnCompact$0);
            case 6:
              // returning from await.
              sink = $async$result;
              $async$handler = 7;
              lines = A._setArrayType([], type$.JSArray_String);
              writeCurrent = new A.SembastDatabase_txnCompact_writeCurrent(_box_0, lines, sink);
              addStringLine = new A.SembastDatabase_txnCompact_addStringLine(_box_0, $async$self, exportStat, lines, writeCurrent);
              A.sembastCodecContentCodec($async$self.openHelper.options.codec);
              hasAsyncCodec = false;
              addLine = new A.SembastDatabase_txnCompact_addLine($async$self, hasAsyncCodec, addStringLine);
              $async$goto = 10;
              return A._asyncAwait(addStringLine.call$1(B.C_JsonCodec.encode$1($async$self._meta.toMap$0())), $async$txnCompact$0);
            case 10:
              // returning from await.
              t1 = $async$self._database_impl$_stores;
              t2 = type$.SembastStore;
              stores = A.List_List$from(new A.LinkedHashMapValuesIterable(t1, A._instanceType(t1)._eval$1("LinkedHashMapValuesIterable<2>")), true, t2);
              t1 = stores, t3 = t1.length, _i = 0;
            case 11:
              // for condition
              if (!(_i < t1.length)) {
                // goto after for
                $async$goto = 13;
                break;
              }
              store = t1[_i];
              records0 = t2._as(store)._currentRecordsCache;
              records = records0;
              t4 = records, t5 = t4.length, _i0 = 0;
            case 14:
              // for condition
              if (!(_i0 < t4.length)) {
                // goto after for
                $async$goto = 16;
                break;
              }
              record = t4[_i0];
              t6 = record;
              map = t6._toBaseMap$0();
              if (!t6.get$deleted())
                map.$indexSet(0, "value", t6.get$value());
              $async$goto = 17;
              return A._asyncAwait(addLine.call$1(map), $async$txnCompact$0);
            case 17:
              // returning from await.
            case 15:
              // for update
              t4.length === t5 || (0, A.throwConcurrentModificationError)(t4), ++_i0;
              // goto for condition
              $async$goto = 14;
              break;
            case 16:
              // after for
            case 12:
              // for update
              t1.length === t3 || (0, A.throwConcurrentModificationError)(t1), ++_i;
              // goto for condition
              $async$goto = 11;
              break;
            case 13:
              // after for
              $async$goto = 18;
              return A._asyncAwait(writeCurrent.call$0(), $async$txnCompact$0);
            case 18:
              // returning from await.
              $async$next.push(9);
              // goto finally
              $async$goto = 8;
              break;
            case 7:
              // uncaught
              $async$next = [1];
            case 8:
              // finally
              $async$handler = 1;
              $async$goto = 19;
              return A._asyncAwait(sink.close$0(), $async$txnCompact$0);
            case 19:
              // returning from await.
              // goto the next finally handler
              $async$goto = $async$next.pop();
              break;
            case 9:
              // after finally
              $async$goto = 20;
              return A._asyncAwait($async$self._storageFs.tmpRecover$0(), $async$txnCompact$0);
            case 20:
              // returning from await.
            case 3:
              // join
              // implicit return
              return A._asyncReturn(null, $async$completer);
            case 1:
              // rethrow
              return A._asyncRethrow($async$errorStack.at(-1), $async$completer);
          }
      });
      return A._asyncStartSync($async$txnCompact$0, $async$completer);
    },
    _getTxnDatabaseContent$0() {
      var t1, t2, t3, t4, records,
        $content = new A.TxnDatabaseContent(A._setArrayType([], type$.JSArray_TxnRecord), A.LinkedHashMap_LinkedHashMap$_empty(type$.StoreRef_of_nullable_Object_and_nullable_Object, type$.StoreContent));
      for (t1 = this._database_impl$_stores, t1 = new A.LinkedHashMapValueIterator(t1, t1._modifications, t1._first, A._instanceType(t1)._eval$1("LinkedHashMapValueIterator<2>")), t2 = type$.TxnRecord; t1.moveNext$0();) {
        t3 = t1.__js_helper$_current;
        t4 = t3.txnRecords;
        records = t4 == null ? null : A.List_List$from(new A.LinkedHashMapValuesIterable(t4, A._instanceType(t4)._eval$1("LinkedHashMapValuesIterable<2>")), false, t2);
        t4 = records == null ? null : records.length !== 0;
        if (t4 === true) {
          t3 = t3.ref;
          records.toString;
          $content.addTxnStoreRecords$2(t3, records);
        }
      }
      return $content;
    },
    commitInMemory$0() {
      var t1, t2, t3, _i, t4, store, _this = this,
        $content = _this._getTxnDatabaseContent$0(),
        txnRecords = $content._records,
        commitData = new A.CommitData();
      commitData.set$txnRecords(txnRecords);
      if (txnRecords.length !== 0)
        new A.SembastDatabase_commitInMemory_saveInMemory(_this, txnRecords).call$0();
      t1 = _this._txnDroppedStores;
      t2 = t1.length;
      if (t2 !== 0)
        for (t3 = _this._database_impl$_stores, _i = 0; _i < t1.length; t1.length === t2 || (0, A.throwConcurrentModificationError)(t1), ++_i)
          t3.remove$1(0, t1[_i]);
      t1 = _this.listener._listener$_stores;
      if (t1.__js_helper$_length !== 0)
        for (t2 = $content._database_content$_map, t2 = new A.LinkedHashMapValueIterator(t2, t2._modifications, t2._first, A._instanceType(t2)._eval$1("LinkedHashMapValueIterator<2>")); t2.moveNext$0();) {
          t3 = t2.__js_helper$_current;
          t4 = t3._database_content$_map;
          store = t3.store;
          if (!new A.LinkedHashMapValuesIterable(t4, A._instanceType(t4)._eval$1("LinkedHashMapValuesIterable<2>")).get$isEmpty(0))
            t1.$index(0, store);
        }
      return commitData;
    },
    storageCommitRecords$1(txnRecords) {
      return this.storageCommitRecords$body$SembastDatabase(type$.List_TxnRecord._as(txnRecords));
    },
    storageCommitRecords$body$SembastDatabase(txnRecords) {
      var $async$goto = 0,
        $async$completer = A._makeAsyncAwaitCompleter(type$.dynamic),
        $async$handler = 1, $async$errorStack = [], $async$self = this, lines, map, encoded, encodedOrFuture, t1, t2, t3, t4, _i, t5, map0, t6, exception, $async$exception;
      var $async$storageCommitRecords$1 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1) {
          $async$errorStack.push($async$result);
          $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$goto = txnRecords.length !== 0 ? 2 : 3;
              break;
            case 2:
              // then
              lines = A._setArrayType([], type$.JSArray_String);
              $async$goto = $async$self._storageFs != null ? 4 : 5;
              break;
            case 4:
              // then
              t1 = txnRecords.length, t2 = type$.Map_dynamic_dynamic, t3 = type$._Future_String, t4 = type$.Future_String, _i = 0;
            case 6:
              // for condition
              if (!(_i < txnRecords.length)) {
                // goto after for
                $async$goto = 8;
                break;
              }
              t5 = txnRecords[_i].record;
              map0 = t5._toBaseMap$0();
              if (!t5.get$deleted())
                map0.$indexSet(0, "value", t5.get$value());
              map = map0;
              encoded = null;
              $async$handler = 10;
              t5 = t2._as(map);
              t6 = $.$get$sembastDefaultJsonEncodableCodec();
              A._instanceType(t6)._eval$1("Codec.S")._as(t5);
              encodedOrFuture = A.SembastContentCodecAsyncSupport_encodeContent(B.C_JsonCodec, t2._as(t6.get$encoder().convert$1(t5)));
              $async$goto = encodedOrFuture instanceof A._Future ? 13 : 15;
              break;
            case 13:
              // then
              t5 = encodedOrFuture;
              if (!t4._is(t5)) {
                A._asString(t5);
                t6 = new A._Future($.Zone__current, t3);
                t6._state = 8;
                t6._resultOrListeners = t5;
                t5 = t6;
              }
              $async$goto = 16;
              return A._asyncAwait(t5, $async$storageCommitRecords$1);
            case 16:
              // returning from await.
              encoded = $async$result;
              // goto join
              $async$goto = 14;
              break;
            case 15:
              // else
              encoded = encodedOrFuture;
            case 14:
              // join
              J.add$1$ax(lines, encoded);
              $async$handler = 1;
              // goto after finally
              $async$goto = 12;
              break;
            case 10:
              // catch
              $async$handler = 9;
              $async$exception = $async$errorStack.pop();
              A.getTraceFromException($async$exception);
              throw $async$exception;
              // goto after finally
              $async$goto = 12;
              break;
            case 9:
              // uncaught
              // goto rethrow
              $async$goto = 1;
              break;
            case 12:
              // after finally
            case 7:
              // for update
              txnRecords.length === t1 || (0, A.throwConcurrentModificationError)(txnRecords), ++_i;
              // goto for condition
              $async$goto = 6;
              break;
            case 8:
              // after for
              $async$goto = 17;
              return A._asyncAwait($async$self._storageFs.appendLines$1(lines), $async$storageCommitRecords$1);
            case 17:
              // returning from await.
            case 5:
              // join
            case 3:
              // join
              // implicit return
              return A._asyncReturn(null, $async$completer);
            case 1:
              // rethrow
              return A._asyncRethrow($async$errorStack.at(-1), $async$completer);
          }
      });
      return A._asyncStartSync($async$storageCommitRecords$1, $async$completer);
    },
    txnPutRecords$2(txn, records) {
      return this.txnPutRecords$body$SembastDatabase(txn, type$.List_ImmutableSembastRecord._as(records));
    },
    txnPutRecords$body$SembastDatabase(txn, records) {
      var $async$goto = 0,
        $async$completer = A._makeAsyncAwaitCompleter(type$.List_nullable_ImmutableSembastRecord),
        $async$returnValue, $async$self = this, t1, recordsResult, t2, i, t3, t4, t5, store, $async$temp1, $async$temp2, $async$temp3;
      var $async$txnPutRecords$2 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return A._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              records = A.List_List$from(records, true, type$.ImmutableSembastRecord);
              t1 = records.length;
              recordsResult = A.List_List$filled(t1, null, false, type$.nullable_ImmutableSembastRecord);
              t2 = $async$self._database_impl$_stores, i = 0;
            case 3:
              // for condition
              if (!(i < t1)) {
                // goto after for
                $async$goto = 5;
                break;
              }
              t3 = records[i];
              t4 = t3.get$ref().RecordRefMixin___RecordRefMixin_store_A;
              t4 === $ && A.throwLateFieldNI("store");
              if ($async$self._closed)
                A.throwExpression(A.DatabaseException$closed());
              t5 = t4.StoreRefMixin___StoreRefMixin_name_A;
              t5 === $ && A.throwLateFieldNI("name");
              store = t2.$index(0, t5);
              $async$temp1 = B.JSArray_methods;
              $async$temp2 = recordsResult;
              $async$temp3 = i;
              $async$goto = 6;
              return A._asyncAwait((store == null ? $async$self._addStore$1(t4.StoreRefMixin___StoreRefMixin_name_A) : store).txnPutRecord$2(txn, t3), $async$txnPutRecords$2);
            case 6:
              // returning from await.
              $async$temp1.$indexSet($async$temp2, $async$temp3, $async$result);
            case 4:
              // for update
              ++i;
              // goto for condition
              $async$goto = 3;
              break;
            case 5:
              // after for
              $async$returnValue = recordsResult;
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return A._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return A._asyncStartSync($async$txnPutRecords$2, $async$completer);
    },
    _addStore$1(storeName) {
      var t1, t2, store, _this = this;
      if (storeName == null)
        return _this._mainStore = _this._addStore$1("_main");
      else {
        t1 = A.SplayTreeMap$(A.utils__compareKey$closure(), type$.Object, type$.ImmutableSembastRecord);
        t2 = type$.nullable_Object;
        store = new A.SembastStore(_this, A.SembastStoreRef$(storeName, t2, t2), t1);
        _this._database_impl$_stores.$indexSet(0, storeName, store);
        return store;
      }
    },
    getSembastStore$1(ref) {
      var t1, store;
      if (this._closed)
        A.throwExpression(new A.DatabaseException(3, "database is closed"));
      t1 = ref.StoreRefMixin___StoreRefMixin_name_A;
      t1 === $ && A.throwLateFieldNI("name");
      store = this._database_impl$_stores.$index(0, t1);
      return store == null ? this._addStore$1(ref.StoreRefMixin___StoreRefMixin_name_A) : store;
    },
    txnDeleteStore$2(txn, storeName) {
      return this.txnDeleteStore$body$SembastDatabase(txn, storeName);
    },
    txnDeleteStore$body$SembastDatabase(txn, storeName) {
      var $async$goto = 0,
        $async$completer = A._makeAsyncAwaitCompleter(type$.void),
        $async$self = this, store;
      var $async$txnDeleteStore$2 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return A._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$goto = 2;
              return A._asyncAwait($async$self._txnClearStore$2(txn, storeName), $async$txnDeleteStore$2);
            case 2:
              // returning from await.
              store = $async$result;
              if (store != null)
                if (store.store !== $async$self._mainStore)
                  B.JSArray_methods.add$1($async$self._txnDroppedStores, storeName);
              // implicit return
              return A._asyncReturn(null, $async$completer);
          }
      });
      return A._asyncStartSync($async$txnDeleteStore$2, $async$completer);
    },
    _txnClearStore$2(txn, storeName) {
      return this._txnClearStore$body$SembastDatabase(txn, storeName);
    },
    _txnClearStore$body$SembastDatabase(txn, storeName) {
      var $async$goto = 0,
        $async$completer = A._makeAsyncAwaitCompleter(type$.nullable_SembastTransactionStore),
        $async$returnValue, $async$self = this, store;
      var $async$_txnClearStore$2 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return A._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              store = $async$self._database_impl$_stores.$index(0, storeName);
              store = store != null ? new A.SembastTransactionStore(store) : null;
              $async$goto = store != null ? 3 : 4;
              break;
            case 3:
              // then
              $async$goto = 5;
              return A._asyncAwait(store.store.txnClear$1(txn), $async$_txnClearStore$2);
            case 5:
              // returning from await.
            case 4:
              // join
              $async$returnValue = store;
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return A._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return A._asyncStartSync($async$_txnClearStore$2, $async$completer);
    },
    flush$0() {
      var $async$goto = 0,
        $async$completer = A._makeAsyncAwaitCompleter(type$.dynamic),
        $async$self = this;
      var $async$flush$0 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return A._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$goto = 2;
              return A._asyncAwait($async$self.transactionLock.synchronized$1$1(new A.SembastDatabase_flush_closure(), type$.Null), $async$flush$0);
            case 2:
              // returning from await.
              $async$goto = 3;
              return A._asyncAwait($async$self.databaseOperation$1(null), $async$flush$0);
            case 3:
              // returning from await.
              // implicit return
              return A._asyncReturn(null, $async$completer);
          }
      });
      return A._asyncStartSync($async$flush$0, $async$completer);
    },
    open$1(options) {
      return this.open$body$SembastDatabase(options);
    },
    open$body$SembastDatabase(options) {
      var $async$goto = 0,
        $async$completer = A._makeAsyncAwaitCompleter(type$.Database_2),
        $async$returnValue, $async$self = this, t1, mode;
      var $async$open$1 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return A._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = {};
              mode = $async$self.openHelper.openMode;
              t1.version = options.version;
              if ($async$self._opened) {
                $async$returnValue = $async$self;
                // goto return
                $async$goto = 1;
                break;
              }
              $async$goto = 3;
              return A._asyncAwait($async$self.databaseLock.synchronized$1$1(new A.SembastDatabase_open_closure(t1, $async$self, options, mode), type$.dynamic), $async$open$1);
            case 3:
              // returning from await.
              $async$goto = 4;
              return A._asyncAwait($async$self.flush$0(), $async$open$1);
            case 4:
              // returning from await.
              $async$returnValue = $async$self;
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return A._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return A._asyncStartSync($async$open$1, $async$completer);
    },
    _notifyLazilyJdbImportResult$1(result) {
      if (!result.delta)
        this._restartListeners$0();
      else
        this._notifyListeners$0();
    },
    txnJdbDeltaImport$1(revision) {
      var $async$goto = 0,
        $async$completer = A._makeAsyncAwaitCompleter(type$.JdbImportResult),
        $async$returnValue, $async$handler = 2, $async$errorStack = [], $async$next = [], $async$self = this, records, entry, record, delta, entries, t1, t2, t3, t4, t5, _i, store, minRevision, $async$temp1;
      var $async$txnJdbDeltaImport$1 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1) {
          $async$errorStack.push($async$result);
          $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              minRevision = $async$self._jdbRevision;
              if (minRevision == null)
                minRevision = 0;
              $async$temp1 = minRevision;
              $async$goto = 3;
              return A._asyncAwait($async$self._storageJdb.getDeltaMinRevision$0(), $async$txnJdbDeltaImport$1);
            case 3:
              // returning from await.
              delta = $async$temp1 >= $async$result;
              $async$goto = delta ? 4 : 6;
              break;
            case 4:
              // then
              $async$goto = 7;
              return A._asyncAwait($async$self._storageJdb.getEntriesAfter$1(minRevision), $async$txnJdbDeltaImport$1);
            case 7:
              // returning from await.
              entries = $async$result;
              if (!$async$self._closed) {
                for (t1 = J.get$iterator$ax(entries); t1.moveNext$0();) {
                  t2 = t1.get$current();
                  t3 = t2.txnRecord.record;
                  t4 = t3.RecordSnapshotMixin___RecordSnapshotMixin_ref_A;
                  t4 === $ && A.throwLateFieldNI("ref");
                  t5 = t3.SembastRecordMixin__deleted === true ? null : t2.get$value();
                  A.ImmutableSembastRecordJdb$(t4, t5, t3.SembastRecordMixin__deleted === true, t2.get$id());
                }
                $async$self._jdbRevision = revision;
              }
              // goto join
              $async$goto = 5;
              break;
            case 6:
              // else
              $async$self._exportStat = new A.DatabaseExportStat();
              records = A._setArrayType([], type$.JSArray_ImmutableSembastRecordJdb);
              t1 = new A._StreamIterator(A.checkNotNullable($async$self._storageJdb.get$entries(), "stream", type$.Object), type$._StreamIterator_JdbEntry);
              $async$handler = 8;
            case 11:
              // for condition
              $async$goto = 13;
              return A._asyncAwait(t1.moveNext$0(), $async$txnJdbDeltaImport$1);
            case 13:
              // returning from await.
              if (!$async$result) {
                // goto after for
                $async$goto = 12;
                break;
              }
              entry = t1.get$current();
              t2 = entry.txnRecord.record.RecordSnapshotMixin___RecordSnapshotMixin_ref_A;
              t2 === $ && A.throwLateFieldNI("ref");
              t3 = entry.txnRecord.record.SembastRecordMixin__deleted === true ? null : entry.get$value();
              record = A.ImmutableSembastRecordJdb$(t2, t3, entry.txnRecord.record.SembastRecordMixin__deleted === true, entry.get$id());
              // goto for condition
              $async$goto = 11;
              break;
            case 12:
              // after for
              $async$next.push(10);
              // goto finally
              $async$goto = 9;
              break;
            case 8:
              // uncaught
              $async$next = [2];
            case 9:
              // finally
              $async$handler = 2;
              $async$goto = 14;
              return A._asyncAwait(t1.cancel$0(), $async$txnJdbDeltaImport$1);
            case 14:
              // returning from await.
              // goto the next finally handler
              $async$goto = $async$next.pop();
              break;
            case 10:
              // after finally
              for (t1 = $async$self._database_impl$_stores, t2 = new A.LinkedHashMapValueIterator(t1, t1._modifications, t1._first, A._instanceType(t1)._eval$1("LinkedHashMapValueIterator<2>")); t2.moveNext$0();) {
                t3 = t2.__js_helper$_current;
                t4 = t3._recordMap;
                t4._root = null;
                t4._count = 0;
                ++t4._modificationCount;
                t3._currentRecordsCache = null;
              }
              for (t2 = records, t3 = t2.length, _i = 0; _i < t2.length; t2.length === t3 || (0, A.throwConcurrentModificationError)(t2), ++_i) {
                record = t2[_i];
                t4 = record.get$ref().RecordRefMixin___RecordRefMixin_store_A;
                t4 === $ && A.throwLateFieldNI("store");
                if ($async$self._closed)
                  A.throwExpression(A.DatabaseException$closed());
                t5 = t4.StoreRefMixin___StoreRefMixin_name_A;
                t5 === $ && A.throwLateFieldNI("name");
                store = t1.$index(0, t5);
                if (store == null)
                  store = $async$self._addStore$1(t4.StoreRefMixin___StoreRefMixin_name_A);
                t4 = A.RecordSnapshotMixin.prototype.get$key.call(record);
                store.setRecordInMemory$1(record);
                if (A._isInt(t4))
                  if (t4 > store.lastIntKey)
                    store.lastIntKey = t4;
              }
            case 5:
              // join
              $async$returnValue = new A.JdbImportResult(delta);
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return A._asyncReturn($async$returnValue, $async$completer);
            case 2:
              // rethrow
              return A._asyncRethrow($async$errorStack.at(-1), $async$completer);
          }
      });
      return A._asyncStartSync($async$txnJdbDeltaImport$1, $async$completer);
    },
    lockedClose$0() {
      var $async$goto = 0,
        $async$completer = A._makeAsyncAwaitCompleter(type$.dynamic),
        $async$self = this;
      var $async$lockedClose$0 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return A._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$self._opened = false;
              $async$self._closed = true;
              $async$goto = 2;
              return A._asyncAwait($async$self.openHelper.lockedCloseDatabase$0(), $async$lockedClose$0);
            case 2:
              // returning from await.
              // implicit return
              return A._asyncReturn(null, $async$completer);
          }
      });
      return A._asyncStartSync($async$lockedClose$0, $async$completer);
    },
    close$0() {
      var $async$goto = 0,
        $async$completer = A._makeAsyncAwaitCompleter(type$.dynamic),
        $async$returnValue, $async$self = this;
      var $async$close$0 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return A._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$self._storageJdbRevisionUpdateSubscription = null;
              $async$returnValue = $async$self.openHelper.lock.synchronized$1$1(new A.SembastDatabase_close_closure($async$self), type$.dynamic);
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return A._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return A._asyncStartSync($async$close$0, $async$completer);
    },
    toJson$0() {
      var t3, stores, t4, map0, t5, _this = this,
        t1 = type$.String,
        t2 = type$.nullable_Object,
        map = A.LinkedHashMap_LinkedHashMap$_empty(t1, t2);
      map.$indexSet(0, "path", _this._storageBase.path);
      t3 = _this._meta.version;
      t3.toString;
      map.$indexSet(0, "version", t3);
      stores = A._setArrayType([], type$.JSArray_Map_of_String_and_nullable_Object);
      for (t3 = _this._database_impl$_stores, t3 = new A.LinkedHashMapValueIterator(t3, t3._modifications, t3._first, A._instanceType(t3)._eval$1("LinkedHashMapValueIterator<2>")); t3.moveNext$0();) {
        t4 = t3.__js_helper$_current;
        map0 = A.LinkedHashMap_LinkedHashMap$_empty(t1, t2);
        t5 = t4.ref.StoreRefMixin___StoreRefMixin_name_A;
        t5 === $ && A.throwLateFieldNI("name");
        map0.$indexSet(0, "name", t5);
        map0.$indexSet(0, "count", t4._recordMap._count);
        B.JSArray_methods.add$1(stores, map0);
      }
      map.$indexSet(0, "stores", stores);
      t1 = _this._exportStat;
      if (t1 != null)
        map.$indexSet(0, "exportStat", t1.toJson$0());
      return map;
    },
    get$_needCompact() {
      var t1, t2;
      if (this._storageFs != null) {
        t1 = this._exportStat;
        t2 = t1.obsoleteLineCount;
        t1 = t2 > 5 && t2 / t1.lineCount > 0.2;
      } else
        t1 = false;
      return t1;
    },
    toString$0(_) {
      return A.MapBase_mapToString(this.toJson$0());
    },
    databaseOperation$1(action) {
      var $async$goto = 0,
        $async$completer = A._makeAsyncAwaitCompleter(type$.dynamic),
        $async$returnValue, $async$self = this, t1;
      var $async$databaseOperation$1 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return A._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = $async$self.lazyStorageOperations.length;
              if (t1 === 0) {
                // goto return
                $async$goto = 1;
                break;
              }
              $async$goto = 3;
              return A._asyncAwait($async$self.databaseLock.synchronized$1$1(new A.SembastDatabase_databaseOperation_closure($async$self, action), type$.Null), $async$databaseOperation$1);
            case 3:
              // returning from await.
            case 1:
              // return
              return A._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return A._asyncStartSync($async$databaseOperation$1, $async$completer);
    },
    transaction$1$1(action, $T) {
      return this.transaction$body$SembastDatabase($T._eval$1("0/(Transaction)")._as(action), $T, $T);
    },
    transaction$body$SembastDatabase(action, $T, $async$type) {
      var $async$goto = 0,
        $async$completer = A._makeAsyncAwaitCompleter($async$type),
        $async$returnValue, $async$self = this, t1;
      var $async$transaction$1$1 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return A._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$goto = 3;
              return A._asyncAwait($async$self._runTransaction$1$1(action, $T), $async$transaction$1$1);
            case 3:
              // returning from await.
              t1 = $async$result;
              $async$returnValue = t1;
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return A._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return A._asyncStartSync($async$transaction$1$1, $async$completer);
    },
    _runTransaction$1$1(action, $T) {
      return this._runTransaction$body$SembastDatabase($T._eval$1("0/(Transaction)")._as(action), $T, $T);
    },
    _runTransaction$body$SembastDatabase(action, $T, $async$type) {
      var $async$goto = 0,
        $async$completer = A._makeAsyncAwaitCompleter($async$type),
        $async$returnValue, $async$self = this, jdbIncrementRevisionStatus, t2, t3, result, _box_0, t1;
      var $async$_runTransaction$1$1 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return A._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              _box_0 = {};
              t1 = $async$self._openTransaction;
              $async$goto = t1 != null ? 3 : 4;
              break;
            case 3:
              // then
              t1 = action.call$1(t1);
              $async$goto = 5;
              return A._asyncAwait($T._eval$1("Future<0>")._is(t1) ? t1 : A._Future$value($T._as(t1), $T), $async$_runTransaction$1$1);
            case 5:
              // returning from await.
              $async$returnValue = $async$result;
              // goto return
              $async$goto = 1;
              break;
            case 4:
              // join
              _box_0.commitData = null;
              _box_0.upgrading = $async$self._upgrading;
              _box_0.reloadData = false;
              jdbIncrementRevisionStatus = A._Cell$named("jdbIncrementRevisionStatus");
              t1 = $async$self.transactionLock;
              t2 = type$.Null;
              t3 = false;
            case 6:
              // do body
              $async$goto = t3 ? 9 : 10;
              break;
            case 9:
              // then
              $async$goto = 11;
              return A._asyncAwait(t1.synchronized$1$1(new A.SembastDatabase__runTransaction_closure($async$self, jdbIncrementRevisionStatus), t2), $async$_runTransaction$1$1);
            case 11:
              // returning from await.
              _box_0.reloadData = false;
            case 10:
              // join
              $async$goto = 12;
              return A._asyncAwait(t1.synchronized$1$1(new A.SembastDatabase__runTransaction_closure0(_box_0, $async$self, action, jdbIncrementRevisionStatus, $T), $T).whenComplete$1(new A.SembastDatabase__runTransaction_closure1(_box_0, $async$self)), $async$_runTransaction$1$1);
            case 12:
              // returning from await.
              result = $async$result;
            case 7:
              // do condition
              if (t3 = _box_0.reloadData, t3) {
                // goto do body
                $async$goto = 6;
                break;
              }
            case 8:
              // after do
              $async$returnValue = result;
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return A._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return A._asyncStartSync($async$_runTransaction$1$1, $async$completer);
    },
    txnPostWrite$1(txn) {
      return this.txnPostWrite$body$SembastDatabase(txn);
    },
    txnPostWrite$body$SembastDatabase(txn) {
      var $async$goto = 0,
        $async$completer = A._makeAsyncAwaitCompleter(type$.void),
        $async$self = this, t1;
      var $async$txnPostWrite$1 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return A._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = $async$self.changesListener._changes_listener$_stores.__js_helper$_length;
              $async$goto = t1 !== 0 ? 2 : 3;
              break;
            case 2:
              // then
              $async$goto = 4;
              return A._asyncAwait($async$self._txnHandleChanges$1(txn), $async$txnPostWrite$1);
            case 4:
              // returning from await.
            case 3:
              // join
              // implicit return
              return A._asyncReturn(null, $async$completer);
          }
      });
      return A._asyncStartSync($async$txnPostWrite$1, $async$completer);
    },
    txnPostWriteAndCooperate$1(txn) {
      return this.txnPostWriteAndCooperate$body$SembastDatabase(txn);
    },
    txnPostWriteAndCooperate$body$SembastDatabase(txn) {
      var $async$goto = 0,
        $async$completer = A._makeAsyncAwaitCompleter(type$.void),
        $async$self = this, t1;
      var $async$txnPostWriteAndCooperate$1 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return A._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = $async$self.changesListener._changes_listener$_stores.__js_helper$_length;
              $async$goto = t1 !== 0 ? 2 : 3;
              break;
            case 2:
              // then
              $async$goto = 4;
              return A._asyncAwait($async$self.txnPostWrite$1(txn), $async$txnPostWriteAndCooperate$1);
            case 4:
              // returning from await.
            case 3:
              // join
              t1 = $async$self.cooperate$0();
              $async$goto = 5;
              return A._asyncAwait(t1 instanceof A._Future ? t1 : A._Future$value(t1, type$.dynamic), $async$txnPostWriteAndCooperate$1);
            case 5:
              // returning from await.
              // implicit return
              return A._asyncReturn(null, $async$completer);
          }
      });
      return A._asyncStartSync($async$txnPostWriteAndCooperate$1, $async$completer);
    },
    _txnHandleChanges$1(txn) {
      return this._txnHandleChanges$body$SembastDatabase(txn);
    },
    _txnHandleChanges$body$SembastDatabase(txn) {
      var $async$goto = 0,
        $async$completer = A._makeAsyncAwaitCompleter(type$.void),
        $async$self = this, t1, t2, t3, t4, storeChangesListeners, t5, _i, storeChangesListener;
      var $async$_txnHandleChanges$1 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return A._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = $async$self.changesListener, t2 = t1._changes_listener$_stores, t3 = A._instanceType(t2)._eval$1("LinkedHashMapValuesIterable<2>"), t4 = type$.StoreChangesListeners;
            case 2:
              // for condition
              if (!t1.get$hasStoreChanges()) {
                // goto after for
                $async$goto = 3;
                break;
              }
              storeChangesListeners = A.List_List$from(new A.LinkedHashMapValuesIterable(t2, t3), true, t4);
              t5 = storeChangesListeners.length, _i = 0;
            case 4:
              // for condition
              if (!(_i < t5)) {
                // goto after for
                $async$goto = 6;
                break;
              }
              storeChangesListener = storeChangesListeners[_i];
              $async$goto = storeChangesListener.get$hasChanges() ? 7 : 8;
              break;
            case 7:
              // then
              $async$goto = 9;
              return A._asyncAwait(storeChangesListener.handleChanges$1(txn), $async$_txnHandleChanges$1);
            case 9:
              // returning from await.
            case 8:
              // join
            case 5:
              // for update
              ++_i;
              // goto for condition
              $async$goto = 4;
              break;
            case 6:
              // after for
              // goto for condition
              $async$goto = 2;
              break;
            case 3:
              // after for
            case 10:
              // for condition
              if (!t1.get$hasGlobalChanges()) {
                // goto after for
                $async$goto = 11;
                break;
              }
              $async$goto = 12;
              return A._asyncAwait(t1.handleGlobalChanges$1(txn), $async$_txnHandleChanges$1);
            case 12:
              // returning from await.
              // goto for condition
              $async$goto = 10;
              break;
            case 11:
              // after for
              // implicit return
              return A._asyncReturn(null, $async$completer);
          }
      });
      return A._asyncStartSync($async$_txnHandleChanges$1, $async$completer);
    },
    cooperate$0() {
      var t1 = this.cooperator;
      return t1 == null ? null : t1.cooperate$0();
    },
    checkTransaction$1(transaction) {
      if (transaction != null && transaction !== this._transaction)
        throw A.wrapException(A.StateError$("The transaction is no longer active. Make sure you (a)wait all pending operations in your transaction block"));
    },
    get$sembastDatabase() {
      return this;
    },
    inTransaction$1$1(action, $T) {
      return this.transaction$1$1(new A.SembastDatabase_inTransaction_closure($T._eval$1("0/(SembastTransaction)")._as(action), $T), $T);
    },
    get$sembastTransaction() {
      return this._openTransaction;
    },
    _restartListeners$0() {
      var t1, t2;
      for (t1 = this.listener._listener$_stores, t2 = new A.LinkedHashMapKeyIterator(t1, t1._modifications, t1._first, A._instanceType(t1)._eval$1("LinkedHashMapKeyIterator<1>")); t2.moveNext$0();)
        t1.$index(0, t2.__js_helper$_current).restart$0();
    },
    _notifyListeners$0() {
      var $async$goto = 0,
        $async$completer = A._makeAsyncAwaitCompleter(type$.void),
        $async$self = this, t1, t2, t3, storeContent, t4;
      var $async$_notifyListeners$0 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return A._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              for (t1 = type$.ImmutableSembastRecord, t2 = $async$self.listener._listener$_stores, t3 = $async$self._pendingListenerContent; true;) {
                storeContent = t3.getAndRemoveFirstStore$0();
                if (storeContent == null)
                  break;
                t4 = storeContent._database_content$_map;
                A.List_List$from(new A.LinkedHashMapValuesIterable(t4, A._instanceType(t4)._eval$1("LinkedHashMapValuesIterable<2>")), true, t1);
                t2.$index(0, storeContent.store);
              }
              // implicit return
              return A._asyncReturn(null, $async$completer);
          }
      });
      return A._asyncStartSync($async$_notifyListeners$0, $async$completer);
    },
    get$_jsonEncodableCodec() {
      var t1 = $.$get$sembastDefaultJsonEncodableCodec();
      return t1;
    },
    _check$2(value, update) {
      var t1;
      if (A.isBasicTypeOrNull(value))
        return;
      if (type$.List_dynamic._is(value)) {
        for (t1 = J.get$iterator$ax(value); t1.moveNext$0();)
          this._check$2(t1.get$current(), false);
        return;
      } else if (type$.Map_dynamic_dynamic._is(value)) {
        for (t1 = value.get$values(), t1 = t1.get$iterator(t1); t1.moveNext$0();)
          this._check$2(t1.get$current(), false);
        return;
      }
      if (this.get$_jsonEncodableCodec().supportsType$1(value))
        return;
      throw A.wrapException(A.ArgumentError$value(value, null, "type " + J.get$runtimeType$(value).toString$0(0) + " not supported"));
    },
    sanitizeInputValue$1$2$update(value, update, $V) {
      var t1, exception;
      this._check$2(value, false);
      if (type$.List_dynamic._is(value))
        try {
          t1 = $V._as(J.cast$1$0$ax(value, type$.nullable_Object));
          return t1;
        } catch (exception) {
          t1 = A.ArgumentError$value(value, "type " + A.createRuntimeType($V).toString$0(0) + " not supported", "List must be of type List<Object?> for type " + J.get$runtimeType$(value).toString$0(0) + " value " + A.S(value));
          throw A.wrapException(t1);
        }
      else if (type$.Map_dynamic_dynamic._is(value))
        try {
          t1 = $V._as(value.cast$2$0(0, type$.String, type$.nullable_Object));
          return t1;
        } catch (exception) {
          t1 = A.ArgumentError$value(value, "type " + A.createRuntimeType($V).toString$0(0) + " not supported", "Map must be of type Map<String, Object?> for type " + A.getRuntimeTypeOfDartObject(value).toString$0(0) + " value " + value.toString$0(0));
          throw A.wrapException(t1);
        }
      return $V._as(value);
    },
    sanitizeInputValue$1$1(value, $V) {
      return this.sanitizeInputValue$1$2$update(value, null, $V);
    },
    $isDatabase0: 1,
    $isDatabaseClient: 1
  };
  A.SembastDatabase_txnCompact_writeCurrent.prototype = {
    call$0() {
      var $async$goto = 0,
        $async$completer = A._makeAsyncAwaitCompleter(type$.void),
        $async$self = this, linesCopy, t2, linesCopy0, t1;
      var $async$call$0 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return A._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = $async$self._box_0;
              $async$goto = t1.currentWriteSize > 0 ? 2 : 3;
              break;
            case 2:
              // then
              t2 = $async$self.lines;
              linesCopy0 = A.List_List$_of(t2, type$.String);
              linesCopy = linesCopy0;
              B.JSArray_methods.clear$0(t2);
              $async$goto = 4;
              return A._asyncAwait($async$self.sink.appendLines$1(linesCopy), $async$call$0);
            case 4:
              // returning from await.
              t1.currentWriteSize = 0;
            case 3:
              // join
              // implicit return
              return A._asyncReturn(null, $async$completer);
          }
      });
      return A._asyncStartSync($async$call$0, $async$completer);
    },
    $signature: 14
  };
  A.SembastDatabase_txnCompact_addStringLine.prototype = {
    $call$body$SembastDatabase_txnCompact_addStringLine(line) {
      var $async$goto = 0,
        $async$completer = A._makeAsyncAwaitCompleter(type$.dynamic),
        $async$self = this, currentWriteSize, t1;
      var $async$call$1 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return A._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = $async$self.$this.cooperate$0();
              $async$goto = 2;
              return A._asyncAwait(t1 instanceof A._Future ? t1 : A._Future$value(t1, type$.dynamic), $async$call$1);
            case 2:
              // returning from await.
              ++$async$self.exportStat.lineCount;
              B.JSArray_methods.add$1($async$self.lines, line);
              t1 = $async$self._box_0;
              currentWriteSize = t1.currentWriteSize + line.length;
              t1.currentWriteSize = currentWriteSize;
              $async$goto = currentWriteSize > 5000000 ? 3 : 4;
              break;
            case 3:
              // then
              $async$goto = 5;
              return A._asyncAwait($async$self.writeCurrent.call$0(), $async$call$1);
            case 5:
              // returning from await.
            case 4:
              // join
              // implicit return
              return A._asyncReturn(null, $async$completer);
          }
      });
      return A._asyncStartSync($async$call$1, $async$completer);
    },
    call$1(line) {
      return this.$call$body$SembastDatabase_txnCompact_addStringLine(line);
    },
    $signature: 61
  };
  A.SembastDatabase_txnCompact_addLine.prototype = {
    $call$body$SembastDatabase_txnCompact_addLine(map) {
      var $async$goto = 0,
        $async$completer = A._makeAsyncAwaitCompleter(type$.dynamic),
        $async$handler = 1, $async$errorStack = [], $async$self = this, t1, t2, exception, encoded, $async$exception;
      var $async$call$1 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1) {
          $async$errorStack.push($async$result);
          $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              encoded = null;
              $async$handler = 3;
              t1 = $async$self.$this;
              t2 = t1.openHelper;
              $async$goto = $async$self.hasAsyncCodec ? 6 : 8;
              break;
            case 6:
              // then
              t2 = A.sembastCodecContentCodec(t2.options.codec);
              t1 = t1.get$_jsonEncodableCodec();
              A._instanceType(t1)._eval$1("Codec.S")._as(map);
              $async$goto = 9;
              return A._asyncAwait(A.SembastContentCodecAsyncSupport_encodeContentAsync(t2, type$.Map_dynamic_dynamic._as(t1.get$encoder().convert$1(map))), $async$call$1);
            case 9:
              // returning from await.
              encoded = $async$result;
              // goto join
              $async$goto = 7;
              break;
            case 8:
              // else
              t2 = A.sembastCodecContentCodec(t2.options.codec);
              t1 = t1.get$_jsonEncodableCodec();
              A._instanceType(t1)._eval$1("Codec.S")._as(map);
              encoded = t2.encode$1(t1.get$encoder().convert$1(map));
            case 7:
              // join
              $async$goto = 10;
              return A._asyncAwait($async$self.addStringLine.call$1(encoded), $async$call$1);
            case 10:
              // returning from await.
              $async$handler = 1;
              // goto after finally
              $async$goto = 5;
              break;
            case 3:
              // catch
              $async$handler = 2;
              $async$exception = $async$errorStack.pop();
              A.getTraceFromException($async$exception);
              throw $async$exception;
              // goto after finally
              $async$goto = 5;
              break;
            case 2:
              // uncaught
              // goto rethrow
              $async$goto = 1;
              break;
            case 5:
              // after finally
              // implicit return
              return A._asyncReturn(null, $async$completer);
            case 1:
              // rethrow
              return A._asyncRethrow($async$errorStack.at(-1), $async$completer);
          }
      });
      return A._asyncStartSync($async$call$1, $async$completer);
    },
    call$1(map) {
      return this.$call$body$SembastDatabase_txnCompact_addLine(map);
    },
    $signature: 62
  };
  A.SembastDatabase_commitInMemory_saveInMemory.prototype = {
    call$0() {
      var t1, t2, t3, _i, record, t4, t5, store, exists;
      for (t1 = this.txnRecords, t2 = t1.length, t3 = this.$this, _i = 0; _i < t1.length; t1.length === t2 || (0, A.throwConcurrentModificationError)(t1), ++_i) {
        record = t1[_i];
        t4 = record.get$ref().RecordRefMixin___RecordRefMixin_store_A;
        t4 === $ && A.throwLateFieldNI("store");
        if (t3._closed)
          A.throwExpression(A.DatabaseException$closed());
        t5 = t4.StoreRefMixin___StoreRefMixin_name_A;
        t5 === $ && A.throwLateFieldNI("name");
        store = t3._database_impl$_stores.$index(0, t5);
        if (store == null)
          store = t3._addStore$1(t4.StoreRefMixin___StoreRefMixin_name_A);
        exists = store.setRecordInMemory$1(record.record);
        t4 = t3._storageFs == null && null;
        if (t4 === true) {
          if (exists)
            ++t3._exportStat.obsoleteLineCount;
          ++t3._exportStat.lineCount;
        }
      }
    },
    $signature: 0
  };
  A.SembastDatabase_flush_closure.prototype = {
    call$0() {
    },
    $signature: 8
  };
  A.SembastDatabase_open_closure.prototype = {
    call$0() {
      var $async$goto = 0,
        $async$completer = A._makeAsyncAwaitCompleter(type$.dynamic),
        $async$returnValue, $async$handler = 2, $async$errorStack = [], $async$self = this, handleVersionChanged, openDone, findOrCreate, t2, t3, exception, t1, $async$exception;
      var $async$call$0 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1) {
          $async$errorStack.push($async$result);
          $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = $async$self.$this;
              t1._closed = false;
              $async$handler = 4;
              t2 = {};
              t2.meta = null;
              t3 = $async$self.options;
              handleVersionChanged = new A.SembastDatabase_open_closure_handleVersionChanged(t2, t1, t3);
              openDone = new A.SembastDatabase_open_closure_openDone(t2, $async$self._box_2, t1, t3, handleVersionChanged);
              findOrCreate = new A.SembastDatabase_open_closure_findOrCreate(t1, $async$self.mode);
              $async$goto = 7;
              return A._asyncAwait(findOrCreate.call$0(), $async$call$0);
            case 7:
              // returning from await.
              if (t1._mainStore == null)
                t1._addStore$1(null);
              t2.meta = t1._meta;
              $async$goto = 8;
              return A._asyncAwait(openDone.call$0(), $async$call$0);
            case 8:
              // returning from await.
              t2 = $async$result;
              $async$returnValue = t2;
              // goto return
              $async$goto = 1;
              break;
              $async$handler = 2;
              // goto after finally
              $async$goto = 6;
              break;
            case 4:
              // catch
              $async$handler = 3;
              $async$exception = $async$errorStack.pop();
              $async$goto = 9;
              return A._asyncAwait(t1.lockedClose$0(), $async$call$0);
            case 9:
              // returning from await.
              throw $async$exception;
              // goto after finally
              $async$goto = 6;
              break;
            case 3:
              // uncaught
              // goto rethrow
              $async$goto = 2;
              break;
            case 6:
              // after finally
            case 1:
              // return
              return A._asyncReturn($async$returnValue, $async$completer);
            case 2:
              // rethrow
              return A._asyncRethrow($async$errorStack.at(-1), $async$completer);
          }
      });
      return A._asyncStartSync($async$call$0, $async$completer);
    },
    $signature: 1
  };
  A.SembastDatabase_open_closure_handleVersionChanged.prototype = {
    $call$body$SembastDatabase_open_closure_handleVersionChanged(oldVersion, newVersion) {
      var $async$goto = 0,
        $async$completer = A._makeAsyncAwaitCompleter(type$.dynamic),
        $async$handler = 1, $async$errorStack = [], $async$next = [], $async$self = this, t1;
      var $async$call$2 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1) {
          $async$errorStack.push($async$result);
          $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = $async$self.$this;
              t1._upgrading = true;
              $async$handler = 2;
              $async$goto = 5;
              return A._asyncAwait(t1.transaction$1$1(new A.SembastDatabase_open__handleVersionChanged_closure($async$self._box_1, t1, newVersion, $async$self.options, oldVersion), type$.nullable_Object), $async$call$2);
            case 5:
              // returning from await.
              $async$next.push(4);
              // goto finally
              $async$goto = 3;
              break;
            case 2:
              // uncaught
              $async$next = [1];
            case 3:
              // finally
              $async$handler = 1;
              t1._upgrading = false;
              // goto the next finally handler
              $async$goto = $async$next.pop();
              break;
            case 4:
              // after finally
              // implicit return
              return A._asyncReturn(null, $async$completer);
            case 1:
              // rethrow
              return A._asyncRethrow($async$errorStack.at(-1), $async$completer);
          }
      });
      return A._asyncStartSync($async$call$2, $async$completer);
    },
    call$2(oldVersion, newVersion) {
      return this.$call$body$SembastDatabase_open_closure_handleVersionChanged(oldVersion, newVersion);
    },
    $signature: 63
  };
  A.SembastDatabase_open__handleVersionChanged_closure.prototype = {
    call$1(txn) {
      return this.$call$body$SembastDatabase_open__handleVersionChanged_closure(txn);
    },
    $call$body$SembastDatabase_open__handleVersionChanged_closure(txn) {
      var $async$goto = 0,
        $async$completer = A._makeAsyncAwaitCompleter(type$.nullable_Object),
        $async$returnValue, $async$handler = 2, $async$errorStack = [], $async$next = [], $async$self = this, t1, t2, t3, t4, meta, result, $async$temp1, $async$temp2;
      var $async$call$1 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1) {
          $async$errorStack.push($async$result);
          $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              result = null;
              $async$handler = 3;
              t1 = $async$self.$this;
              t1._openTransaction = txn;
              t2 = $async$self.newVersion;
              t3 = $async$self.options;
              t4 = A.getCodecEncodedSignature(t3.codec);
              $async$temp1 = A;
              $async$temp2 = t2;
              $async$goto = 6;
              return A._asyncAwait(type$.Future_nullable_String._is(t4) ? t4 : A._Future$value(A._asStringQ(t4), type$.nullable_String), $async$call$1);
            case 6:
              // returning from await.
              meta = new $async$temp1.Meta($async$temp2, $async$result);
              t1._upgradingMeta = meta;
              $async$self._box_1.meta = meta;
              t4 = $async$self.oldVersion;
              t4.toString;
              t2.toString;
              t2 = t3.onVersionChanged.call$3(t1, t4, t2);
              $async$goto = 7;
              return A._asyncAwait(t2 instanceof A._Future ? t2 : A._Future$value(t2, type$.dynamic), $async$call$1);
            case 7:
              // returning from await.
              result = $async$result;
              $async$next.push(5);
              // goto finally
              $async$goto = 4;
              break;
            case 3:
              // uncaught
              $async$next = [2];
            case 4:
              // finally
              $async$handler = 2;
              $async$self.$this._openTransaction = null;
              // goto the next finally handler
              $async$goto = $async$next.pop();
              break;
            case 5:
              // after finally
              $async$returnValue = result;
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return A._asyncReturn($async$returnValue, $async$completer);
            case 2:
              // rethrow
              return A._asyncRethrow($async$errorStack.at(-1), $async$completer);
          }
      });
      return A._asyncStartSync($async$call$1, $async$completer);
    },
    $signature: 64
  };
  A.SembastDatabase_open_closure_openDone.prototype = {
    call$0() {
      var $async$goto = 0,
        $async$completer = A._makeAsyncAwaitCompleter(type$.dynamic),
        $async$self = this, needVersionChanged, oldVersion, t2, t3, t4, t5, t1, $async$temp1, $async$temp2, $async$temp3;
      var $async$call$0 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return A._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = $async$self.$this;
              if (t1._mainStore == null)
                t1._addStore$1(null);
              t2 = $async$self._box_1;
              t3 = t2.meta;
              $async$goto = t3 == null ? 2 : 3;
              break;
            case 2:
              // then
              t3 = A.getCodecEncodedSignature($async$self.options.codec);
              $async$temp1 = t2;
              $async$temp2 = A;
              $async$goto = 4;
              return A._asyncAwait(type$.Future_nullable_String._is(t3) ? t3 : A._Future$value(A._asStringQ(t3), type$.nullable_String), $async$call$0);
            case 4:
              // returning from await.
              t3 = $async$temp1.meta = new $async$temp2.Meta(0, $async$result);
            case 3:
              // join
              if (t1._meta == null)
                t1._meta = t3;
              needVersionChanged = false;
              oldVersion = t3.version;
              $async$goto = J.$eq$(oldVersion, 0) ? 5 : 7;
              break;
            case 5:
              // then
              needVersionChanged = true;
              t3 = $async$self._box_2;
              t4 = t3.version;
              if (t4 == null)
                t4 = t3.version = 1;
              t5 = A.getCodecEncodedSignature($async$self.options.codec);
              $async$temp1 = t2;
              $async$temp2 = A;
              $async$temp3 = t4;
              $async$goto = 8;
              return A._asyncAwait(type$.Future_nullable_String._is(t5) ? t5 : A._Future$value(A._asStringQ(t5), type$.nullable_String), $async$call$0);
            case 8:
              // returning from await.
              $async$temp1.meta = new $async$temp2.Meta($async$temp3, $async$result);
              // goto join
              $async$goto = 6;
              break;
            case 7:
              // else
              t3 = $async$self._box_2;
              t4 = t3.version;
              if (t4 != null && t4 !== oldVersion)
                needVersionChanged = true;
            case 6:
              // join
              t1._opened = true;
              $async$goto = needVersionChanged ? 9 : 10;
              break;
            case 9:
              // then
              $async$goto = 11;
              return A._asyncAwait($async$self.handleVersionChanged.call$2(oldVersion, t3.version), $async$call$0);
            case 11:
              // returning from await.
            case 10:
              // join
              t1._meta = t2.meta;
              // implicit return
              return A._asyncReturn(null, $async$completer);
          }
      });
      return A._asyncStartSync($async$call$0, $async$completer);
    },
    $signature: 1
  };
  A.SembastDatabase_open_closure_findOrCreate.prototype = {
    call$0() {
      var $async$goto = 0,
        $async$completer = A._makeAsyncAwaitCompleter(type$.dynamic),
        $async$self = this, found, t1, t2;
      var $async$call$0 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return A._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = $async$self.mode;
              t2 = J.getInterceptor$(t1);
              $async$goto = t2.$eq(t1, B.DatabaseMode_1) || t2.$eq(t1, B.DatabaseMode_4) ? 2 : 4;
              break;
            case 2:
              // then
              t1 = $async$self.$this;
              t2 = t1._storageBase;
              $async$goto = 5;
              return A._asyncAwait(A.Future_Future$value(t2.factory._exists.$index(0, t2.path) === true, type$.bool), $async$call$0);
            case 5:
              // returning from await.
              found = $async$result;
              if (!found)
                throw A.wrapException(new A.DatabaseException(1, "Database (open existing or read-only) " + t1.get$path() + " not found"));
              t1.openHelper.openMode = B.DatabaseMode_3;
              // goto join
              $async$goto = 3;
              break;
            case 4:
              // else
              $async$goto = t2.$eq(t1, B.DatabaseMode_2) ? 6 : 7;
              break;
            case 6:
              // then
              t1 = $async$self.$this;
              $async$goto = 8;
              return A._asyncAwait(t1._storageBase.delete$0(), $async$call$0);
            case 8:
              // returning from await.
              t1.openHelper.openMode = B.DatabaseMode_3;
            case 7:
              // join
              $async$goto = 9;
              return A._asyncAwait($async$self.$this._storageBase.findOrCreate$0(), $async$call$0);
            case 9:
              // returning from await.
            case 3:
              // join
              // implicit return
              return A._asyncReturn(null, $async$completer);
          }
      });
      return A._asyncStartSync($async$call$0, $async$completer);
    },
    $signature: 1
  };
  A.SembastDatabase_close_closure.prototype = {
    call$0() {
      var $async$goto = 0,
        $async$completer = A._makeAsyncAwaitCompleter(type$.Null),
        $async$self = this, t1;
      var $async$call$0 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return A._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = $async$self.$this;
              t1.listener.close$0();
              t1.changesListener._changes_listener$_stores.clear$0(0);
              $async$goto = 2;
              return A._asyncAwait(t1.flush$0(), $async$call$0);
            case 2:
              // returning from await.
              $async$goto = 3;
              return A._asyncAwait(t1.lockedClose$0(), $async$call$0);
            case 3:
              // returning from await.
              // implicit return
              return A._asyncReturn(null, $async$completer);
          }
      });
      return A._asyncStartSync($async$call$0, $async$completer);
    },
    $signature: 10
  };
  A.SembastDatabase_databaseOperation_closure.prototype = {
    call$0() {
      var $async$goto = 0,
        $async$completer = A._makeAsyncAwaitCompleter(type$.Null),
        $async$handler = 1, $async$errorStack = [], $async$self = this, operation, list, t2, _i, exception, t1, $async$exception;
      var $async$call$0 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1) {
          $async$errorStack.push($async$result);
          $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = $async$self.$this.lazyStorageOperations;
              $async$goto = t1.length !== 0 ? 2 : 3;
              break;
            case 2:
              // then
              list = A.List_List$from(t1, true, type$.Future_nullable_Object_Function);
              t2 = list.length, _i = 0;
            case 4:
              // for condition
              if (!(_i < t2)) {
                // goto after for
                $async$goto = 6;
                break;
              }
              operation = list[_i];
              $async$handler = 8;
              $async$goto = 11;
              return A._asyncAwait(operation.call$0(), $async$call$0);
            case 11:
              // returning from await.
              $async$handler = 1;
              // goto after finally
              $async$goto = 10;
              break;
            case 8:
              // catch
              $async$handler = 7;
              $async$exception = $async$errorStack.pop();
              // goto after finally
              $async$goto = 10;
              break;
            case 7:
              // uncaught
              // goto rethrow
              $async$goto = 1;
              break;
            case 10:
              // after finally
              B.JSArray_methods.remove$1(t1, operation);
            case 5:
              // for update
              ++_i;
              // goto for condition
              $async$goto = 4;
              break;
            case 6:
              // after for
            case 3:
              // join
              // implicit return
              return A._asyncReturn(null, $async$completer);
            case 1:
              // rethrow
              return A._asyncRethrow($async$errorStack.at(-1), $async$completer);
          }
      });
      return A._asyncStartSync($async$call$0, $async$completer);
    },
    $signature: 10
  };
  A.SembastDatabase__runTransaction_closure.prototype = {
    call$0() {
      var $async$goto = 0,
        $async$completer = A._makeAsyncAwaitCompleter(type$.Null),
        $async$self = this, t1, $async$temp1;
      var $async$call$0 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return A._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = $async$self.$this;
              $async$temp1 = t1;
              $async$goto = 2;
              return A._asyncAwait(t1.txnJdbDeltaImport$1($async$self.jdbIncrementRevisionStatus._readLocal$0().get$revision()), $async$call$0);
            case 2:
              // returning from await.
              $async$temp1._notifyLazilyJdbImportResult$1($async$result);
              // implicit return
              return A._asyncReturn(null, $async$completer);
          }
      });
      return A._asyncStartSync($async$call$0, $async$completer);
    },
    $signature: 10
  };
  A.SembastDatabase__runTransaction_closure0.prototype = {
    call$0() {
      return this.$call$body$SembastDatabase__runTransaction_closure(this.T);
    },
    $call$body$SembastDatabase__runTransaction_closure($async$type) {
      var $async$goto = 0,
        $async$completer = A._makeAsyncAwaitCompleter($async$type),
        $async$returnValue, $async$handler = 2, $async$errorStack = [], $async$next = [], $async$self = this, transactionCleanUp, actionResult, hasRecords, postTransaction, t2, t3, exception, t1, $async$exception;
      var $async$call$0 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1) {
          $async$errorStack.push($async$result);
          $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = $async$self.$this;
              t1._transaction = new A.SembastTransaction(t1, ++t1._txnId, new A._AsyncCompleter(new A._Future($.Zone__current, type$._Future_void), type$._AsyncCompleter_void));
              t2 = $async$self._box_0;
              transactionCleanUp = new A.SembastDatabase__runTransaction_closure_transactionCleanUp(t2, t1);
              actionResult = null;
              $async$handler = 4;
              t3 = $async$self.T;
              $async$goto = 7;
              return A._asyncAwait(A.Future_Future$sync(new A.SembastDatabase__runTransaction__closure(t1, $async$self.action, t3), t3), $async$call$0);
            case 7:
              // returning from await.
              actionResult = $async$result;
              t2.commitData = t1.commitInMemory$0();
              $async$next.push(6);
              // goto finally
              $async$goto = 5;
              break;
            case 4:
              // catch
              $async$handler = 3;
              $async$exception = $async$errorStack.pop();
              transactionCleanUp.call$0();
              throw $async$exception;
              $async$next.push(6);
              // goto finally
              $async$goto = 5;
              break;
            case 3:
              // uncaught
              $async$next = [2];
            case 5:
              // finally
              $async$handler = 2;
              t3 = t1._storageFs == null && null;
              $async$goto = t3 === true ? 8 : 9;
              break;
            case 8:
              // then
              t3 = t2.commitData;
              t3 = t3 == null ? null : t3.get$hasWriteData();
              hasRecords = t3 === true;
              $async$goto = hasRecords || t2.upgrading ? 10 : 11;
              break;
            case 10:
              // then
              postTransaction = new A.SembastDatabase__runTransaction_closure_postTransaction(t2, t1);
              $async$goto = t2.upgrading ? 12 : 14;
              break;
            case 12:
              // then
              $async$goto = 15;
              return A._asyncAwait(postTransaction.call$0(), $async$call$0);
            case 15:
              // returning from await.
              // goto join
              $async$goto = 13;
              break;
            case 14:
              // else
              B.JSArray_methods.add$1(t1.lazyStorageOperations, postTransaction);
            case 13:
              // join
            case 11:
              // join
            case 9:
              // join
              // goto the next finally handler
              $async$goto = $async$next.pop();
              break;
            case 6:
              // after finally
              transactionCleanUp.call$0();
              $async$returnValue = actionResult;
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return A._asyncReturn($async$returnValue, $async$completer);
            case 2:
              // rethrow
              return A._asyncRethrow($async$errorStack.at(-1), $async$completer);
          }
      });
      return A._asyncStartSync($async$call$0, $async$completer);
    },
    $signature() {
      return this.T._eval$1("Future<0>()");
    }
  };
  A.SembastDatabase__runTransaction_closure_transactionCleanUp.prototype = {
    call$0() {
      var t1, t2;
      this._box_0.upgrading = false;
      t1 = this.$this;
      t1._clearTxnData$0();
      t2 = t1._transaction;
      if (t2 != null)
        t2.completer.complete$0();
      t1._transaction = null;
    },
    $signature: 0
  };
  A.SembastDatabase__runTransaction__closure.prototype = {
    call$0() {
      var t1 = this.$this._transaction;
      t1.toString;
      t1 = this.action.call$1(t1);
      return t1;
    },
    $signature() {
      return this.T._eval$1("0/()");
    }
  };
  A.SembastDatabase__runTransaction_closure_postTransaction.prototype = {
    call$0() {
      var $async$goto = 0,
        $async$completer = A._makeAsyncAwaitCompleter(type$.dynamic),
        $async$self = this, t2, t3, t1;
      var $async$call$0 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return A._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = $async$self._box_0;
              $async$goto = t1.upgrading ? 2 : 3;
              break;
            case 2:
              // then
              t2 = $async$self.$this;
              t3 = t2._storageFs;
              t3.toString;
              $async$goto = 4;
              return A._asyncAwait(t3.appendLine$1(B.C_JsonCodec.encode$1(t2._upgradingMeta.toMap$0())), $async$call$0);
            case 4:
              // returning from await.
            case 3:
              // join
              t1 = t1.commitData;
              if (t1 == null)
                t2 = null;
              else {
                t2 = t1.txnRecords;
                t2 = t2 == null ? null : t2.length !== 0;
              }
              $async$goto = t2 === true ? 5 : 6;
              break;
            case 5:
              // then
              t1 = t1.txnRecords;
              t1.toString;
              $async$goto = 7;
              return A._asyncAwait($async$self.$this.storageCommitRecords$1(t1), $async$call$0);
            case 7:
              // returning from await.
            case 6:
              // join
              t1 = $async$self.$this;
              $async$goto = !t1._upgrading && t1.get$_needCompact() ? 8 : 9;
              break;
            case 8:
              // then
              $async$goto = 10;
              return A._asyncAwait(t1.txnCompact$0(), $async$call$0);
            case 10:
              // returning from await.
            case 9:
              // join
              // implicit return
              return A._asyncReturn(null, $async$completer);
          }
      });
      return A._asyncStartSync($async$call$0, $async$completer);
    },
    $signature: 1
  };
  A.SembastDatabase__runTransaction_closure1.prototype = {
    call$0() {
      var $async$goto = 0,
        $async$completer = A._makeAsyncAwaitCompleter(type$.void),
        $async$self = this, t1;
      var $async$call$0 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return A._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = $async$self.$this;
              t1._notifyListeners$0();
              $async$goto = !$async$self._box_0.upgrading ? 2 : 3;
              break;
            case 2:
              // then
              $async$goto = 4;
              return A._asyncAwait(t1.databaseOperation$1(null), $async$call$0);
            case 4:
              // returning from await.
            case 3:
              // join
              // implicit return
              return A._asyncReturn(null, $async$completer);
          }
      });
      return A._asyncStartSync($async$call$0, $async$completer);
    },
    $signature: 14
  };
  A.SembastDatabase_inTransaction_closure.prototype = {
    call$1(txn) {
      return this.action.call$1(txn);
    },
    $signature() {
      return this.T._eval$1("0/(Transaction)");
    }
  };
  A.DatabaseExportStat.prototype = {
    toJson$0() {
      var map = A.LinkedHashMap_LinkedHashMap$_empty(type$.String, type$.nullable_Object);
      map.$indexSet(0, "lineCount", this.lineCount);
      map.$indexSet(0, "obsoleteLineCount", this.obsoleteLineCount);
      map.$indexSet(0, "compactCount", this.compactCount);
      return map;
    },
    toString$0(_) {
      return A.MapBase_mapToString(this.toJson$0());
    }
  };
  A.JdbImportResult.prototype = {};
  A._SembastDatabase_Object_SembastDatabaseMixin.prototype = {};
  A.DatabaseOpenHelper.prototype = {
    openDatabase$0() {
      return this.lock.synchronized$1$1(new A.DatabaseOpenHelper_openDatabase_closure(this), type$.Database_2);
    },
    lockedCloseDatabase$0() {
      var $async$goto = 0,
        $async$completer = A._makeAsyncAwaitCompleter(type$.dynamic),
        $async$returnValue, $async$self = this;
      var $async$lockedCloseDatabase$0 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return A._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              if ($async$self.database != null)
                $async$self.factory.SembastDatabaseFactoryMixin__databaseOpenHelpers.remove$1(0, $async$self.path);
              $async$returnValue = $async$self.database;
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return A._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return A._asyncStartSync($async$lockedCloseDatabase$0, $async$completer);
    },
    toString$0(_) {
      return "DatabaseOpenHelper(" + this.path + ", " + this.options.toString$0(0) + ")";
    }
  };
  A.DatabaseOpenHelper_openDatabase_closure.prototype = {
    call$0() {
      var $async$goto = 0,
        $async$completer = A._makeAsyncAwaitCompleter(type$.SembastDatabase),
        $async$returnValue, $async$self = this, path, t3, db, t4, t5, t6, t7, t8, t9, t10, t11, t1, t2;
      var $async$call$0 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return A._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = $async$self.$this;
              t2 = t1.database;
              if (t2 == null) {
                t2 = t1.factory;
                path = t1.path;
                t3 = t2._databases;
                db = t3.$index(0, path);
                if (db == null) {
                  t2 = new A.DatabaseStorageMemory(t2, path);
                  t4 = A.Lock_Lock();
                  t5 = A.Lock_Lock();
                  t6 = A.Lock_Lock();
                  t7 = type$.StoreRef_of_nullable_Object_and_nullable_Object;
                  t8 = type$.String;
                  t9 = A._setArrayType([], type$.JSArray_String);
                  t10 = A._setArrayType([], type$.JSArray_of_Future_nullable_Object_Function);
                  t11 = $.$get$globalCooperator();
                  db = new A.SembastDatabase(t1, false, t2, t4, t5, t6, new A.DatabaseListener(A.LinkedHashMap_LinkedHashMap$_empty(t7, type$.StoreListener)), new A.DatabaseChangesListener(A.LinkedHashMap_LinkedHashMap$_empty(t7, type$.StoreChangesListeners)), A.LinkedHashMap_LinkedHashMap$_empty(t8, type$.SembastStore), t9, A.LinkedHashMap_LinkedHashMap$_empty(t8, type$.int), new A.DatabaseListenerContent(A.LinkedHashMap_LinkedHashMap$_empty(t7, type$.StoreContent)), t10, t11);
                  db._storageFs = t2;
                  t3.$indexSet(0, path, db);
                }
                t2 = t1.database = db;
              }
              t2.openHelper = t1;
              $async$goto = 3;
              return A._asyncAwait(t2.open$1(t1.options), $async$call$0);
            case 3:
              // returning from await.
              t1.factory.setDatabaseOpenHelper$2(t1.path, t1);
              t1 = t1.database;
              t1.toString;
              $async$returnValue = t1;
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return A._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return A._asyncStartSync($async$call$0, $async$completer);
    },
    $signature: 65
  };
  A.DatabaseOpenOptions.prototype = {
    toString$0(_) {
      var map = A.LinkedHashMap_LinkedHashMap$_empty(type$.String, type$.nullable_Object);
      map.$indexSet(0, "version", this.version);
      return A.MapBase_mapToString(map);
    }
  };
  A.SembastFilterBase.prototype = {$isFilter: 1};
  A.SembastCustomFilter.prototype = {
    matchesRecord$1(record) {
      var t1, exception;
      try {
        t1 = this.matches.call$1(record);
        return t1;
      } catch (exception) {
        return false;
      }
    },
    toString$0(_) {
      return "SembastCustomFilter()";
    }
  };
  A.FilterAnyInListMixin.prototype = {};
  A.FilterValueMixin.prototype = {};
  A.FilterFieldMixin.prototype = {};
  A._FilterSmartMatchMixin.prototype = {
    smartMatchesRecord$2(record, match) {
      var t1, t2, t3, t4, t5, field;
      type$.bool_Function_nullable_Object._as(match);
      t1 = this.FilterFieldMixin___FilterFieldMixin_field_A;
      t1 === $ && A.throwLateFieldNI("field");
      t2 = record.snapshot;
      t3 = t2.RecordSnapshotMixin___RecordSnapshotMixin_rawValue_A;
      t3 === $ && A.throwLateFieldNI("rawValue");
      t4 = type$.Map_dynamic_dynamic;
      if (!(t4._is(t3) || t1 === "_value" || t1 === "_key"))
        return false;
      t5 = new A._FilterSmartMatchMixin_smartMatchesRecord_matchValue(this, match);
      if (t1 === "_value")
        return t5.call$1(t3);
      else if (t1 === "_key") {
        t1 = A.RecordSnapshotMixin.prototype.get$key.call(t2);
        return t5.call$1(t1);
      } else {
        if (this.FilterAnyInListMixin_anyInList === true)
          field = t1 + ".@";
        else
          field = t1;
        return A.smartMatchPartsMapValue(t4._as(t3), A.getFieldParts(field), match);
      }
    }
  };
  A._FilterSmartMatchMixin_smartMatchesRecord_matchValue.prototype = {
    call$1(value) {
      var t2,
        t1 = this.$this.FilterAnyInListMixin_anyInList;
      if (t1 === true) {
        if (type$.Iterable_dynamic._is(value))
          for (t1 = J.get$iterator$ax(value), t2 = this.match; t1.moveNext$0();)
            if (t2.call$1(t1.get$current()))
              return true;
        return false;
      }
      return this.match.call$1(value);
    },
    $signature: 3
  };
  A.SembastEqualsFilter.prototype = {
    matchesRecord$1(record) {
      var _this = this,
        t1 = _this.FilterValueMixin___FilterValueMixin_value_A;
      t1 === $ && A.throwLateFieldNI("value");
      if (t1 == null) {
        t1 = _this.FilterFieldMixin___FilterFieldMixin_field_A;
        t1 === $ && A.throwLateFieldNI("field");
        return record.snapshot.getRawValue$1(t1) == null;
      }
      return _this.smartMatchesRecord$2(record, new A.SembastEqualsFilter_matchesRecord_match(_this));
    },
    toString$0(_) {
      var t2,
        t1 = this.FilterFieldMixin___FilterFieldMixin_field_A;
      t1 === $ && A.throwLateFieldNI("field");
      t2 = this.FilterValueMixin___FilterValueMixin_value_A;
      t2 === $ && A.throwLateFieldNI("value");
      return t1 + " == " + A.S(t2);
    }
  };
  A.SembastEqualsFilter_matchesRecord_match.prototype = {
    call$1(value) {
      var t1 = this.$this.FilterValueMixin___FilterValueMixin_value_A;
      t1 === $ && A.throwLateFieldNI("value");
      return A.valuesAreEquals(value, t1);
    },
    $signature: 3
  };
  A.SembastNotEqualsFilter.prototype = {
    matchesRecord$1(record) {
      return !this.super$SembastEqualsFilter$matchesRecord(record);
    },
    toString$0(_) {
      var t2,
        t1 = this.FilterFieldMixin___FilterFieldMixin_field_A;
      t1 === $ && A.throwLateFieldNI("field");
      t2 = this.FilterValueMixin___FilterValueMixin_value_A;
      t2 === $ && A.throwLateFieldNI("value");
      return t1 + " != " + A.S(t2);
    }
  };
  A.SembastCompositeFilter.prototype = {
    matchesRecord$1(record) {
      var t1, t2, _i;
      for (t1 = this.filters, t2 = t1.length, _i = 0; _i < t1.length; t1.length === t2 || (0, A.throwConcurrentModificationError)(t1), ++_i)
        if (!t1[_i].matchesRecord$1(record))
          return false;
      return true;
    },
    toString$0(_) {
      return B.JSArray_methods.join$1(this.filters, " AND ");
    }
  };
  A._SembastEqualsFilter_SembastFilterBase_FilterAnyInListMixin.prototype = {};
  A._SembastEqualsFilter_SembastFilterBase_FilterAnyInListMixin_FilterValueMixin.prototype = {};
  A._SembastEqualsFilter_SembastFilterBase_FilterAnyInListMixin_FilterValueMixin_FilterFieldMixin.prototype = {};
  A._SembastEqualsFilter_SembastFilterBase_FilterAnyInListMixin_FilterValueMixin_FilterFieldMixin__FilterSmartMatchMixin.prototype = {};
  A.SembastFinder.prototype = {
    compare$2(record1, record2) {
      var t2, t3, _i, t4, t5,
        t1 = this.sortOrders,
        result = 0;
      if (t1 != null)
        for (t2 = t1.length, t3 = type$.SembastSortOrder_nullable_Object, _i = 0; _i < t1.length; t1.length === t2 || (0, A.throwConcurrentModificationError)(t1), ++_i) {
          t4 = t3._as(t1[_i]);
          t5 = t4.field;
          result = t4.compareValueAscending$2(record1.$index(0, t5), record2.$index(0, t5));
          result = t4.ascending ? result : -result;
          if (result !== 0)
            break;
        }
      return result;
    },
    compareThenKey$2(record1, record2) {
      var result = this.compare$2(record1, record2);
      if (result === 0)
        return A.compareValue(record1.get$key(), record2.get$key());
      return result;
    },
    toString$0(_) {
      var t1 = A.LinkedHashMap_LinkedHashMap$_empty(type$.String, type$.nullable_Object),
        t2 = this.filter;
      if (t2 != null)
        t1.$indexSet(0, "filter", t2);
      t2 = this.sortOrders;
      if (t2 != null)
        t1.$indexSet(0, "sort", t2);
      t2 = this.limit;
      if (t2 != null)
        t1.$indexSet(0, "limit", t2);
      return "Finder(" + t1.toString$0(0) + ")";
    },
    $isFinder: 1
  };
  A.ImmutableList.prototype = {
    get$length(_) {
      return this._list.length;
    },
    $index(_, index) {
      var t1 = this._list;
      if (!(index >= 0 && index < t1.length))
        return A.ioore(t1, index);
      return this.$ti._precomputed1._as(A.immutableValueOrNull(t1[index]));
    }
  };
  A.ImmutableMap.prototype = {
    $index(_, key) {
      var t1 = this._immutable_utils$_map,
        t2 = this.$ti;
      return t2._eval$1("2?")._as(A.immutableValueOrNull(t1.$ti._eval$1("4?")._as(t1._source.$index(0, t2._precomputed1._as(key)))));
    },
    $indexSet(_, key, value) {
      var t1 = this.$ti;
      t1._precomputed1._as(key);
      t1._rest[1]._as(value);
      return A.throwExpression(A.StateError$("read only"));
    },
    get$keys() {
      var t1 = this._immutable_utils$_map,
        t2 = t1.$ti;
      return A.CastIterable_CastIterable(t1._source.get$keys(), t2._precomputed1, t2._rest[2]);
    }
  };
  A.JsonEncodableEncoder.prototype = {
    convert$1(input) {
      var t1;
      type$.Object._as(input);
      t1 = this._codec._adapters;
      return A.toJsonEncodable(input, new A.LinkedHashMapValuesIterable(t1, A._instanceType(t1)._eval$1("LinkedHashMapValuesIterable<2>")));
    }
  };
  A.JsonEncodableDecoder.prototype = {};
  A.JsonEncodableCodec.prototype = {
    get$encoder() {
      var t1 = this.__JsonEncodableCodec__encoder_A;
      t1 === $ && A.throwLateFieldNI("_encoder");
      return t1;
    },
    supportsType$1(value) {
      var t1;
      for (t1 = this._adapters, t1 = new A.LinkedHashMapValueIterator(t1, t1._modifications, t1._first, A._instanceType(t1)._eval$1("LinkedHashMapValueIterator<2>")); t1.moveNext$0();)
        if (t1.__js_helper$_current.isType$1(value))
          return true;
      return false;
    }
  };
  A._toJsonEncodable_closure.prototype = {
    call$2(key, item) {
      var converted, t1, t2;
      if (typeof key != "string")
        throw A.wrapException(A.ArgumentError$value(key, null, null));
      converted = A._toJsonEncodable(item, this.adapters);
      if (converted == null ? item != null : converted !== item) {
        t1 = this._box_0;
        t2 = t1.clone;
        (t2 == null ? t1.clone = A.LinkedHashMap_LinkedHashMap$from(this.map, type$.String, type$.nullable_Object) : t2).$indexSet(0, key, converted);
      }
    },
    $signature: 4
  };
  A.DatabaseListener.prototype = {
    close$0() {
      var t1, t2, t3, t4, recordListeners;
      for (t1 = this._listener$_stores, t2 = new A.LinkedHashMapValueIterator(t1, t1._modifications, t1._first, A._instanceType(t1)._eval$1("LinkedHashMapValueIterator<2>")); t2.moveNext$0();) {
        t3 = t2.__js_helper$_current;
        for (t4 = t3.get$_listener$_stores(), t4 = t4.get$iterator(t4); t4.moveNext$0();)
          t4.get$current().close$0();
        for (t3 = t3.get$_listener$_records().get$values(), t3 = t3.get$iterator(t3); t3.moveNext$0();) {
          recordListeners = t3.get$current();
          for (t4 = recordListeners.get$iterator(recordListeners); t4.moveNext$0();)
            t4.get$current().close$0();
        }
      }
      t1.clear$0(0);
    }
  };
  A.DatabaseFactoryMemory.prototype = {
    doDeleteDatabase$1(path) {
      return this.doDeleteDatabase$body$DatabaseFactoryMemory(path);
    },
    doDeleteDatabase$body$DatabaseFactoryMemory(path) {
      var $async$goto = 0,
        $async$completer = A._makeAsyncAwaitCompleter(type$.dynamic),
        $async$self = this;
      var $async$doDeleteDatabase$1 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return A._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$self._databases.remove$1(0, path);
              $async$self._exists.remove$1(0, path);
              // implicit return
              return A._asyncReturn(null, $async$completer);
          }
      });
      return A._asyncStartSync($async$doDeleteDatabase$1, $async$completer);
    },
    openDatabaseWithOptions$2(path, options) {
      return this.openDatabaseWithOptions$body$DatabaseFactoryMemory(path, options);
    },
    openDatabaseWithOptions$body$DatabaseFactoryMemory(path, options) {
      var $async$goto = 0,
        $async$completer = A._makeAsyncAwaitCompleter(type$.Database_2),
        $async$returnValue, $async$self = this;
      var $async$openDatabaseWithOptions$2 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return A._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$goto = path === "sembast://memory" ? 3 : 4;
              break;
            case 3:
              // then
              $async$goto = 5;
              return A._asyncAwait($async$self.doDeleteDatabase$1(path), $async$openDatabaseWithOptions$2);
            case 5:
              // returning from await.
              $async$returnValue = A.DatabaseOpenHelper$($async$self, path, options).openDatabase$0();
              // goto return
              $async$goto = 1;
              break;
            case 4:
              // join
              $async$returnValue = $async$self.super$SembastDatabaseFactoryMixin$openDatabaseWithOptions(path, options);
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return A._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return A._asyncStartSync($async$openDatabaseWithOptions$2, $async$completer);
    }
  };
  A.DatabaseStorageMemory.prototype = {
    findOrCreate$0() {
      var $async$goto = 0,
        $async$completer = A._makeAsyncAwaitCompleter(type$.void),
        $async$self = this;
      var $async$findOrCreate$0 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return A._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$self.factory._exists.$indexSet(0, $async$self.path, true);
              // implicit return
              return A._asyncReturn(null, $async$completer);
          }
      });
      return A._asyncStartSync($async$findOrCreate$0, $async$completer);
    },
    delete$0() {
      var $async$goto = 0,
        $async$completer = A._makeAsyncAwaitCompleter(type$.void);
      var $async$delete$0 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return A._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              // implicit return
              return A._asyncReturn(null, $async$completer);
          }
      });
      return A._asyncStartSync($async$delete$0, $async$completer);
    },
    appendLines$1(lines) {
      type$.List_String._as(lines);
      return A.throwExpression(A.UnimplementedError$("appendLines"));
    },
    tmpRecover$0() {
      return A.throwExpression(A.UnimplementedError$("tmpRecover"));
    },
    openAppend$0() {
      throw A.wrapException(A.UnimplementedError$("openAppend"));
    }
  };
  A._DatabaseFactoryMemory_SembastDatabaseFactory_SembastDatabaseFactoryMixin.prototype = {};
  A.Meta.prototype = {
    toMap$0() {
      var map = A.LinkedHashMap_LinkedHashMap$_literal(["version", this.version, "sembast", this.sembastVersion], type$.String, type$.nullable_Object),
        t1 = this.codecSignature;
      if (t1 != null)
        map.$indexSet(0, "codec", t1);
      return map;
    },
    toString$0(_) {
      return A.MapBase_mapToString(this.toMap$0());
    }
  };
  A.SembastRecordHelperMixin.prototype = {
    _toBaseMap$0() {
      var t1, _this = this, _s5_ = "store",
        map = A.LinkedHashMap_LinkedHashMap$_empty(type$.String, type$.nullable_Object);
      map.$indexSet(0, "key", _this.get$key());
      if (_this.get$deleted())
        map.$indexSet(0, "deleted", true);
      t1 = _this.get$ref().RecordRefMixin___RecordRefMixin_store_A;
      t1 === $ && A.throwLateFieldNI(_s5_);
      if (!t1.$eq(0, $.$get$mainStoreRef())) {
        t1 = _this.get$ref().RecordRefMixin___RecordRefMixin_store_A;
        t1 === $ && A.throwLateFieldNI(_s5_);
        t1 = t1.StoreRefMixin___StoreRefMixin_name_A;
        t1 === $ && A.throwLateFieldNI("name");
        map.$indexSet(0, _s5_, t1);
      }
      return map;
    },
    toDatabaseRowMap$0() {
      var t1, _this = this, _s5_ = "store",
        map = A.LinkedHashMap_LinkedHashMap$_empty(type$.String, type$.nullable_Object);
      map.$indexSet(0, "key", _this.get$key());
      if (_this.get$deleted())
        map.$indexSet(0, "deleted", true);
      t1 = _this.get$ref().RecordRefMixin___RecordRefMixin_store_A;
      t1 === $ && A.throwLateFieldNI(_s5_);
      if (!t1.$eq(0, $.$get$mainStoreRef())) {
        t1 = _this.get$ref().RecordRefMixin___RecordRefMixin_store_A;
        t1 === $ && A.throwLateFieldNI(_s5_);
        t1 = t1.StoreRefMixin___StoreRefMixin_name_A;
        t1 === $ && A.throwLateFieldNI("name");
        map.$indexSet(0, _s5_, t1);
      }
      if (!_this.get$deleted())
        map.$indexSet(0, "value", _this.get$value());
      return map;
    },
    get$hashCode(_) {
      return J.get$hashCode$(this.get$key());
    },
    $eq(_, other) {
      if (other == null)
        return false;
      if (type$.SembastRecord._is(other))
        return J.$eq$(this.get$key(), other.get$key());
      return false;
    }
  };
  A.SembastRecordMixin.prototype = {
    get$deleted() {
      return this.SembastRecordMixin__deleted === true;
    },
    set$value(value) {
      this.RecordSnapshotMixin___RecordSnapshotMixin_rawValue_A = A._instanceType(this)._eval$1("RecordSnapshotMixin.V")._as(A.sanitizeValueIfMap(value));
    }
  };
  A.ImmutableSembastRecordJdb.prototype = {};
  A.ImmutableSembastRecord.prototype = {
    get$key() {
      var t1 = A.RecordSnapshotMixin.prototype.get$key.call(this);
      return t1;
    },
    get$value() {
      var t1 = A.RecordSnapshotMixin.prototype.get$value.call(this);
      t1 = A.immutableValueOrNull(t1);
      t1.toString;
      return t1;
    },
    ImmutableSembastRecord$3$deleted(ref, value, deleted) {
      var _this = this;
      _this.RecordSnapshotMixin___RecordSnapshotMixin_ref_A = A._instanceType(_this)._eval$1("RecordRef<RecordSnapshotMixin.K,RecordSnapshotMixin.V>")._as(ref);
      _this.SembastRecordMixin__deleted = deleted;
      if (!deleted) {
        value.toString;
        _this.super$SembastRecordMixin$value(value);
      }
      _this.RecordSnapshotMixin_revision = $.ImmutableSembastRecord__lastRevision = $.ImmutableSembastRecord__lastRevision + 1;
    },
    ImmutableSembastRecord$noValue$2$deleted(ref, deleted) {
      var _this = this;
      _this.RecordSnapshotMixin___RecordSnapshotMixin_ref_A = A._instanceType(_this)._eval$1("RecordRef<RecordSnapshotMixin.K,RecordSnapshotMixin.V>")._as(ref);
      _this.SembastRecordMixin__deleted = true;
      _this.RecordSnapshotMixin_revision = $.ImmutableSembastRecord__lastRevision = $.ImmutableSembastRecord__lastRevision + 1;
    },
    toString$0(_) {
      var map = this.toDatabaseRowMap$0(),
        t1 = this.RecordSnapshotMixin_revision;
      if (t1 != null)
        map.$indexSet(0, "revision", t1);
      return A.MapBase_mapToString(map);
    },
    $isRecordSnapshot: 1,
    $isSembastRecord: 1
  };
  A.TxnRecord.prototype = {
    $index(_, field) {
      return this.record.getValue$1(field);
    },
    get$deleted() {
      return this.record.SembastRecordMixin__deleted === true;
    },
    get$key() {
      var t1 = this.record;
      t1 = A.RecordSnapshotMixin.prototype.get$key.call(t1);
      return t1;
    },
    get$value() {
      var t1 = this.record;
      t1 = A.RecordSnapshotMixin.prototype.get$value.call(t1);
      t1 = A.immutableValueOrNull(t1);
      t1.toString;
      return t1;
    },
    get$ref() {
      var t1 = this.record.RecordSnapshotMixin___RecordSnapshotMixin_ref_A;
      t1 === $ && A.throwLateFieldNI("ref");
      return t1;
    },
    $isRecordSnapshot: 1,
    $isSembastRecord: 1
  };
  A._ImmutableSembastRecord_Object_SembastRecordMixin.prototype = {};
  A._ImmutableSembastRecord_Object_SembastRecordMixin_SembastRecordHelperMixin.prototype = {};
  A._ImmutableSembastRecord_Object_SembastRecordMixin_SembastRecordHelperMixin_RecordSnapshotMixin.prototype = {};
  A._TxnRecord_Object_SembastRecordHelperMixin.prototype = {};
  A.RecordRefMixin.prototype = {
    toString$0(_) {
      var t2,
        t1 = this.RecordRefMixin___RecordRefMixin_store_A;
      t1 === $ && A.throwLateFieldNI("store");
      t1 = t1.StoreRefMixin___StoreRefMixin_name_A;
      t1 === $ && A.throwLateFieldNI("name");
      t2 = this.RecordRefMixin___RecordRefMixin_key_A;
      t2 === $ && A.throwLateFieldNI("key");
      return "Record(" + t1 + ", " + A.S(t2) + ")";
    },
    get$hashCode(_) {
      var t1 = this.RecordRefMixin___RecordRefMixin_key_A;
      t1 === $ && A.throwLateFieldNI("key");
      return J.get$hashCode$(t1);
    },
    $eq(_, other) {
      var t1, t2;
      if (other == null)
        return false;
      if (other instanceof A.SembastRecordRef) {
        t1 = other.RecordRefMixin___RecordRefMixin_store_A;
        t1 === $ && A.throwLateFieldNI("store");
        t2 = this.RecordRefMixin___RecordRefMixin_store_A;
        t2 === $ && A.throwLateFieldNI("store");
        if (t1.$eq(0, t2)) {
          t1 = other.RecordRefMixin___RecordRefMixin_key_A;
          t1 === $ && A.throwLateFieldNI("key");
          t2 = this.RecordRefMixin___RecordRefMixin_key_A;
          t2 === $ && A.throwLateFieldNI("key");
          t2 = J.$eq$(t1, t2);
          t1 = t2;
        } else
          t1 = false;
        return t1;
      }
      return false;
    }
  };
  A.SembastRecordRef.prototype = {$isRecordRef: 1};
  A.SembastRecordRefExtension_add_closure.prototype = {
    call$1(txn) {
      var t3, _this = this,
        t1 = _this._this,
        t2 = t1.RecordRefMixin___RecordRefMixin_store_A;
      t2 === $ && A.throwLateFieldNI("store");
      t2 = _this.client.getSembastStore$1(t2);
      t3 = _this._box_0.value;
      t1 = t1.RecordRefMixin___RecordRefMixin_key_A;
      t1 === $ && A.throwLateFieldNI("key");
      return t2.txnAdd$1$3(txn, t3, t1, _this.K);
    },
    $signature() {
      return this.K._eval$1("Future<0?>(SembastTransaction)");
    }
  };
  A.SembastRecordRefExtension_put_closure.prototype = {
    call$1(txn) {
      var t3, _this = this,
        t1 = _this._this,
        t2 = t1.RecordRefMixin___RecordRefMixin_store_A;
      t2 === $ && A.throwLateFieldNI("store");
      t2 = _this.client.getSembastStore$1(t2);
      t3 = _this._box_0.value;
      t1 = t1.RecordRefMixin___RecordRefMixin_key_A;
      t1 === $ && A.throwLateFieldNI("key");
      return t2.txnPut$5$ifNotExists$merge(txn, t3, t1, _this.ifNotExists, _this.merge);
    },
    $signature: 66
  };
  A.SembastRecordRefExtension_delete_closure.prototype = {
    call$1(txn) {
      return this.$call$body$SembastRecordRefExtension_delete_closure(txn, this.K._eval$1("0?"));
    },
    $call$body$SembastRecordRefExtension_delete_closure(txn, $async$type) {
      var $async$goto = 0,
        $async$completer = A._makeAsyncAwaitCompleter($async$type),
        $async$returnValue, $async$self = this, t1, t2, $async$temp1;
      var $async$call$1 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return A._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = $async$self._this;
              t2 = t1.RecordRefMixin___RecordRefMixin_store_A;
              t2 === $ && A.throwLateFieldNI("store");
              t2 = $async$self.client.getSembastStore$1(t2);
              t1 = t1.RecordRefMixin___RecordRefMixin_key_A;
              t1 === $ && A.throwLateFieldNI("key");
              $async$temp1 = $async$self.K._eval$1("0?");
              $async$goto = 3;
              return A._asyncAwait(t2.txnDelete$2(txn, t1), $async$call$1);
            case 3:
              // returning from await.
              $async$returnValue = $async$temp1._as($async$result);
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return A._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return A._asyncStartSync($async$call$1, $async$completer);
    },
    $signature() {
      return this.K._eval$1("Future<0?>(SembastTransaction)");
    }
  };
  A._SembastRecordRef_Object_RecordRefMixin.prototype = {};
  A.RecordSnapshotMixin.prototype = {
    get$ref() {
      var t1 = this.RecordSnapshotMixin___RecordSnapshotMixin_ref_A;
      t1 === $ && A.throwLateFieldNI("ref");
      return t1;
    },
    get$key() {
      var t1 = this.RecordSnapshotMixin___RecordSnapshotMixin_ref_A;
      t1 === $ && A.throwLateFieldNI("ref");
      t1 = t1.RecordRefMixin___RecordRefMixin_key_A;
      t1 === $ && A.throwLateFieldNI("key");
      return t1;
    },
    get$value() {
      var t1 = this.RecordSnapshotMixin___RecordSnapshotMixin_rawValue_A;
      t1 === $ && A.throwLateFieldNI("rawValue");
      return t1;
    },
    toString$0(_) {
      var t2,
        t1 = this.RecordSnapshotMixin___RecordSnapshotMixin_ref_A;
      t1 === $ && A.throwLateFieldNI("ref");
      t1 = t1.toString$0(0);
      t2 = this.RecordSnapshotMixin___RecordSnapshotMixin_rawValue_A;
      t2 === $ && A.throwLateFieldNI("rawValue");
      return t1 + " " + A.S(t2);
    },
    $index(_, field) {
      return this.getValue$1(field);
    },
    getValue$1(field) {
      var t1, _this = this;
      if (field === "_value")
        return _this.get$value();
      else if (field === "_key")
        return _this.get$key();
      else {
        t1 = type$.Map_dynamic_dynamic;
        if (t1._is(_this.get$value()))
          return A.getPartsMapValue(t1._as(_this.get$value()), A.getFieldParts(field), type$.Object);
      }
      return null;
    },
    getRawValue$1(field) {
      var t1, map, _this = this;
      if (field === "_value")
        return _this.get$value();
      else if (field === "_key")
        return _this.get$key();
      else {
        t1 = type$.Map_dynamic_dynamic;
        if (t1._is(_this.get$value())) {
          map = t1._as(_this.get$value());
          t1 = A.getFieldParts(field);
          if (map instanceof A.ImmutableMap)
            map = map._immutable_utils$_map;
          return A.getPartsMapValue(map, t1, type$.nullable_Object);
        }
      }
      return null;
    }
  };
  A.SembastRecordSnapshot.prototype = {$isRecordSnapshot: 1};
  A.SembastRecordRawSnapshot.prototype = {
    get$value() {
      var t1 = this.snapshot.RecordSnapshotMixin___RecordSnapshotMixin_rawValue_A;
      t1 === $ && A.throwLateFieldNI("rawValue");
      return t1;
    },
    get$key() {
      var t1 = this.snapshot;
      t1 = A.RecordSnapshotMixin.prototype.get$key.call(t1);
      return t1;
    },
    $isRecordSnapshot: 1
  };
  A._SembastRecordSnapshot_Object_RecordSnapshotMixin.prototype = {};
  A.RecordsRefMixin.prototype = {
    toString$0(_) {
      var t2,
        t1 = this.RecordsRefMixin___RecordsRefMixin_store_A;
      t1 === $ && A.throwLateFieldNI("store");
      t1 = t1.StoreRefMixin___StoreRefMixin_name_A;
      t1 === $ && A.throwLateFieldNI("name");
      t2 = this.RecordsRefMixin___RecordsRefMixin_keys_A;
      t2 === $ && A.throwLateFieldNI("keys");
      return "Records(" + t1 + ", " + A.S(t2) + ")";
    }
  };
  A.SembastRecordsRef.prototype = {$isRecordsRef: 1};
  A._SembastRecordsRef_Object_RecordsRefMixin.prototype = {};
  A.Sort.prototype = {
    _doSort$1$4(a, left, right, compare, $E) {
      return this._doSort$body$Sort($E._eval$1("List<0>")._as(a), left, right, $E._eval$1("int(0,0)")._as(compare), $E);
    },
    _doSort$body$Sort(a, left, right, compare, $E) {
      var $async$goto = 0,
        $async$completer = A._makeAsyncAwaitCompleter(type$.dynamic),
        $async$returnValue, $async$self = this;
      var $async$_doSort$1$4 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return A._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              if (right - left <= 32) {
                $async$returnValue = $async$self._insertionSort$1$4(a, left, right, compare, $E);
                // goto return
                $async$goto = 1;
                break;
              } else {
                $async$returnValue = $async$self._dualPivotQuicksort$1$4(a, left, right, compare, $E);
                // goto return
                $async$goto = 1;
                break;
              }
            case 1:
              // return
              return A._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return A._asyncStartSync($async$_doSort$1$4, $async$completer);
    },
    _insertionSort$1$4(a, left, right, compare, $E) {
      return this._insertionSort$body$Sort($E._eval$1("List<0>")._as(a), left, right, $E._eval$1("int(0,0)")._as(compare), $E);
    },
    _insertionSort$body$Sort(a, left, right, compare, $E) {
      var $async$goto = 0,
        $async$completer = A._makeAsyncAwaitCompleter(type$.dynamic),
        $async$returnValue, $async$self = this, i, t1, t2, t3, t4, el, j, t5, j0;
      var $async$_insertionSort$1$4 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return A._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              i = left + 1, t1 = $async$self.cooperator, t2 = t1._cooperateStopWatch, t3 = type$._Future_dynamic;
            case 3:
              // for condition
              if (!(i <= right)) {
                // goto after for
                $async$goto = 5;
                break;
              }
              t4 = a.length;
              if (!(i >= 0 && i < t4)) {
                $async$returnValue = A.ioore(a, i);
                // goto return
                $async$goto = 1;
                break;
              }
              el = a[i];
              j = i;
            case 6:
              // while condition
              if (j > left) {
                t5 = j - 1;
                if (!(t5 >= 0 && t5 < t4)) {
                  $async$returnValue = A.ioore(a, t5);
                  // goto return
                  $async$goto = 1;
                  break;
                }
                t5 = compare.call$2(a[t5], el);
                if (typeof t5 !== "number") {
                  $async$returnValue = t5.$gt();
                  // goto return
                  $async$goto = 1;
                  break;
                }
                t5 = t5 > 0;
                t4 = t5;
              } else
                t4 = false;
              if (!t4) {
                // goto after while
                $async$goto = 7;
                break;
              }
              t4 = t1._paused || t2.get$elapsedMicroseconds() > 24000;
              $async$goto = t4 ? 8 : 9;
              break;
            case 8:
              // then
              t4 = t1.cooperate$0();
              if (!(t4 instanceof A._Future)) {
                t5 = new A._Future($.Zone__current, t3);
                t5._state = 8;
                t5._resultOrListeners = t4;
                t4 = t5;
              }
              $async$goto = 10;
              return A._asyncAwait(t4, $async$_insertionSort$1$4);
            case 10:
              // returning from await.
            case 9:
              // join
              j0 = j - 1;
              t4 = a.length;
              if (!(j0 >= 0 && j0 < t4)) {
                $async$returnValue = A.ioore(a, j0);
                // goto return
                $async$goto = 1;
                break;
              }
              t5 = a[j0];
              if (!(j >= 0 && j < t4)) {
                $async$returnValue = A.ioore(a, j);
                // goto return
                $async$goto = 1;
                break;
              }
              a[j] = t5;
              j = j0;
              // goto while condition
              $async$goto = 6;
              break;
            case 7:
              // after while
              if (!(j >= 0 && j < a.length)) {
                $async$returnValue = A.ioore(a, j);
                // goto return
                $async$goto = 1;
                break;
              }
              a[j] = el;
            case 4:
              // for update
              ++i;
              // goto for condition
              $async$goto = 3;
              break;
            case 5:
              // after for
            case 1:
              // return
              return A._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return A._asyncStartSync($async$_insertionSort$1$4, $async$completer);
    },
    _dualPivotQuicksort$1$4(a, left, right, compare, $E) {
      return this._dualPivotQuicksort$body$Sort($E._eval$1("List<0>")._as(a), left, right, $E._eval$1("int(0,0)")._as(compare), $E);
    },
    _dualPivotQuicksort$body$Sort(a, left, right, compare, $E) {
      var $async$goto = 0,
        $async$completer = A._makeAsyncAwaitCompleter(type$.dynamic),
        $async$returnValue, $async$self = this, el1, el2, el3, el4, el5, t0, t2, less, great, pivots_are_equal, t3, k, ak, comp, t4, t5, great0, less0, comp_pivot1, comp_pivot2, sixth, index1, index5, index3, index2, index4, t1;
      var $async$_dualPivotQuicksort$1$4 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return A._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              sixth = B.JSInt_methods._tdivFast$1(right - left + 1, 6);
              index1 = left + sixth;
              index5 = right - sixth;
              index3 = B.JSInt_methods._tdivFast$1(left + right, 2);
              index2 = index3 - sixth;
              index4 = index3 + sixth;
              t1 = a.length;
              if (!(index1 >= 0 && index1 < t1)) {
                $async$returnValue = A.ioore(a, index1);
                // goto return
                $async$goto = 1;
                break;
              }
              el1 = a[index1];
              if (!(index2 >= 0 && index2 < t1)) {
                $async$returnValue = A.ioore(a, index2);
                // goto return
                $async$goto = 1;
                break;
              }
              el2 = a[index2];
              if (!(index3 >= 0 && index3 < t1)) {
                $async$returnValue = A.ioore(a, index3);
                // goto return
                $async$goto = 1;
                break;
              }
              el3 = a[index3];
              if (!(index4 >= 0 && index4 < t1)) {
                $async$returnValue = A.ioore(a, index4);
                // goto return
                $async$goto = 1;
                break;
              }
              el4 = a[index4];
              if (!(index5 >= 0 && index5 < t1)) {
                $async$returnValue = A.ioore(a, index5);
                // goto return
                $async$goto = 1;
                break;
              }
              el5 = a[index5];
              t1 = compare.call$2(el1, el2);
              if (typeof t1 !== "number") {
                $async$returnValue = t1.$gt();
                // goto return
                $async$goto = 1;
                break;
              }
              if (t1 > 0) {
                t0 = el2;
                el2 = el1;
                el1 = t0;
              }
              t1 = compare.call$2(el4, el5);
              if (typeof t1 !== "number") {
                $async$returnValue = t1.$gt();
                // goto return
                $async$goto = 1;
                break;
              }
              if (t1 > 0) {
                t0 = el5;
                el5 = el4;
                el4 = t0;
              }
              t1 = compare.call$2(el1, el3);
              if (typeof t1 !== "number") {
                $async$returnValue = t1.$gt();
                // goto return
                $async$goto = 1;
                break;
              }
              if (t1 > 0) {
                t0 = el3;
                el3 = el1;
                el1 = t0;
              }
              t1 = compare.call$2(el2, el3);
              if (typeof t1 !== "number") {
                $async$returnValue = t1.$gt();
                // goto return
                $async$goto = 1;
                break;
              }
              if (t1 > 0) {
                t0 = el3;
                el3 = el2;
                el2 = t0;
              }
              t1 = compare.call$2(el1, el4);
              if (typeof t1 !== "number") {
                $async$returnValue = t1.$gt();
                // goto return
                $async$goto = 1;
                break;
              }
              if (t1 > 0) {
                t0 = el4;
                el4 = el1;
                el1 = t0;
              }
              t1 = compare.call$2(el3, el4);
              if (typeof t1 !== "number") {
                $async$returnValue = t1.$gt();
                // goto return
                $async$goto = 1;
                break;
              }
              if (t1 > 0) {
                t0 = el4;
                el4 = el3;
                el3 = t0;
              }
              t1 = compare.call$2(el2, el5);
              if (typeof t1 !== "number") {
                $async$returnValue = t1.$gt();
                // goto return
                $async$goto = 1;
                break;
              }
              if (t1 > 0) {
                t0 = el5;
                el5 = el2;
                el2 = t0;
              }
              t1 = compare.call$2(el2, el3);
              if (typeof t1 !== "number") {
                $async$returnValue = t1.$gt();
                // goto return
                $async$goto = 1;
                break;
              }
              if (t1 > 0) {
                t0 = el3;
                el3 = el2;
                el2 = t0;
              }
              t1 = compare.call$2(el4, el5);
              if (typeof t1 !== "number") {
                $async$returnValue = t1.$gt();
                // goto return
                $async$goto = 1;
                break;
              }
              if (t1 > 0) {
                t0 = el5;
                el5 = el4;
                el4 = t0;
              }
              B.JSArray_methods.$indexSet(a, index1, el1);
              B.JSArray_methods.$indexSet(a, index3, el3);
              B.JSArray_methods.$indexSet(a, index5, el5);
              t1 = a.length;
              if (!(left >= 0 && left < t1)) {
                $async$returnValue = A.ioore(a, left);
                // goto return
                $async$goto = 1;
                break;
              }
              t2 = a[left];
              if (!(index2 < t1)) {
                $async$returnValue = A.ioore(a, index2);
                // goto return
                $async$goto = 1;
                break;
              }
              a[index2] = t2;
              if (!(right >= 0 && right < t1)) {
                $async$returnValue = A.ioore(a, right);
                // goto return
                $async$goto = 1;
                break;
              }
              t2 = a[right];
              if (!(index4 < t1)) {
                $async$returnValue = A.ioore(a, index4);
                // goto return
                $async$goto = 1;
                break;
              }
              a[index4] = t2;
              less = left + 1;
              great = right - 1;
              pivots_are_equal = J.$eq$(compare.call$2(el2, el4), 0);
              $async$goto = pivots_are_equal ? 3 : 5;
              break;
            case 3:
              // then
              t1 = $async$self.cooperator, t2 = t1._cooperateStopWatch, t3 = type$._Future_dynamic, k = less;
            case 6:
              // for condition
              if (!(k <= great)) {
                // goto after for
                $async$goto = 8;
                break;
              }
              if (!(k < a.length)) {
                $async$returnValue = A.ioore(a, k);
                // goto return
                $async$goto = 1;
                break;
              }
              ak = a[k];
              comp = compare.call$2(ak, el2);
              t4 = t1._paused || t2.get$elapsedMicroseconds() > 24000;
              $async$goto = t4 ? 9 : 10;
              break;
            case 9:
              // then
              t4 = t1.cooperate$0();
              if (!(t4 instanceof A._Future)) {
                t5 = new A._Future($.Zone__current, t3);
                t5._state = 8;
                t5._resultOrListeners = t4;
                t4 = t5;
              }
              $async$goto = 11;
              return A._asyncAwait(t4, $async$_dualPivotQuicksort$1$4);
            case 11:
              // returning from await.
            case 10:
              // join
              if (comp === 0) {
                // goto for update
                $async$goto = 7;
                break;
              }
              $async$goto = comp < 0 ? 12 : 14;
              break;
            case 12:
              // then
              if (k !== less) {
                t4 = a.length;
                if (!(less < t4)) {
                  $async$returnValue = A.ioore(a, less);
                  // goto return
                  $async$goto = 1;
                  break;
                }
                t5 = a[less];
                if (!(k < t4)) {
                  $async$returnValue = A.ioore(a, k);
                  // goto return
                  $async$goto = 1;
                  break;
                }
                a[k] = t5;
                a[less] = ak;
              }
              ++less;
              // goto join
              $async$goto = 13;
              break;
            case 14:
              // else
            case 15:
              // for condition
              // trivial condition
              if (!(great >= 0 && great < a.length)) {
                $async$returnValue = A.ioore(a, great);
                // goto return
                $async$goto = 1;
                break;
              }
              comp = compare.call$2(a[great], el2);
              t4 = t1._paused || t2.get$elapsedMicroseconds() > 24000;
              $async$goto = t4 ? 17 : 18;
              break;
            case 17:
              // then
              t4 = t1.cooperate$0();
              if (!(t4 instanceof A._Future)) {
                t5 = new A._Future($.Zone__current, t3);
                t5._state = 8;
                t5._resultOrListeners = t4;
                t4 = t5;
              }
              $async$goto = 19;
              return A._asyncAwait(t4, $async$_dualPivotQuicksort$1$4);
            case 19:
              // returning from await.
            case 18:
              // join
              if (comp > 0) {
                --great;
                // goto for condition
                $async$goto = 15;
                break;
              } else {
                t4 = a.length;
                great0 = great - 1;
                if (comp < 0) {
                  if (!(less < t4)) {
                    $async$returnValue = A.ioore(a, less);
                    // goto return
                    $async$goto = 1;
                    break;
                  }
                  t5 = a[less];
                  if (!(k < t4)) {
                    $async$returnValue = A.ioore(a, k);
                    // goto return
                    $async$goto = 1;
                    break;
                  }
                  a[k] = t5;
                  less0 = less + 1;
                  if (!(great < t4)) {
                    $async$returnValue = A.ioore(a, great);
                    // goto return
                    $async$goto = 1;
                    break;
                  }
                  a[less] = a[great];
                  a[great] = ak;
                  great = great0;
                  less = less0;
                  // goto after for
                  $async$goto = 16;
                  break;
                } else {
                  if (!(great < t4)) {
                    $async$returnValue = A.ioore(a, great);
                    // goto return
                    $async$goto = 1;
                    break;
                  }
                  t5 = a[great];
                  if (!(k < t4)) {
                    $async$returnValue = A.ioore(a, k);
                    // goto return
                    $async$goto = 1;
                    break;
                  }
                  a[k] = t5;
                  a[great] = ak;
                  great = great0;
                  // goto after for
                  $async$goto = 16;
                  break;
                }
              }
              // goto for condition
              $async$goto = 15;
              break;
            case 16:
              // after for
            case 13:
              // join
            case 7:
              // for update
              ++k;
              // goto for condition
              $async$goto = 6;
              break;
            case 8:
              // after for
              // goto join
              $async$goto = 4;
              break;
            case 5:
              // else
              t1 = $async$self.cooperator, t2 = t1._cooperateStopWatch, t3 = type$._Future_dynamic, k = less;
            case 20:
              // for condition
              if (!(k <= great)) {
                // goto after for
                $async$goto = 22;
                break;
              }
              if (!(k < a.length)) {
                $async$returnValue = A.ioore(a, k);
                // goto return
                $async$goto = 1;
                break;
              }
              ak = a[k];
              comp_pivot1 = compare.call$2(ak, el2);
              t4 = t1._paused || t2.get$elapsedMicroseconds() > 24000;
              $async$goto = t4 ? 23 : 24;
              break;
            case 23:
              // then
              t4 = t1.cooperate$0();
              if (!(t4 instanceof A._Future)) {
                t5 = new A._Future($.Zone__current, t3);
                t5._state = 8;
                t5._resultOrListeners = t4;
                t4 = t5;
              }
              $async$goto = 25;
              return A._asyncAwait(t4, $async$_dualPivotQuicksort$1$4);
            case 25:
              // returning from await.
            case 24:
              // join
              $async$goto = comp_pivot1 < 0 ? 26 : 28;
              break;
            case 26:
              // then
              if (k !== less) {
                t4 = a.length;
                if (!(less < t4)) {
                  $async$returnValue = A.ioore(a, less);
                  // goto return
                  $async$goto = 1;
                  break;
                }
                t5 = a[less];
                if (!(k < t4)) {
                  $async$returnValue = A.ioore(a, k);
                  // goto return
                  $async$goto = 1;
                  break;
                }
                a[k] = t5;
                a[less] = ak;
              }
              ++less;
              // goto join
              $async$goto = 27;
              break;
            case 28:
              // else
              comp_pivot2 = compare.call$2(ak, el4);
              t4 = t1._paused || t2.get$elapsedMicroseconds() > 24000;
              $async$goto = t4 ? 29 : 30;
              break;
            case 29:
              // then
              t4 = t1.cooperate$0();
              if (!(t4 instanceof A._Future)) {
                t5 = new A._Future($.Zone__current, t3);
                t5._state = 8;
                t5._resultOrListeners = t4;
                t4 = t5;
              }
              $async$goto = 31;
              return A._asyncAwait(t4, $async$_dualPivotQuicksort$1$4);
            case 31:
              // returning from await.
            case 30:
              // join
              $async$goto = comp_pivot2 > 0 ? 32 : 33;
              break;
            case 32:
              // then
            case 34:
              // for condition
              // trivial condition
              if (!(great >= 0 && great < a.length)) {
                $async$returnValue = A.ioore(a, great);
                // goto return
                $async$goto = 1;
                break;
              }
              comp = compare.call$2(a[great], el4);
              t4 = t1._paused || t2.get$elapsedMicroseconds() > 24000;
              $async$goto = t4 ? 36 : 37;
              break;
            case 36:
              // then
              t4 = t1.cooperate$0();
              if (!(t4 instanceof A._Future)) {
                t5 = new A._Future($.Zone__current, t3);
                t5._state = 8;
                t5._resultOrListeners = t4;
                t4 = t5;
              }
              $async$goto = 38;
              return A._asyncAwait(t4, $async$_dualPivotQuicksort$1$4);
            case 38:
              // returning from await.
            case 37:
              // join
              $async$goto = comp > 0 ? 39 : 41;
              break;
            case 39:
              // then
              --great;
              if (great < k) {
                // goto after for
                $async$goto = 35;
                break;
              }
              // goto for condition
              $async$goto = 34;
              break;
              // goto join
              $async$goto = 40;
              break;
            case 41:
              // else
              if (!(great < a.length)) {
                $async$returnValue = A.ioore(a, great);
                // goto return
                $async$goto = 1;
                break;
              }
              comp = compare.call$2(a[great], el2);
              t4 = t1._paused || t2.get$elapsedMicroseconds() > 24000;
              $async$goto = t4 ? 42 : 43;
              break;
            case 42:
              // then
              t4 = t1.cooperate$0();
              if (!(t4 instanceof A._Future)) {
                t5 = new A._Future($.Zone__current, t3);
                t5._state = 8;
                t5._resultOrListeners = t4;
                t4 = t5;
              }
              $async$goto = 44;
              return A._asyncAwait(t4, $async$_dualPivotQuicksort$1$4);
            case 44:
              // returning from await.
            case 43:
              // join
              t4 = a.length;
              great0 = great - 1;
              if (comp < 0) {
                if (!(less < t4)) {
                  $async$returnValue = A.ioore(a, less);
                  // goto return
                  $async$goto = 1;
                  break;
                }
                t5 = a[less];
                if (!(k < t4)) {
                  $async$returnValue = A.ioore(a, k);
                  // goto return
                  $async$goto = 1;
                  break;
                }
                a[k] = t5;
                less0 = less + 1;
                if (!(great < t4)) {
                  $async$returnValue = A.ioore(a, great);
                  // goto return
                  $async$goto = 1;
                  break;
                }
                a[less] = a[great];
                a[great] = ak;
                less = less0;
              } else {
                if (!(great < t4)) {
                  $async$returnValue = A.ioore(a, great);
                  // goto return
                  $async$goto = 1;
                  break;
                }
                t5 = a[great];
                if (!(k < t4)) {
                  $async$returnValue = A.ioore(a, k);
                  // goto return
                  $async$goto = 1;
                  break;
                }
                a[k] = t5;
                a[great] = ak;
              }
              great = great0;
              // goto after for
              $async$goto = 35;
              break;
            case 40:
              // join
              // goto for condition
              $async$goto = 34;
              break;
            case 35:
              // after for
            case 33:
              // join
            case 27:
              // join
            case 21:
              // for update
              ++k;
              // goto for condition
              $async$goto = 20;
              break;
            case 22:
              // after for
            case 4:
              // join
              t1 = less - 1;
              t2 = a.length;
              if (!(t1 < t2)) {
                $async$returnValue = A.ioore(a, t1);
                // goto return
                $async$goto = 1;
                break;
              }
              t3 = a[t1];
              if (!(left < t2)) {
                $async$returnValue = A.ioore(a, left);
                // goto return
                $async$goto = 1;
                break;
              }
              a[left] = t3;
              B.JSArray_methods.$indexSet(a, t1, el2);
              t1 = great + 1;
              t3 = a.length;
              if (!(t1 >= 0 && t1 < t3)) {
                $async$returnValue = A.ioore(a, t1);
                // goto return
                $async$goto = 1;
                break;
              }
              t2 = a[t1];
              if (!(right < t3)) {
                $async$returnValue = A.ioore(a, right);
                // goto return
                $async$goto = 1;
                break;
              }
              a[right] = t2;
              B.JSArray_methods.$indexSet(a, t1, el4);
              $async$goto = 45;
              return A._asyncAwait($async$self._doSort$1$4(a, left, less - 2, compare, $E), $async$_dualPivotQuicksort$1$4);
            case 45:
              // returning from await.
              $async$goto = 46;
              return A._asyncAwait($async$self._doSort$1$4(a, great + 2, right, compare, $E), $async$_dualPivotQuicksort$1$4);
            case 46:
              // returning from await.
              if (pivots_are_equal) {
                // goto return
                $async$goto = 1;
                break;
              }
              $async$goto = less < index1 && great > index5 ? 47 : 49;
              break;
            case 47:
              // then
              t1 = $async$self.cooperator;
              t2 = t1._cooperateStopWatch;
              t3 = type$._Future_dynamic;
            case 50:
              // while condition
              if (!(less < a.length)) {
                $async$returnValue = A.ioore(a, less);
                // goto return
                $async$goto = 1;
                break;
              }
              if (!J.$eq$(compare.call$2(a[less], el2), 0)) {
                // goto after while
                $async$goto = 51;
                break;
              }
              t4 = t1._paused || t2.get$elapsedMicroseconds() > 24000;
              $async$goto = t4 ? 52 : 53;
              break;
            case 52:
              // then
              t4 = t1.cooperate$0();
              if (!(t4 instanceof A._Future)) {
                t5 = new A._Future($.Zone__current, t3);
                t5._state = 8;
                t5._resultOrListeners = t4;
                t4 = t5;
              }
              $async$goto = 54;
              return A._asyncAwait(t4, $async$_dualPivotQuicksort$1$4);
            case 54:
              // returning from await.
            case 53:
              // join
              ++less;
              // goto while condition
              $async$goto = 50;
              break;
            case 51:
              // after while
            case 55:
              // while condition
              if (!(great >= 0 && great < a.length)) {
                $async$returnValue = A.ioore(a, great);
                // goto return
                $async$goto = 1;
                break;
              }
              if (!J.$eq$(compare.call$2(a[great], el4), 0)) {
                // goto after while
                $async$goto = 56;
                break;
              }
              t4 = t1._paused || t2.get$elapsedMicroseconds() > 24000;
              $async$goto = t4 ? 57 : 58;
              break;
            case 57:
              // then
              t4 = t1.cooperate$0();
              if (!(t4 instanceof A._Future)) {
                t5 = new A._Future($.Zone__current, t3);
                t5._state = 8;
                t5._resultOrListeners = t4;
                t4 = t5;
              }
              $async$goto = 59;
              return A._asyncAwait(t4, $async$_dualPivotQuicksort$1$4);
            case 59:
              // returning from await.
            case 58:
              // join
              --great;
              // goto while condition
              $async$goto = 55;
              break;
            case 56:
              // after while
              k = less;
            case 60:
              // for condition
              if (!(k <= great)) {
                // goto after for
                $async$goto = 62;
                break;
              }
              if (!(k < a.length)) {
                $async$returnValue = A.ioore(a, k);
                // goto return
                $async$goto = 1;
                break;
              }
              ak = a[k];
              comp_pivot1 = compare.call$2(ak, el2);
              t4 = t1._paused || t2.get$elapsedMicroseconds() > 24000;
              $async$goto = t4 ? 63 : 64;
              break;
            case 63:
              // then
              t4 = t1.cooperate$0();
              if (!(t4 instanceof A._Future)) {
                t5 = new A._Future($.Zone__current, t3);
                t5._state = 8;
                t5._resultOrListeners = t4;
                t4 = t5;
              }
              $async$goto = 65;
              return A._asyncAwait(t4, $async$_dualPivotQuicksort$1$4);
            case 65:
              // returning from await.
            case 64:
              // join
              $async$goto = comp_pivot1 === 0 ? 66 : 68;
              break;
            case 66:
              // then
              if (k !== less) {
                t4 = a.length;
                if (!(less < t4)) {
                  $async$returnValue = A.ioore(a, less);
                  // goto return
                  $async$goto = 1;
                  break;
                }
                t5 = a[less];
                if (!(k < t4)) {
                  $async$returnValue = A.ioore(a, k);
                  // goto return
                  $async$goto = 1;
                  break;
                }
                a[k] = t5;
                a[less] = ak;
              }
              ++less;
              // goto join
              $async$goto = 67;
              break;
            case 68:
              // else
              $async$goto = compare.call$2(ak, el4) === 0 ? 69 : 70;
              break;
            case 69:
              // then
            case 71:
              // for condition
              // trivial condition
              if (!(great >= 0 && great < a.length)) {
                $async$returnValue = A.ioore(a, great);
                // goto return
                $async$goto = 1;
                break;
              }
              comp = compare.call$2(a[great], el4);
              t4 = t1._paused || t2.get$elapsedMicroseconds() > 24000;
              $async$goto = t4 ? 73 : 74;
              break;
            case 73:
              // then
              t4 = t1.cooperate$0();
              if (!(t4 instanceof A._Future)) {
                t5 = new A._Future($.Zone__current, t3);
                t5._state = 8;
                t5._resultOrListeners = t4;
                t4 = t5;
              }
              $async$goto = 75;
              return A._asyncAwait(t4, $async$_dualPivotQuicksort$1$4);
            case 75:
              // returning from await.
            case 74:
              // join
              $async$goto = comp === 0 ? 76 : 78;
              break;
            case 76:
              // then
              --great;
              if (great < k) {
                // goto after for
                $async$goto = 72;
                break;
              }
              // goto for condition
              $async$goto = 71;
              break;
              // goto join
              $async$goto = 77;
              break;
            case 78:
              // else
              if (!(great < a.length)) {
                $async$returnValue = A.ioore(a, great);
                // goto return
                $async$goto = 1;
                break;
              }
              comp = compare.call$2(a[great], el2);
              t4 = t1._paused || t2.get$elapsedMicroseconds() > 24000;
              $async$goto = t4 ? 79 : 80;
              break;
            case 79:
              // then
              t4 = t1.cooperate$0();
              if (!(t4 instanceof A._Future)) {
                t5 = new A._Future($.Zone__current, t3);
                t5._state = 8;
                t5._resultOrListeners = t4;
                t4 = t5;
              }
              $async$goto = 81;
              return A._asyncAwait(t4, $async$_dualPivotQuicksort$1$4);
            case 81:
              // returning from await.
            case 80:
              // join
              t4 = a.length;
              great0 = great - 1;
              if (comp < 0) {
                if (!(less < t4)) {
                  $async$returnValue = A.ioore(a, less);
                  // goto return
                  $async$goto = 1;
                  break;
                }
                t5 = a[less];
                if (!(k < t4)) {
                  $async$returnValue = A.ioore(a, k);
                  // goto return
                  $async$goto = 1;
                  break;
                }
                a[k] = t5;
                less0 = less + 1;
                if (!(great < t4)) {
                  $async$returnValue = A.ioore(a, great);
                  // goto return
                  $async$goto = 1;
                  break;
                }
                a[less] = a[great];
                a[great] = ak;
                less = less0;
              } else {
                if (!(great < t4)) {
                  $async$returnValue = A.ioore(a, great);
                  // goto return
                  $async$goto = 1;
                  break;
                }
                t5 = a[great];
                if (!(k < t4)) {
                  $async$returnValue = A.ioore(a, k);
                  // goto return
                  $async$goto = 1;
                  break;
                }
                a[k] = t5;
                a[great] = ak;
              }
              great = great0;
              // goto after for
              $async$goto = 72;
              break;
            case 77:
              // join
              // goto for condition
              $async$goto = 71;
              break;
            case 72:
              // after for
            case 70:
              // join
            case 67:
              // join
            case 61:
              // for update
              ++k;
              // goto for condition
              $async$goto = 60;
              break;
            case 62:
              // after for
              $async$goto = 82;
              return A._asyncAwait($async$self._doSort$1$4(a, less, great, compare, $E), $async$_dualPivotQuicksort$1$4);
            case 82:
              // returning from await.
              // goto join
              $async$goto = 48;
              break;
            case 49:
              // else
              $async$goto = 83;
              return A._asyncAwait($async$self._doSort$1$4(a, less, great, compare, $E), $async$_dualPivotQuicksort$1$4);
            case 83:
              // returning from await.
            case 48:
              // join
            case 1:
              // return
              return A._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return A._asyncStartSync($async$_dualPivotQuicksort$1$4, $async$completer);
    }
  };
  A.SembastSortOrderBase.prototype = {
    compareValueAscending$2(value1, value2) {
      if (value1 == null) {
        if (value2 == null)
          return 0;
        return -1;
      } else if (value2 == null)
        return 1;
      return A.compareValue(value1, value2);
    },
    $isSortOrder: 1
  };
  A.SembastSortOrder.prototype = {
    toString$0(_) {
      var t1 = A.LinkedHashMap_LinkedHashMap$_empty(type$.String, type$.nullable_Object),
        t2 = this.ascending ? "asc" : "desc";
      t1.$indexSet(0, this.field, t2);
      return A.MapBase_mapToString(t1);
    }
  };
  A.StorageBase.prototype = {};
  A.DatabaseStorage.prototype = {
    appendLine$1(line) {
      return this.appendLines$1(A._setArrayType([line], type$.JSArray_String));
    }
  };
  A.SembastStore.prototype = {
    txnPut$5$ifNotExists$merge(txn, value, key, ifNotExists, merge) {
      return this.txnPut$body$SembastStore(txn, value, key, ifNotExists, merge);
    },
    txnPut$body$SembastStore(txn, value, key, ifNotExists, merge) {
      var $async$goto = 0,
        $async$completer = A._makeAsyncAwaitCompleter(type$.nullable_Object),
        $async$returnValue, $async$handler = 2, $async$errorStack = [], $async$next = [], $async$self = this, t1;
      var $async$txnPut$5$ifNotExists$merge = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1) {
          $async$errorStack.push($async$result);
          $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$handler = 3;
              t1 = $async$self.txnPutSync$5$ifNotExists$merge(txn, value, key, ifNotExists, merge);
              $async$returnValue = t1;
              $async$next = [1];
              // goto finally
              $async$goto = 4;
              break;
              $async$next.push(5);
              // goto finally
              $async$goto = 4;
              break;
            case 3:
              // uncaught
              $async$next = [2];
            case 4:
              // finally
              $async$handler = 2;
              $async$goto = 6;
              return A._asyncAwait($async$self.database.txnPostWriteAndCooperate$1(txn), $async$txnPut$5$ifNotExists$merge);
            case 6:
              // returning from await.
              // goto the next finally handler
              $async$goto = $async$next.pop();
              break;
            case 5:
              // after finally
            case 1:
              // return
              return A._asyncReturn($async$returnValue, $async$completer);
            case 2:
              // rethrow
              return A._asyncRethrow($async$errorStack.at(-1), $async$completer);
          }
      });
      return A._asyncStartSync($async$txnPut$5$ifNotExists$merge, $async$completer);
    },
    txnGenerateUniqueIntKey$1(txn) {
      var $async$goto = 0,
        $async$completer = A._makeAsyncAwaitCompleter(type$.int),
        $async$returnValue, $async$self = this, t3, key, t1, t2;
      var $async$txnGenerateUniqueIntKey$1 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return A._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = $async$self.database;
              t2 = $async$self.ref;
            case 3:
              // do body
              t3 = t2.StoreRefMixin___StoreRefMixin_name_A;
              t3 === $ && A.throwLateFieldNI("name");
              $async$goto = 6;
              return A._asyncAwait(t1.generateUniqueIntKey$1(t3), $async$txnGenerateUniqueIntKey$1);
            case 6:
              // returning from await.
              key = $async$result;
              if (key == null)
                key = ++$async$self.lastIntKey;
            case 4:
              // do condition
              $async$goto = 7;
              return A._asyncAwait($async$self.txnRecordExists$2(txn, key), $async$txnGenerateUniqueIntKey$1);
            case 7:
              // returning from await.
              if ($async$result) {
                // goto do body
                $async$goto = 3;
                break;
              }
            case 5:
              // after do
              $async$returnValue = key;
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return A._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return A._asyncStartSync($async$txnGenerateUniqueIntKey$1, $async$completer);
    },
    txnGenerateUniqueStringKey$1(txn) {
      var $async$goto = 0,
        $async$completer = A._makeAsyncAwaitCompleter(type$.String),
        $async$returnValue, $async$self = this, t3, key, t1, t2;
      var $async$txnGenerateUniqueStringKey$1 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return A._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = $async$self.database;
              t2 = $async$self.ref;
            case 3:
              // do body
              t3 = t2.StoreRefMixin___StoreRefMixin_name_A;
              t3 === $ && A.throwLateFieldNI("name");
              $async$goto = 6;
              return A._asyncAwait(t1.generateUniqueStringKey$1(t3), $async$txnGenerateUniqueStringKey$1);
            case 6:
              // returning from await.
              key = $async$result;
              if (key == null)
                key = A.PushIdGenerator_generatePushChildName();
            case 4:
              // do condition
              $async$goto = 7;
              return A._asyncAwait($async$self.txnRecordExists$2(txn, key), $async$txnGenerateUniqueStringKey$1);
            case 7:
              // returning from await.
              if ($async$result) {
                // goto do body
                $async$goto = 3;
                break;
              }
            case 5:
              // after do
              $async$returnValue = key;
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return A._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return A._asyncStartSync($async$txnGenerateUniqueStringKey$1, $async$completer);
    },
    txnGenerateUniqueKey$1$1(txn, $K) {
      return this.txnGenerateUniqueKey$body$SembastStore(txn, $K, $K);
    },
    txnGenerateUniqueKey$body$SembastStore(txn, $K, $async$type) {
      var $async$goto = 0,
        $async$completer = A._makeAsyncAwaitCompleter($async$type),
        $async$returnValue, $async$self = this, intKey, exception, t1, key, $async$temp1, $async$temp2;
      var $async$txnGenerateUniqueKey$1$1 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return A._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              key = A._Cell$named("key");
              $async$goto = A.createRuntimeType($K) === B.Type_String_AXU ? 3 : 5;
              break;
            case 3:
              // then
              $async$temp1 = key;
              $async$temp2 = $K;
              $async$goto = 6;
              return A._asyncAwait($async$self.txnGenerateUniqueStringKey$1(txn), $async$txnGenerateUniqueKey$1$1);
            case 6:
              // returning from await.
              $async$temp1._value = $async$temp2._as($async$result);
              // goto join
              $async$goto = 4;
              break;
            case 5:
              // else
              $async$goto = A.createRuntimeType($K) === B.Type_int_T7V ? 7 : 9;
              break;
            case 7:
              // then
              $async$temp1 = key;
              $async$temp2 = $K;
              $async$goto = 10;
              return A._asyncAwait($async$self.txnGenerateUniqueIntKey$1(txn), $async$txnGenerateUniqueKey$1$1);
            case 10:
              // returning from await.
              $async$temp1._value = $async$temp2._as($async$result);
              // goto join
              $async$goto = 8;
              break;
            case 9:
              // else
              $async$goto = 11;
              return A._asyncAwait($async$self.txnGenerateUniqueIntKey$1(txn), $async$txnGenerateUniqueKey$1$1);
            case 11:
              // returning from await.
              intKey = $async$result;
              try {
                key._value = $K._as(intKey);
              } catch (exception) {
                t1 = A.ArgumentError$("Invalid key type " + A.createRuntimeType($K).toString$0(0) + " for generating a key. You should either use String or int or generate the key yourself.", null);
                throw A.wrapException(t1);
              }
            case 8:
              // join
            case 4:
              // join
              $async$returnValue = key._readLocal$0();
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return A._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return A._asyncStartSync($async$txnGenerateUniqueKey$1$1, $async$completer);
    },
    txnAdd$1$3(txn, value, key, $K) {
      return this.txnAdd$body$SembastStore(txn, value, key, $K, $K._eval$1("0?"));
    },
    txnAdd$body$SembastStore(txn, value, key, $K, $async$type) {
      var $async$goto = 0,
        $async$completer = A._makeAsyncAwaitCompleter($async$type),
        $async$returnValue, $async$handler = 2, $async$errorStack = [], $async$next = [], $async$self = this, t1;
      var $async$txnAdd$1$3 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1) {
          $async$errorStack.push($async$result);
          $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              key = key;
              $async$handler = 3;
              $async$goto = key == null ? 6 : 8;
              break;
            case 6:
              // then
              $async$goto = 9;
              return A._asyncAwait($async$self.txnGenerateUniqueKey$1$1(txn, $K), $async$txnAdd$1$3);
            case 9:
              // returning from await.
              key = $async$result;
              // goto join
              $async$goto = 7;
              break;
            case 8:
              // else
              $async$goto = 10;
              return A._asyncAwait($async$self.txnRecordExists$2(txn, key), $async$txnAdd$1$3);
            case 10:
              // returning from await.
              if ($async$result) {
                $async$returnValue = null;
                $async$next = [1];
                // goto finally
                $async$goto = 4;
                break;
              }
            case 7:
              // join
              t1 = key;
              $async$self.txnPutSync$3(txn, value, t1 == null ? type$.Object._as(t1) : t1);
              t1 = $K._eval$1("0?")._as(key);
              $async$returnValue = t1;
              $async$next = [1];
              // goto finally
              $async$goto = 4;
              break;
              $async$next.push(5);
              // goto finally
              $async$goto = 4;
              break;
            case 3:
              // uncaught
              $async$next = [2];
            case 4:
              // finally
              $async$handler = 2;
              $async$goto = 11;
              return A._asyncAwait($async$self.database.txnPostWriteAndCooperate$1(txn), $async$txnAdd$1$3);
            case 11:
              // returning from await.
              // goto the next finally handler
              $async$goto = $async$next.pop();
              break;
            case 5:
              // after finally
            case 1:
              // return
              return A._asyncReturn($async$returnValue, $async$completer);
            case 2:
              // rethrow
              return A._asyncRethrow($async$errorStack.at(-1), $async$completer);
          }
      });
      return A._asyncStartSync($async$txnAdd$1$3, $async$completer);
    },
    txnPutSync$5$ifNotExists$merge(txn, value, key, ifNotExists, merge) {
      var oldSnapshot, record, _this = this,
        t1 = _this.database,
        t2 = t1.changesListener,
        t3 = _this.ref,
        t4 = t2._changes_listener$_stores,
        t5 = t4.__js_helper$_length,
        hasChangesListener = t5 !== 0 && t4.containsKey$1(t3);
      if (!hasChangesListener)
        t2._hasGlobalChangeListener$1(t3);
      oldSnapshot = hasChangesListener ? _this.txnGetImmutableRecordSync$1$2(txn, key, type$.Object) : null;
      value = A.cloneValue(value);
      t4 = t3.$ti;
      t5 = t4._precomputed1;
      record = _this.txnPutRecordSync$2(txn, A.ImmutableSembastRecord$(A.SembastRecordRef$(t3, t5._as(key), t5, t4._rest[1]), value, false));
      if (t1.logV)
        A.print(txn.toString$0(0) + " put " + record.toString$0(0));
      if (hasChangesListener)
        t2.addChange$2(oldSnapshot, record);
      t1 = A.RecordSnapshotMixin.prototype.get$value.call(record);
      t1 = A.immutableValueOrNull(t1);
      t1.toString;
      return t1;
    },
    txnPutSync$3(txn, value, key) {
      return this.txnPutSync$5$ifNotExists$merge(txn, value, key, null, null);
    },
    get$currentRecords() {
      var t2,
        t1 = this._currentRecordsCache;
      if (t1 == null) {
        t1 = this._recordMap;
        t2 = t1.$ti._eval$1("_SplayTreeValueIterable<1,2>");
        t1 = A.List_List$_of(new A._SplayTreeValueIterable(t1, t2), t2._eval$1("Iterable.E"));
        t1.$flags = 1;
        t1 = this._currentRecordsCache = t1;
      }
      return t1;
    },
    get$txnCurrentRecords() {
      var t2,
        t1 = this.txnRecords;
      if (t1 == null)
        t1 = null;
      else {
        t2 = A._instanceType(t1)._eval$1("LinkedHashMapValuesIterable<2>");
        t2 = A.MappedIterable_MappedIterable(new A.LinkedHashMapValuesIterable(t1, t2), t2._eval$1("ImmutableSembastRecord(Iterable.E)")._as(new A.SembastStore_txnCurrentRecords_closure()), t2._eval$1("Iterable.E"), type$.ImmutableSembastRecord);
        t1 = A.List_List$_of(t2, A._instanceType(t2)._eval$1("Iterable.E"));
        t1.$flags = 1;
        t1 = t1;
      }
      return t1;
    },
    forEachRecords$3(txn, finder, action) {
      return this.forEachRecords$body$SembastStore(txn, finder, type$.bool_Function_ImmutableSembastRecord._as(action));
    },
    forEachRecords$body$SembastStore(txn, finder, action) {
      var $async$goto = 0,
        $async$completer = A._makeAsyncAwaitCompleter(type$.void),
        $async$returnValue, $async$self = this, records, t1, t2, t3, _i, record, t4, t5, t6, t7, finderMatchesRecord;
      var $async$forEachRecords$3 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return A._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              finderMatchesRecord = new A.SembastStore_forEachRecords_finderMatchesRecord();
              $async$goto = $async$self._hasTransactionRecords$1(txn) ? 3 : 4;
              break;
            case 3:
              // then
              records = $async$self.get$txnCurrentRecords();
              t1 = records.length, t2 = $async$self.database.cooperator, t3 = type$._Future_dynamic, _i = 0;
            case 5:
              // for condition
              if (!(_i < records.length)) {
                // goto after for
                $async$goto = 7;
                break;
              }
              record = records[_i];
              t4 = t2 == null;
              if (t4)
                t5 = null;
              else
                t5 = t2._paused || t2._cooperateStopWatch.get$elapsedMicroseconds() > 24000;
              $async$goto = t5 === true ? 8 : 9;
              break;
            case 8:
              // then
              t4 = t4 ? null : t2.cooperate$0();
              if (!(t4 instanceof A._Future)) {
                t5 = new A._Future($.Zone__current, t3);
                t5._state = 8;
                t5._resultOrListeners = t4;
                t4 = t5;
              }
              $async$goto = 10;
              return A._asyncAwait(t4, $async$forEachRecords$3);
            case 10:
              // returning from await.
            case 9:
              // join
              if (finderMatchesRecord.call$2(finder, record))
                if (!action.call$1(record)) {
                  // goto return
                  $async$goto = 1;
                  break;
                }
            case 6:
              // for update
              records.length === t1 || (0, A.throwConcurrentModificationError)(records), ++_i;
              // goto for condition
              $async$goto = 5;
              break;
            case 7:
              // after for
            case 4:
              // join
              records = $async$self.get$currentRecords();
              t1 = records.length, t2 = txn != null, t3 = $async$self.database, t4 = t3.cooperator, t5 = type$._Future_dynamic, _i = 0;
            case 11:
              // for condition
              if (!(_i < records.length)) {
                // goto after for
                $async$goto = 13;
                break;
              }
              record = records[_i];
              t6 = t4 == null;
              if (t6)
                t7 = null;
              else
                t7 = t4._paused || t4._cooperateStopWatch.get$elapsedMicroseconds() > 24000;
              $async$goto = t7 === true ? 14 : 15;
              break;
            case 14:
              // then
              t6 = t6 ? null : t4.cooperate$0();
              if (!(t6 instanceof A._Future)) {
                t7 = new A._Future($.Zone__current, t5);
                t7._state = 8;
                t7._resultOrListeners = t6;
                t6 = t7;
              }
              $async$goto = 16;
              return A._asyncAwait(t6, $async$forEachRecords$3);
            case 16:
              // returning from await.
            case 15:
              // join
              if (t2 && txn === t3._transaction && $async$self.txnRecords != null) {
                t6 = $async$self.txnRecords;
                t6.toString;
                t7 = A.RecordSnapshotMixin.prototype.get$key.call(record);
                if (t6.containsKey$1(t7)) {
                  // goto for update
                  $async$goto = 12;
                  break;
                }
              }
              if (finderMatchesRecord.call$2(finder, record))
                if (!action.call$1(record)) {
                  // goto return
                  $async$goto = 1;
                  break;
                }
            case 12:
              // for update
              records.length === t1 || (0, A.throwConcurrentModificationError)(records), ++_i;
              // goto for condition
              $async$goto = 11;
              break;
            case 13:
              // after for
            case 1:
              // return
              return A._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return A._asyncStartSync($async$forEachRecords$3, $async$completer);
    },
    forEachRecordsSync$3(txn, finder, action) {
      var finderMatchesRecord, records, t1, _i, record, t2, t3, t4, t5, _this = this;
      type$.bool_Function_ImmutableSembastRecord._as(action);
      finderMatchesRecord = new A.SembastStore_forEachRecordsSync_finderMatchesRecord();
      if (_this._hasTransactionRecords$1(txn)) {
        records = _this.get$txnCurrentRecords();
        for (t1 = records.length, _i = 0; _i < records.length; records.length === t1 || (0, A.throwConcurrentModificationError)(records), ++_i) {
          record = records[_i];
          if (finderMatchesRecord.call$2(finder, record))
            if (!action.call$1(record))
              return;
        }
      }
      records = _this.get$currentRecords();
      for (t1 = records.length, t2 = txn != null, t3 = _this.database, _i = 0; _i < records.length; records.length === t1 || (0, A.throwConcurrentModificationError)(records), ++_i) {
        record = records[_i];
        if (t2 && txn === t3._transaction && _this.txnRecords != null) {
          t4 = _this.txnRecords;
          t4.toString;
          t5 = A.RecordSnapshotMixin.prototype.get$key.call(record);
          if (t4.containsKey$1(t5))
            continue;
        }
        if (finderMatchesRecord.call$2(finder, record))
          if (!action.call$1(record))
            return;
      }
    },
    txnFindKey$2(txn, finder) {
      var $async$goto = 0,
        $async$completer = A._makeAsyncAwaitCompleter(type$.nullable_Object),
        $async$returnValue, $async$self = this, t1;
      var $async$txnFindKey$2 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return A._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$goto = 3;
              return A._asyncAwait($async$self.txnFindRecord$2(txn, finder), $async$txnFindKey$2);
            case 3:
              // returning from await.
              t1 = $async$result;
              if (t1 == null)
                t1 = null;
              else
                t1 = A.RecordSnapshotMixin.prototype.get$key.call(t1);
              $async$returnValue = t1;
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return A._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return A._asyncStartSync($async$txnFindKey$2, $async$completer);
    },
    txnFindRecord$2(txn, finder) {
      var $async$goto = 0,
        $async$completer = A._makeAsyncAwaitCompleter(type$.nullable_ImmutableSembastRecord),
        $async$returnValue, $async$self = this, t1, t2, t3, records, sembastFinder;
      var $async$txnFindRecord$2 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return A._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              sembastFinder = A._Cell$named("sembastFinder");
              sembastFinder._value = finder;
              if (sembastFinder._readLocal$0().limit !== 1) {
                t1 = sembastFinder._readLocal$0();
                t2 = t1.filter;
                t3 = t1.sortOrders;
                sembastFinder._value = new A.SembastFinder(t2, t1.offset, 1, t1.start, t1.end, t3);
              }
              $async$goto = 3;
              return A._asyncAwait($async$self.txnFindRecords$2(txn, sembastFinder._readLocal$0()), $async$txnFindRecord$2);
            case 3:
              // returning from await.
              records = $async$result;
              t1 = J.getInterceptor$asx(records);
              if (t1.get$isNotEmpty(records)) {
                $async$returnValue = t1.get$first(records);
                // goto return
                $async$goto = 1;
                break;
              }
              $async$returnValue = null;
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return A._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return A._asyncStartSync($async$txnFindRecord$2, $async$completer);
    },
    txnFindRecords$2(txn, finder) {
      var $async$goto = 0,
        $async$completer = A._makeAsyncAwaitCompleter(type$.List_ImmutableSembastRecord),
        $async$returnValue, $async$self = this, finderData, results, t1, t2;
      var $async$txnFindRecords$2 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return A._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = $async$self.database.cooperator;
              t2 = t1 != null || null;
              if (t2 !== true) {
                $async$returnValue = $async$self.txnFindRecordsSync$2(txn, finder);
                // goto return
                $async$goto = 1;
                break;
              }
              finderData = A._FinderData$(finder);
              $async$goto = 3;
              return A._asyncAwait($async$self.forEachRecords$3(txn, finder, finderData.get$addRecord()), $async$txnFindRecords$2);
            case 3:
              // returning from await.
              results = finderData.get$addedResults();
              $async$goto = finderData.get$hasSortOrder() ? 4 : 5;
              break;
            case 4:
              // then
              t1.toString;
              type$.List_ImmutableSembastRecord._as(results);
              t2 = type$.int_Function_ImmutableSembastRecord_ImmutableSembastRecord._as(new A.SembastStore_txnFindRecords_closure(finder));
              $async$goto = 6;
              return A._asyncAwait(new A.Sort(t1)._doSort$1$4(results, 0, results.length - 1, t2, type$.ImmutableSembastRecord), $async$txnFindRecords$2);
            case 6:
              // returning from await.
              results = A.recordsLimit(results, finder);
            case 5:
              // join
              $async$returnValue = results;
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return A._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return A._asyncStartSync($async$txnFindRecords$2, $async$completer);
    },
    txnFindRecordsSync$2(txn, finder) {
      var results,
        finderData = A._FinderData$(finder);
      this.forEachRecordsSync$3(txn, finder, finderData.get$addRecord());
      results = finderData.get$addedResults();
      if (finderData.get$hasSortOrder()) {
        B.JSArray_methods.sort$1(results, new A.SembastStore_txnFindRecordsSync_closure(finder));
        results = A.recordsLimit(results, finder);
      }
      return results;
    },
    txnFindKeys$2(txn, finder) {
      var $async$goto = 0,
        $async$completer = A._makeAsyncAwaitCompleter(type$.List_nullable_Object),
        $async$returnValue, $async$self = this, t1, $async$temp1;
      var $async$txnFindKeys$2 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return A._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$temp1 = J;
              $async$goto = 3;
              return A._asyncAwait($async$self.txnFindRecords$2(txn, finder), $async$txnFindKeys$2);
            case 3:
              // returning from await.
              t1 = $async$temp1.map$1$1$ax($async$result, new A.SembastStore_txnFindKeys_closure(), type$.nullable_Object);
              t1 = A.List_List$_of(t1, t1.$ti._eval$1("ListIterable.E"));
              $async$returnValue = t1;
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return A._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return A._asyncStartSync($async$txnFindKeys$2, $async$completer);
    },
    setRecordInMemory$1(record) {
      var t3,
        t1 = this._recordMap,
        t2 = A.RecordSnapshotMixin.prototype.get$key.call(record);
      t2 = t1.$index(0, t2);
      if (record.SembastRecordMixin__deleted === true) {
        t3 = A.RecordSnapshotMixin.prototype.get$key.call(record);
        t1.remove$1(0, t3);
      } else {
        t3 = A.RecordSnapshotMixin.prototype.get$key.call(record);
        t1.$indexSet(0, t3, record);
      }
      this._currentRecordsCache = null;
      return t2 != null;
    },
    txnPutRecord$2(txn, record) {
      return this.txnPutRecord$body$SembastStore(txn, record);
    },
    txnPutRecord$body$SembastStore(txn, record) {
      var $async$goto = 0,
        $async$completer = A._makeAsyncAwaitCompleter(type$.ImmutableSembastRecord),
        $async$returnValue, $async$self = this, t1;
      var $async$txnPutRecord$2 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return A._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = $async$self.database;
              $async$goto = A.cooperateNeeded(t1.cooperator) ? 3 : 4;
              break;
            case 3:
              // then
              t1 = t1.cooperate$0();
              $async$goto = 5;
              return A._asyncAwait(t1 instanceof A._Future ? t1 : A._Future$value(t1, type$.dynamic), $async$txnPutRecord$2);
            case 5:
              // returning from await.
            case 4:
              // join
              $async$returnValue = $async$self.txnPutRecordSync$2(txn, record);
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return A._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return A._asyncStartSync($async$txnPutRecord$2, $async$completer);
    },
    txnPutRecordSync$2(txn, record) {
      var t2, t3, _this = this,
        t1 = A.RecordSnapshotMixin.prototype.get$key.call(record);
      if (A._isInt(t1))
        if (t1 > _this.lastIntKey)
          _this.lastIntKey = t1;
      t1 = _this.database;
      t1.checkTransaction$1(txn);
      t2 = _this.txnRecords;
      if (t2 == null)
        t2 = _this.txnRecords = A.LinkedHashMap_LinkedHashMap$_empty(type$.Object, type$.TxnRecord);
      t3 = A.RecordSnapshotMixin.prototype.get$key.call(record);
      t2.$indexSet(0, t3, new A.TxnRecord(record));
      t2 = record.RecordSnapshotMixin___RecordSnapshotMixin_ref_A;
      t2 === $ && A.throwLateFieldNI("ref");
      t2 = t2.RecordRefMixin___RecordRefMixin_store_A;
      t2 === $ && A.throwLateFieldNI("store");
      t2 = t2.StoreRefMixin___StoreRefMixin_name_A;
      t2 === $ && A.throwLateFieldNI("name");
      B.JSArray_methods.remove$1(t1._txnDroppedStores, t2);
      return record;
    },
    txnGetRawImmutableRecordSync$1$2(txn, key, $K) {
      var t1, t2, record, _this = this;
      $K._as(key);
      t1 = _this.database;
      t1.checkTransaction$1(txn);
      if (_this._hasTransactionRecords$1(txn)) {
        t2 = _this.txnRecords.$index(0, key);
        record = t2 == null ? null : t2.record;
      } else
        record = null;
      if (record == null)
        record = _this._recordMap.$index(0, key);
      if (t1.logV)
        A.print(A.S(t1._transaction) + " get " + A.S(record) + " key " + A.S(key));
      return record;
    },
    txnGetImmutableRecord$2(txn, key) {
      return this.txnGetImmutableRecord$body$SembastStore(txn, key);
    },
    txnGetImmutableRecord$body$SembastStore(txn, key) {
      var $async$goto = 0,
        $async$completer = A._makeAsyncAwaitCompleter(type$.nullable_ImmutableSembastRecord),
        $async$returnValue, $async$self = this, record, t1;
      var $async$txnGetImmutableRecord$2 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return A._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              record = $async$self.txnGetImmutableRecordSync$1$2(txn, key, type$.Object);
              t1 = $async$self.database;
              $async$goto = A.cooperateNeeded(t1.cooperator) ? 3 : 4;
              break;
            case 3:
              // then
              t1 = t1.cooperate$0();
              $async$goto = 5;
              return A._asyncAwait(t1 instanceof A._Future ? t1 : A._Future$value(t1, type$.dynamic), $async$txnGetImmutableRecord$2);
            case 5:
              // returning from await.
            case 4:
              // join
              $async$returnValue = record;
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return A._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return A._asyncStartSync($async$txnGetImmutableRecord$2, $async$completer);
    },
    txnRecordExists$2(txn, key) {
      return this.txnRecordExists$body$SembastStore(txn, key);
    },
    txnRecordExists$body$SembastStore(txn, key) {
      var $async$goto = 0,
        $async$completer = A._makeAsyncAwaitCompleter(type$.bool),
        $async$returnValue, $async$self = this, record, t1, t2;
      var $async$txnRecordExists$2 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return A._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              record = $async$self.txnGetRawImmutableRecordSync$1$2(txn, key, type$.Object);
              t1 = record == null ? null : record.SembastRecordMixin__deleted === true;
              t2 = $async$self.database;
              $async$goto = A.cooperateNeeded(t2.cooperator) ? 3 : 4;
              break;
            case 3:
              // then
              t2 = t2.cooperate$0();
              $async$goto = 5;
              return A._asyncAwait(t2 instanceof A._Future ? t2 : A._Future$value(t2, type$.dynamic), $async$txnRecordExists$2);
            case 5:
              // returning from await.
            case 4:
              // join
              $async$returnValue = t1 === false;
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return A._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return A._asyncStartSync($async$txnRecordExists$2, $async$completer);
    },
    txnGetImmutableRecordSync$1$2(txn, key, $K) {
      var record = this.txnGetRawImmutableRecordSync$1$2(txn, $K._as(key), $K);
      if (record == null || record.SembastRecordMixin__deleted === true)
        return null;
      return record;
    },
    txnGetImmutableRecords$1$2(txn, refs, $K) {
      return this.txnGetImmutableRecords$body$SembastStore(txn, $K._eval$1("RecordsRef<0,Object?>")._as(refs), $K);
    },
    txnGetImmutableRecords$body$SembastStore(txn, refs, $K) {
      var $async$goto = 0,
        $async$completer = A._makeAsyncAwaitCompleter(type$.List_nullable_ImmutableSembastRecord),
        $async$returnValue, $async$self = this, t2, _i, list, t1, $async$temp1, $async$temp2;
      var $async$txnGetImmutableRecords$1$2 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return A._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              list = A._setArrayType([], type$.JSArray_nullable_ImmutableSembastRecord);
              t1 = refs.RecordsRefMixin___RecordsRefMixin_keys_A;
              t1 === $ && A.throwLateFieldNI("keys");
              t2 = t1.length;
              _i = 0;
            case 3:
              // for condition
              if (!(_i < t1.length)) {
                // goto after for
                $async$goto = 5;
                break;
              }
              $async$temp1 = B.JSArray_methods;
              $async$temp2 = list;
              $async$goto = 6;
              return A._asyncAwait($async$self.txnGetImmutableRecord$2(txn, t1[_i]), $async$txnGetImmutableRecords$1$2);
            case 6:
              // returning from await.
              $async$temp1.add$1($async$temp2, $async$result);
            case 4:
              // for update
              t1.length === t2 || (0, A.throwConcurrentModificationError)(t1), ++_i;
              // goto for condition
              $async$goto = 3;
              break;
            case 5:
              // after for
              $async$returnValue = list;
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return A._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return A._asyncStartSync($async$txnGetImmutableRecords$1$2, $async$completer);
    },
    txnDelete$2(txn, key) {
      return this.txnDelete$body$SembastStore(txn, key);
    },
    txnDelete$body$SembastStore(txn, key) {
      var $async$goto = 0,
        $async$completer = A._makeAsyncAwaitCompleter(type$.nullable_Object),
        $async$returnValue, $async$handler = 2, $async$errorStack = [], $async$next = [], $async$self = this, t1;
      var $async$txnDelete$2 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1) {
          $async$errorStack.push($async$result);
          $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$handler = 3;
              t1 = $async$self.txnDeleteSync$2(txn, key);
              $async$returnValue = t1;
              $async$next = [1];
              // goto finally
              $async$goto = 4;
              break;
              $async$next.push(5);
              // goto finally
              $async$goto = 4;
              break;
            case 3:
              // uncaught
              $async$next = [2];
            case 4:
              // finally
              $async$handler = 2;
              $async$goto = 6;
              return A._asyncAwait($async$self.database.txnPostWriteAndCooperate$1(txn), $async$txnDelete$2);
            case 6:
              // returning from await.
              // goto the next finally handler
              $async$goto = $async$next.pop();
              break;
            case 5:
              // after finally
            case 1:
              // return
              return A._asyncReturn($async$returnValue, $async$completer);
            case 2:
              // rethrow
              return A._asyncRethrow($async$errorStack.at(-1), $async$completer);
          }
      });
      return A._asyncStartSync($async$txnDelete$2, $async$completer);
    },
    txnDeleteSync$2(txn, key) {
      var t1, t2, t3, t4, _this = this,
        record = _this.txnGetRawImmutableRecordSync$1$2(txn, key, type$.Object);
      if (record == null)
        return null;
      else {
        _this.txnPutRecordSync$2(txn, A.ImmutableSembastRecord$noValue(record.get$ref(), true));
        t1 = _this.database.changesListener;
        t2 = _this.ref;
        t3 = t1._changes_listener$_stores;
        t4 = t3.__js_helper$_length;
        t3 = t4 !== 0 && t3.containsKey$1(t2);
        if (!t3)
          t1._hasGlobalChangeListener$1(t2);
        if (t3)
          t1.addChange$2(record, null);
        t1 = A.RecordSnapshotMixin.prototype.get$key.call(record);
        return t1;
      }
    },
    txnDeleteAll$2(txn, keys) {
      return this.txnDeleteAll$body$SembastStore(txn, keys);
    },
    txnDeleteAll$body$SembastStore(txn, keys) {
      var $async$goto = 0,
        $async$completer = A._makeAsyncAwaitCompleter(type$.List_dynamic),
        $async$returnValue, $async$handler = 2, $async$errorStack = [], $async$next = [], $async$self = this, deletedKeys, updates, key, record, clone, t1, t2, t3, t4, t5, t6, t7, t8, _i, t9, t10, clone0;
      var $async$txnDeleteAll$2 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1) {
          $async$errorStack.push($async$result);
          $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              keys = keys;
              deletedKeys = [];
              $async$handler = 3;
              updates = A._setArrayType([], type$.JSArray_ImmutableSembastRecord);
              keys = A.List_List$from(keys, false, type$.nullable_Object);
              t1 = keys, t2 = t1.length, t3 = type$.Object, t4 = type$._Future_dynamic, t5 = $async$self.database, t6 = t5.cooperator, t7 = txn.sembastDatabase.changesListener, t8 = type$.ImmutableSembastRecord._eval$1("RecordRef<RecordSnapshotMixin.K,RecordSnapshotMixin.V>"), _i = 0;
            case 6:
              // for condition
              if (!(_i < t1.length)) {
                // goto after for
                $async$goto = 8;
                break;
              }
              key = t1[_i];
              t9 = t6 == null ? null : t6.cooperate$0();
              if (!(t9 instanceof A._Future)) {
                t10 = new A._Future($.Zone__current, t4);
                t10._state = 8;
                t10._resultOrListeners = t9;
                t9 = t10;
              }
              $async$goto = 9;
              return A._asyncAwait(t9, $async$txnDeleteAll$2);
            case 9:
              // returning from await.
              t9 = key;
              record = $async$self.txnGetRawImmutableRecordSync$1$2(txn, t9 == null ? t3._as(t9) : t9, t3);
              if (record != null && record.SembastRecordMixin__deleted !== true) {
                clone0 = new A.ImmutableSembastRecord(null, $, $, null);
                clone0.RecordSnapshotMixin___RecordSnapshotMixin_ref_A = t8._as(record.get$ref());
                clone0.SembastRecordMixin__deleted = true;
                clone0.RecordSnapshotMixin_revision = $.ImmutableSembastRecord__lastRevision = $.ImmutableSembastRecord__lastRevision + 1;
                clone = clone0;
                J.add$1$ax(updates, clone);
                t9 = t7._changes_listener$_stores.__js_helper$_length;
                if (t9 !== 0)
                  t7.addChange$2(record, null);
                J.add$1$ax(deletedKeys, key);
              } else
                J.add$1$ax(deletedKeys, null);
            case 7:
              // for update
              t1.length === t2 || (0, A.throwConcurrentModificationError)(t1), ++_i;
              // goto for condition
              $async$goto = 6;
              break;
            case 8:
              // after for
              $async$goto = J.get$length$asx(updates) !== 0 ? 10 : 11;
              break;
            case 10:
              // then
              $async$goto = 12;
              return A._asyncAwait(t5.txnPutRecords$2(txn, updates), $async$txnDeleteAll$2);
            case 12:
              // returning from await.
            case 11:
              // join
              $async$next.push(5);
              // goto finally
              $async$goto = 4;
              break;
            case 3:
              // uncaught
              $async$next = [2];
            case 4:
              // finally
              $async$handler = 2;
              $async$goto = 13;
              return A._asyncAwait($async$self.database.txnPostWriteAndCooperate$1(txn), $async$txnDeleteAll$2);
            case 13:
              // returning from await.
              // goto the next finally handler
              $async$goto = $async$next.pop();
              break;
            case 5:
              // after finally
              $async$returnValue = deletedKeys;
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return A._asyncReturn($async$returnValue, $async$completer);
            case 2:
              // rethrow
              return A._asyncRethrow($async$errorStack.at(-1), $async$completer);
          }
      });
      return A._asyncStartSync($async$txnDeleteAll$2, $async$completer);
    },
    _hasTransactionRecords$1(txn) {
      return txn != null && txn === this.database._transaction && this.txnRecords != null;
    },
    toJson$0() {
      var map = A.LinkedHashMap_LinkedHashMap$_empty(type$.String, type$.nullable_Object),
        t1 = this.ref.StoreRefMixin___StoreRefMixin_name_A;
      t1 === $ && A.throwLateFieldNI("name");
      map.$indexSet(0, "name", t1);
      map.$indexSet(0, "count", this._recordMap._count);
      return map;
    },
    toString$0(_) {
      var t1 = this.ref.StoreRefMixin___StoreRefMixin_name_A;
      t1 === $ && A.throwLateFieldNI("name");
      return t1;
    },
    txnClear$2$finder(txn, finder) {
      return this.txnClear$body$SembastStore(txn, finder);
    },
    txnClear$1(txn) {
      return this.txnClear$2$finder(txn, null);
    },
    txnClear$body$SembastStore(txn, finder) {
      var $async$goto = 0,
        $async$completer = A._makeAsyncAwaitCompleter(type$.List_nullable_Object),
        $async$returnValue, $async$self = this, deletedKeys, t1, $async$temp1, $async$temp2;
      var $async$txnClear$2$finder = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return A._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$goto = finder == null ? 3 : 5;
              break;
            case 3:
              // then
              deletedKeys = [];
              $async$goto = $async$self._hasTransactionRecords$1(txn) ? 6 : 7;
              break;
            case 6:
              // then
              t1 = $async$self.txnRecords;
              t1.toString;
              $async$temp1 = B.JSArray_methods;
              $async$temp2 = deletedKeys;
              $async$goto = 8;
              return A._asyncAwait($async$self.txnDeleteAll$2(txn, A.List_List$from(new A.LinkedHashMapKeysIterable(t1, A._instanceType(t1)._eval$1("LinkedHashMapKeysIterable<1>")), false, type$.nullable_Object)), $async$txnClear$2$finder);
            case 8:
              // returning from await.
              $async$temp1.addAll$1($async$temp2, $async$result);
            case 7:
              // join
              t1 = $async$self._recordMap;
              $async$temp1 = B.JSArray_methods;
              $async$temp2 = deletedKeys;
              $async$goto = 9;
              return A._asyncAwait($async$self.txnDeleteAll$2(txn, A.List_List$from(new A._SplayTreeKeyIterable(t1, t1.$ti._eval$1("_SplayTreeKeyIterable<1,_SplayTreeMapNode<1,2>>")), false, type$.nullable_Object)), $async$txnClear$2$finder);
            case 9:
              // returning from await.
              $async$temp1.addAll$1($async$temp2, $async$result);
              $async$returnValue = deletedKeys;
              // goto return
              $async$goto = 1;
              break;
              // goto join
              $async$goto = 4;
              break;
            case 5:
              // else
              $async$temp1 = txn;
              $async$temp2 = A;
              $async$goto = 11;
              return A._asyncAwait($async$self.txnFindKeys$2(txn, finder), $async$txnClear$2$finder);
            case 11:
              // returning from await.
              $async$goto = 10;
              return A._asyncAwait($async$self.txnDeleteAll$2($async$temp1, $async$temp2.List_List$from($async$result, false, type$.nullable_Object)), $async$txnClear$2$finder);
            case 10:
              // returning from await.
              $async$returnValue = $async$result;
              // goto return
              $async$goto = 1;
              break;
            case 4:
              // join
            case 1:
              // return
              return A._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return A._asyncStartSync($async$txnClear$2$finder, $async$completer);
    }
  };
  A.SembastStore_txnCurrentRecords_closure.prototype = {
    call$1(txnRecord) {
      return type$.TxnRecord._as(txnRecord).record;
    },
    $signature: 22
  };
  A.SembastStore_forEachRecords_finderMatchesRecord.prototype = {
    call$2(finder, record) {
      if (record.SembastRecordMixin__deleted === true)
        return false;
      return A.finderMatchesFilterAndBoundaries(finder, record);
    },
    $signature: 23
  };
  A.SembastStore_forEachRecordsSync_finderMatchesRecord.prototype = {
    call$2(finder, record) {
      if (record.SembastRecordMixin__deleted === true)
        return false;
      return A.finderMatchesFilterAndBoundaries(finder, record);
    },
    $signature: 23
  };
  A.SembastStore_txnFindRecords_closure.prototype = {
    call$2(record1, record2) {
      var t1 = type$.SembastRecord;
      return this.finder.compareThenKey$2(t1._as(record1), t1._as(record2));
    },
    $signature: 68
  };
  A.SembastStore_txnFindRecordsSync_closure.prototype = {
    call$2(record1, record2) {
      var t1 = type$.ImmutableSembastRecord;
      return this.finder.compareThenKey$2(t1._as(record1), t1._as(record2));
    },
    $signature: 69
  };
  A.SembastStore_txnFindKeys_closure.prototype = {
    call$1(record) {
      return type$.SembastRecord._as(record).get$key();
    },
    $signature: 70
  };
  A._FinderData.prototype = {
    get$hasSortOrder() {
      var t1,
        value = this.___FinderData_hasSortOrder_AI;
      if (value === $) {
        t1 = this.sembastFinder.sortOrders;
        t1 = t1 == null ? null : t1.length !== 0;
        value = this.___FinderData_hasSortOrder_AI = t1 === true;
      }
      return value;
    },
    get$usePreordered() {
      var value = this.___FinderData_usePreordered_AI;
      return value === $ ? this.___FinderData_usePreordered_AI = !this.get$hasSortOrder() : value;
    },
    get$addedResults() {
      var t1, t2;
      if (this.get$usePreordered()) {
        t1 = this.___FinderData_preOrderedResults_A;
        t1 === $ && A.throwLateFieldNI("preOrderedResults");
        t2 = t1.$ti._eval$1("_SplayTreeValueIterable<1,2>");
        t1 = A.List_List$_of(new A._SplayTreeValueIterable(t1, t2), t2._eval$1("Iterable.E"));
        t1.$flags = 1;
        return t1;
      } else {
        t1 = this.___FinderData_results_A;
        t1 === $ && A.throwLateFieldNI("results");
        return t1;
      }
    },
    addRecord$1(record) {
      var t1, t2, t3, _this = this,
        _s17_ = "preOrderedResults";
      if (_this.get$usePreordered()) {
        t1 = _this.sembastFinder.limit;
        if (t1 != null) {
          t2 = _this.___FinderData_preOrderedResults_A;
          t2 === $ && A.throwLateFieldNI(_s17_);
          t3 = t2._count;
          t1.toString;
          if (t3 >= t1 - 1) {
            t1 = A.RecordSnapshotMixin.prototype.get$key.call(record);
            t2.$indexSet(0, t1, record);
            return false;
          }
        }
        t1 = _this.___FinderData_preOrderedResults_A;
        t1 === $ && A.throwLateFieldNI(_s17_);
        t2 = A.RecordSnapshotMixin.prototype.get$key.call(record);
        t1.$indexSet(0, t2, record);
      } else {
        t1 = _this.___FinderData_results_A;
        t1 === $ && A.throwLateFieldNI("results");
        B.JSArray_methods.add$1(t1, record);
      }
      return true;
    }
  };
  A.SembastStoreRef.prototype = {$isStoreRef: 1};
  A.StoreRefMixin.prototype = {
    toString$0(_) {
      var t1 = this.StoreRefMixin___StoreRefMixin_name_A;
      t1 === $ && A.throwLateFieldNI("name");
      return "Store(" + t1 + ")";
    },
    get$hashCode(_) {
      var t1 = this.StoreRefMixin___StoreRefMixin_name_A;
      t1 === $ && A.throwLateFieldNI("name");
      return B.JSString_methods.get$hashCode(t1);
    },
    $eq(_, other) {
      var t1, t2;
      if (other == null)
        return false;
      if (other instanceof A.SembastStoreRef) {
        t1 = other.StoreRefMixin___StoreRefMixin_name_A;
        t1 === $ && A.throwLateFieldNI("name");
        t2 = this.StoreRefMixin___StoreRefMixin_name_A;
        t2 === $ && A.throwLateFieldNI("name");
        return t1 === t2;
      }
      return false;
    }
  };
  A.SembastStoreRefExtensionPrv_immutableRecordIterableToSnapshots_closure.prototype = {
    call$1(immutable) {
      return A.SembastRecordSnapshot$fromRecord(this._this, type$.ImmutableSembastRecord._as(immutable), this.K, this.V);
    },
    $signature() {
      return this.K._eval$1("@<0>")._bind$1(this.V)._eval$1("SembastRecordSnapshot<1,2>(ImmutableSembastRecord)");
    }
  };
  A.SembastStoreRefExtension_drop_closure.prototype = {
    call$1(txn) {
      var t1 = this.client.get$sembastDatabase(),
        t2 = this._this.StoreRefMixin___StoreRefMixin_name_A;
      t2 === $ && A.throwLateFieldNI("name");
      return t1.txnDeleteStore$2(txn, t2);
    },
    $signature: 72
  };
  A.SembastStoreRefExtension_generateIntKey_closure.prototype = {
    call$1(txn) {
      return this.client.getSembastStore$1(this._this).txnGenerateUniqueIntKey$1(txn);
    },
    $signature: 24
  };
  A.SembastStoreRefExtension_delete_closure.prototype = {
    call$1(txn) {
      return this.$call$body$SembastStoreRefExtension_delete_closure(txn);
    },
    $call$body$SembastStoreRefExtension_delete_closure(txn) {
      var $async$goto = 0,
        $async$completer = A._makeAsyncAwaitCompleter(type$.int),
        $async$returnValue, $async$self = this, $async$temp1;
      var $async$call$1 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return A._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$temp1 = J;
              $async$goto = 3;
              return A._asyncAwait($async$self.client.getSembastStore$1($async$self._this).txnClear$2$finder(txn, $async$self.finder), $async$call$1);
            case 3:
              // returning from await.
              $async$returnValue = $async$temp1.get$length$asx($async$result);
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return A._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return A._asyncStartSync($async$call$1, $async$completer);
    },
    $signature: 24
  };
  A.StoreFactoryMixin.prototype = {
    store$1($name) {
      var t1 = this.$ti;
      t1 = A.SembastStoreRef$($name, t1._precomputed1, t1._rest[1]);
      return t1;
    }
  };
  A.StoreFactoryBase.prototype = {};
  A._SembastStoreRef_Object_StoreRefMixin.prototype = {};
  A._StoreFactoryBase_Object_StoreFactoryMixin.prototype = {};
  A.Timestamp.prototype = {
    $eq(_, other) {
      if (other == null)
        return false;
      if (this === other)
        return true;
      if (other instanceof A.Timestamp)
        return this.seconds === other.seconds && this.nanoseconds === other.nanoseconds;
      return false;
    },
    get$hashCode(_) {
      return this.seconds * 17 + this.nanoseconds;
    },
    get$microsecondsSinceEpoch() {
      return this.seconds * 1000000 + B.JSInt_methods._tdivFast$1(this.nanoseconds, 1000);
    },
    toDateTime$1$isUtc(isUtc) {
      var t1 = this.seconds * 1000000 + B.JSInt_methods._tdivFast$1(this.nanoseconds, 1000),
        t2 = B.JSInt_methods.$mod(t1, 1000);
      t1 = B.JSInt_methods._tdivFast$1(t1 - t2, 1000);
      if (t1 < -864e13 || t1 > 864e13)
        A.throwExpression(A.RangeError$range(t1, -864e13, 864e13, "millisecondsSinceEpoch", null));
      if (t1 === 864e13 && t2 !== 0)
        A.throwExpression(A.ArgumentError$value(t2, "microsecond", string$.Time_i));
      A.checkNotNullable(true, "isUtc", type$.bool);
      return new A.DateTime(t1, t2, true);
    },
    toIso8601String$0() {
      var text = A.DateTime$fromMicrosecondsSinceEpoch(A.Timestamp$(this.seconds, 0).get$microsecondsSinceEpoch(), true).toIso8601String$0();
      return B.JSString_methods.substring$2(text, 0, B.JSString_methods.lastIndexOf$1(text, ".") + 1) + A.Timestamp__formatNanos(this.nanoseconds) + "Z";
    },
    toString$0(_) {
      return "Timestamp(" + this.toIso8601String$0() + ")";
    },
    compareTo$1(_, other) {
      var t1, t2;
      type$.Timestamp._as(other);
      t1 = this.seconds;
      t2 = other.seconds;
      if (t1 !== t2)
        return t1 - t2;
      return this.nanoseconds - other.nanoseconds;
    },
    $isComparable: 1
  };
  A.SembastTransaction.prototype = {
    toString$0(_) {
      var t1 = (this.completer.future._state & 30) !== 0 ? " completed" : "";
      return "txn " + this._id + t1;
    },
    inTransaction$1$1(action, $T) {
      return this.inTransaction$body$SembastTransaction($T._eval$1("0/(SembastTransaction)")._as(action), $T, $T);
    },
    inTransaction$body$SembastTransaction(action, $T, $async$type) {
      var $async$goto = 0,
        $async$completer = A._makeAsyncAwaitCompleter($async$type),
        $async$returnValue, $async$self = this;
      var $async$inTransaction$1$1 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return A._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$returnValue = action.call$1($async$self);
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return A._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return A._asyncStartSync($async$inTransaction$1$1, $async$completer);
    },
    get$sembastTransaction() {
      return this;
    },
    getSembastStore$1(ref) {
      var t2, store,
        t1 = ref.StoreRefMixin___StoreRefMixin_name_A;
      t1 === $ && A.throwLateFieldNI("name");
      t2 = type$.nullable_Object;
      store = this.sembastDatabase.getSembastStore$1(A.SembastStoreRef$(t1, t2, t2));
      return new A.SembastTransactionStore(store).store;
    },
    $isDatabaseClient: 1,
    $isTransaction: 1,
    get$sembastDatabase() {
      return this.sembastDatabase;
    }
  };
  A.SembastTransactionStore.prototype = {
    toString$0(_) {
      return this.store.toString$0(0);
    }
  };
  A._Converter.prototype = {
    convert$1(input) {
      return this._convert.call$1(this.$ti._precomputed1._as(input));
    }
  };
  A._TimestampAdapter.prototype = {
    _TimestampAdapter$0() {
      var t1 = A._instanceType(this);
      this._TypeAdapterCodecMixin____TypeAdapterCodecMixin_encoder_A = t1._eval$1("Converter<_TypeAdapterCodecMixin.S,_TypeAdapterCodecMixin.T>")._as(new A._Converter(new A._TimestampAdapter_closure(), type$._Converter_Timestamp_String));
      this._TypeAdapterCodecMixin____TypeAdapterCodecMixin_decoder_A = t1._eval$1("Converter<_TypeAdapterCodecMixin.T,_TypeAdapterCodecMixin.S>")._as(new A._Converter(new A._TimestampAdapter_closure0(), type$._Converter_String_Timestamp));
    },
    get$name() {
      return "Timestamp";
    }
  };
  A._TimestampAdapter_closure.prototype = {
    call$1(timestamp) {
      return type$.Timestamp._as(timestamp).toIso8601String$0();
    },
    $signature: 74
  };
  A._TimestampAdapter_closure0.prototype = {
    call$1(text) {
      var timestamp;
      A._asString(text);
      timestamp = A.Timestamp_tryParse(text);
      if (timestamp == null)
        A.throwExpression(A.FormatException$("timestamp " + text, null, null));
      return timestamp;
    },
    $signature: 75
  };
  A._BlobAdapter.prototype = {
    _BlobAdapter$0() {
      var t1 = A._instanceType(this);
      this._TypeAdapterCodecMixin____TypeAdapterCodecMixin_encoder_A = t1._eval$1("Converter<_TypeAdapterCodecMixin.S,_TypeAdapterCodecMixin.T>")._as(new A._Converter(new A._BlobAdapter_closure(), type$._Converter_Blob_String));
      this._TypeAdapterCodecMixin____TypeAdapterCodecMixin_decoder_A = t1._eval$1("Converter<_TypeAdapterCodecMixin.T,_TypeAdapterCodecMixin.S>")._as(new A._Converter(new A._BlobAdapter_closure0(), type$._Converter_String_Blob));
    },
    get$name() {
      return "Blob";
    }
  };
  A._BlobAdapter_closure.prototype = {
    call$1(blob) {
      var t1 = type$.Base64Codec._eval$1("Codec.S")._as(type$.Blob._as(blob).bytes);
      return B.C_Base64Codec.get$encoder().convert$1(t1);
    },
    $signature: 76
  };
  A._BlobAdapter_closure0.prototype = {
    call$1(text) {
      return new A.Blob(B.C_Base64Decoder.convert$1(A._asString(text)));
    },
    $signature: 77
  };
  A.SembastTypeAdapter.prototype = {};
  A._TypeAdapterCodecMixin.prototype = {
    isType$1(value) {
      return A._instanceType(this)._eval$1("_TypeAdapterCodecMixin.S")._is(value);
    },
    get$encoder() {
      var t1 = this._TypeAdapterCodecMixin____TypeAdapterCodecMixin_encoder_A;
      t1 === $ && A.throwLateFieldNI("encoder");
      return t1;
    },
    toString$0(_) {
      return "TypeAdapter(" + this.get$name() + ")";
    }
  };
  A.__BlobAdapter_SembastTypeAdapter__TypeAdapterCodecMixin.prototype = {};
  A.__TimestampAdapter_SembastTypeAdapter__TypeAdapterCodecMixin.prototype = {};
  A.cloneValue_closure.prototype = {
    call$2(key, value) {
      return new A.MapEntry(A._asString(key), A.cloneValueOrNull(value), type$.MapEntry_of_String_and_nullable_Object);
    },
    $signature: 25
  };
  A.cloneValue_closure0.prototype = {
    call$1(value) {
      return A.cloneValueOrNull(value);
    },
    $signature: 6
  };
  A.cloneValueOrNull_closure.prototype = {
    call$2(key, value) {
      return new A.MapEntry(A._asString(key), A.cloneValueOrNull(value), type$.MapEntry_of_String_and_nullable_Object);
    },
    $signature: 25
  };
  A.cloneValueOrNull_closure0.prototype = {
    call$1(value) {
      return A.cloneValueOrNull(value);
    },
    $signature: 6
  };
  A._smartMatchPartsAnyValue_matchItem.prototype = {
    call$1(item) {
      var t1 = this.parts,
        t2 = this.match;
      if (t1.get$isEmpty(t1))
        return t2.call$1(item);
      else
        return A._smartMatchPartsAnyValue(item, t1.get$first(t1), t1.skip$1(0, 1), t2);
    },
    $signature: 3
  };
  A.BasicLock.prototype = {
    synchronized$1$2$timeout(func, timeout, $T) {
      return this.synchronized$body$BasicLock($T._eval$1("0/()")._as(func), timeout, $T, $T);
    },
    synchronized$1$1(func, $T) {
      func.toString;
      return this.synchronized$1$2$timeout(func, null, $T);
    },
    synchronized$body$BasicLock(func, timeout, $T, $async$type) {
      var $async$goto = 0,
        $async$completer = A._makeAsyncAwaitCompleter($async$type),
        $async$returnValue, $async$handler = 2, $async$errorStack = [], $async$next = [], $async$self = this, result, complete, t1, prev, completer;
      var $async$synchronized$1$2$timeout = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1) {
          $async$errorStack.push($async$result);
          $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              prev = $async$self.last;
              completer = new A._SyncCompleter(new A._Future($.Zone__current, type$._Future_void), type$._SyncCompleter_void);
              $async$self.last = completer.future;
              $async$handler = 3;
              $async$goto = prev != null ? 6 : 7;
              break;
            case 6:
              // then
              $async$goto = 8;
              return A._asyncAwait(prev, $async$synchronized$1$2$timeout);
            case 8:
              // returning from await.
            case 7:
              // join
              result = func.call$0();
              $async$goto = result instanceof A._Future ? 9 : 11;
              break;
            case 9:
              // then
              t1 = result;
              $async$goto = 12;
              return A._asyncAwait($T._eval$1("Future<0>")._is(t1) ? t1 : A._Future$value($T._as(t1), $T), $async$synchronized$1$2$timeout);
            case 12:
              // returning from await.
              t1 = $async$result;
              $async$returnValue = t1;
              $async$next = [1];
              // goto finally
              $async$goto = 4;
              break;
              // goto join
              $async$goto = 10;
              break;
            case 11:
              // else
              $async$returnValue = result;
              $async$next = [1];
              // goto finally
              $async$goto = 4;
              break;
            case 10:
              // join
              $async$next.push(5);
              // goto finally
              $async$goto = 4;
              break;
            case 3:
              // uncaught
              $async$next = [2];
            case 4:
              // finally
              $async$handler = 2;
              complete = new A.BasicLock_synchronized_complete($async$self, completer);
              complete.call$0();
              // goto the next finally handler
              $async$goto = $async$next.pop();
              break;
            case 5:
              // after finally
            case 1:
              // return
              return A._asyncReturn($async$returnValue, $async$completer);
            case 2:
              // rethrow
              return A._asyncRethrow($async$errorStack.at(-1), $async$completer);
          }
      });
      return A._asyncStartSync($async$synchronized$1$2$timeout, $async$completer);
    },
    toString$0(_) {
      return "Lock[" + A.objectHashCode(this) + "]";
    },
    $isLock: 1
  };
  A.BasicLock_synchronized_complete.prototype = {
    call$0() {
      var t1 = this.$this,
        t2 = this.completer;
      if (t1.last === t2.future)
        t1.last = null;
      t2.complete$0();
    },
    $signature: 0
  };
  A.EventStreamProvider.prototype = {};
  A._EventStream.prototype = {
    listen$4$cancelOnError$onDone$onError(onData, cancelOnError, onDone, onError) {
      var t1 = this.$ti;
      t1._eval$1("~(1)?")._as(onData);
      type$.nullable_void_Function._as(onDone);
      return A._EventStreamSubscription$(this._target, this._eventType, onData, false, t1._precomputed1);
    }
  };
  A._EventStreamSubscription.prototype = {
    cancel$0() {
      var _this = this,
        emptyFuture = A.Future_Future$value(null, type$.void);
      if (_this._target == null)
        return emptyFuture;
      _this._unlisten$0();
      _this._streams$_onData = _this._target = null;
      return emptyFuture;
    },
    pause$0() {
      if (this._target == null)
        return;
      ++this._pauseCount;
      this._unlisten$0();
    },
    resume$0() {
      var _this = this;
      if (_this._target == null || _this._pauseCount <= 0)
        return;
      --_this._pauseCount;
      _this._tryResume$0();
    },
    _tryResume$0() {
      var _this = this,
        t1 = _this._streams$_onData;
      if (t1 != null && _this._pauseCount <= 0)
        _this._target.addEventListener(_this._eventType, t1, false);
    },
    _unlisten$0() {
      var t1 = this._streams$_onData;
      if (t1 != null)
        this._target.removeEventListener(this._eventType, t1, false);
    },
    $isStreamSubscription: 1
  };
  A._EventStreamSubscription_closure.prototype = {
    call$1(e) {
      return this.onData.call$1(type$.JSObject._as(e));
    },
    $signature: 20
  };
  A.setupEventListeners_handleAddStudent.prototype = {
    call$0() {
      var $async$goto = 0,
        $async$completer = A._makeAsyncAwaitCompleter(type$.void),
        $async$returnValue, $async$handler = 2, $async$errorStack = [], id, $name, major, age, student, error, ageText, exception, t1, t2, t3, idInput, nameInput, ageInput, majorInput, $async$exception;
      var $async$call$0 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1) {
          $async$errorStack.push($async$result);
          $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = init.G;
              t2 = type$.JSObject;
              t3 = type$.nullable_JSObject;
              idInput = t3._as(t2._as(t1.document).querySelector("#student-id"));
              nameInput = t3._as(t2._as(t1.document).querySelector("#student-name"));
              ageInput = t3._as(t2._as(t1.document).querySelector("#student-age"));
              majorInput = t3._as(t2._as(t1.document).querySelector("#student-major"));
              if (idInput == null || nameInput == null || ageInput == null || majorInput == null) {
                A.showOutput("\u274c Form elements not found");
                // goto return
                $async$goto = 1;
                break;
              }
              id = B.JSString_methods.trim$0(A._asString(idInput.value));
              $name = B.JSString_methods.trim$0(A._asString(nameInput.value));
              ageText = B.JSString_methods.trim$0(A._asString(ageInput.value));
              major = B.JSString_methods.trim$0(A._asString(majorInput.value));
              if (J.get$length$asx(id) === 0 || J.get$length$asx($name) === 0 || ageText.length === 0 || J.get$length$asx(major) === 0) {
                A.showOutput("\u274c Please fill in all fields to add a student");
                // goto return
                $async$goto = 1;
                break;
              }
              age = A.Primitives_parseInt(ageText, null);
              if (age == null || age <= 0) {
                A.showOutput("\u274c Please enter a valid age");
                // goto return
                $async$goto = 1;
                break;
              }
              $async$handler = 4;
              student = new A.Student(id, $name, age, major);
              $async$goto = 7;
              return A._asyncAwait(A.createStudent($.__database._readField$0(), student), $async$call$0);
            case 7:
              // returning from await.
              idInput = t3._as(t2._as(t1.document).querySelector("#student-id"));
              nameInput = t3._as(t2._as(t1.document).querySelector("#student-name"));
              ageInput = t3._as(t2._as(t1.document).querySelector("#student-age"));
              majorInput = t3._as(t2._as(t1.document).querySelector("#student-major"));
              if (idInput != null)
                idInput.value = "";
              if (nameInput != null)
                nameInput.value = "";
              if (ageInput != null)
                ageInput.value = "";
              if (majorInput != null)
                majorInput.value = "";
              A.showOutput("\u2705 Student " + student.name + " added successfully!");
              $async$goto = 8;
              return A._asyncAwait(A.showAllStudents(), $async$call$0);
            case 8:
              // returning from await.
              $async$handler = 2;
              // goto after finally
              $async$goto = 6;
              break;
            case 4:
              // catch
              $async$handler = 3;
              $async$exception = $async$errorStack.pop();
              error = A.unwrapException($async$exception);
              A.showOutput("\u274c Error adding student: " + A.S(error));
              // goto after finally
              $async$goto = 6;
              break;
            case 3:
              // uncaught
              // goto rethrow
              $async$goto = 2;
              break;
            case 6:
              // after finally
            case 1:
              // return
              return A._asyncReturn($async$returnValue, $async$completer);
            case 2:
              // rethrow
              return A._asyncRethrow($async$errorStack.at(-1), $async$completer);
          }
      });
      return A._asyncStartSync($async$call$0, $async$completer);
    },
    $signature: 0
  };
  A.setupEventListeners_handleGetAllStudents.prototype = {
    call$0() {
      var $async$goto = 0,
        $async$completer = A._makeAsyncAwaitCompleter(type$.void);
      var $async$call$0 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return A._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              A.print("\ud83d\udd04 Get All Students button clicked");
              $async$goto = 2;
              return A._asyncAwait(A.showAllStudents(), $async$call$0);
            case 2:
              // returning from await.
              // implicit return
              return A._asyncReturn(null, $async$completer);
          }
      });
      return A._asyncStartSync($async$call$0, $async$completer);
    },
    $signature: 0
  };
  A.setupEventListeners_handleGetStudent.prototype = {
    call$0() {
      var $async$goto = 0,
        $async$completer = A._makeAsyncAwaitCompleter(type$.void),
        $async$returnValue, $async$handler = 2, $async$errorStack = [], searchId, student, error, exception, searchInput, $async$exception;
      var $async$call$0 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1) {
          $async$errorStack.push($async$result);
          $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              searchInput = type$.nullable_JSObject._as(type$.JSObject._as(init.G.document).querySelector("#search-id"));
              if (searchInput == null) {
                A.showOutput("\u274c Search input not found");
                // goto return
                $async$goto = 1;
                break;
              }
              searchId = B.JSString_methods.trim$0(A._asString(searchInput.value));
              if (J.get$length$asx(searchId) === 0) {
                A.showOutput("\u274c Please enter a student ID to search");
                // goto return
                $async$goto = 1;
                break;
              }
              $async$handler = 4;
              $async$goto = 7;
              return A._asyncAwait(A.readStudent($.__database._readField$0(), searchId), $async$call$0);
            case 7:
              // returning from await.
              student = $async$result;
              if (student != null)
                A.showOutput("\ud83d\udccb STUDENT FOUND:\n\n\ud83c\udd94 ID: " + student.id + "\n\ud83d\udc64 Name: " + student.name + "\n\ud83d\udcc5 Age: " + student.age + " years old\n\ud83c\udf93 Major: " + student.major + "\n        ");
              else
                A.showOutput("\u274c No student found with ID: " + A.S(searchId));
              $async$handler = 2;
              // goto after finally
              $async$goto = 6;
              break;
            case 4:
              // catch
              $async$handler = 3;
              $async$exception = $async$errorStack.pop();
              error = A.unwrapException($async$exception);
              A.showOutput("\u274c Error searching for student: " + A.S(error));
              // goto after finally
              $async$goto = 6;
              break;
            case 3:
              // uncaught
              // goto rethrow
              $async$goto = 2;
              break;
            case 6:
              // after finally
              searchInput.value = "";
            case 1:
              // return
              return A._asyncReturn($async$returnValue, $async$completer);
            case 2:
              // rethrow
              return A._asyncRethrow($async$errorStack.at(-1), $async$completer);
          }
      });
      return A._asyncStartSync($async$call$0, $async$completer);
    },
    $signature: 0
  };
  A.setupEventListeners_handleUpdateStudent.prototype = {
    call$0() {
      var $async$goto = 0,
        $async$completer = A._makeAsyncAwaitCompleter(type$.void),
        $async$returnValue, $async$handler = 2, $async$errorStack = [], id, $name, major, age, success, error, ageText, t4, t5, t6, t7, exception, t1, t2, t3, idInput, nameInput, ageInput, majorInput, $async$exception;
      var $async$call$0 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1) {
          $async$errorStack.push($async$result);
          $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = init.G;
              t2 = type$.JSObject;
              t3 = type$.nullable_JSObject;
              idInput = t3._as(t2._as(t1.document).querySelector("#update-id"));
              nameInput = t3._as(t2._as(t1.document).querySelector("#update-name"));
              ageInput = t3._as(t2._as(t1.document).querySelector("#update-age"));
              majorInput = t3._as(t2._as(t1.document).querySelector("#update-major"));
              if (idInput == null || nameInput == null || ageInput == null || majorInput == null) {
                A.showOutput("\u274c Update form elements not found");
                // goto return
                $async$goto = 1;
                break;
              }
              id = B.JSString_methods.trim$0(A._asString(idInput.value));
              $name = B.JSString_methods.trim$0(A._asString(nameInput.value));
              ageText = B.JSString_methods.trim$0(A._asString(ageInput.value));
              major = B.JSString_methods.trim$0(A._asString(majorInput.value));
              if (J.get$length$asx(id) === 0) {
                A.showOutput("\u274c Please enter a student ID to update");
                // goto return
                $async$goto = 1;
                break;
              }
              age = null;
              if (ageText.length !== 0) {
                age = A.Primitives_parseInt(ageText, null);
                if (age == null || age <= 0) {
                  A.showOutput("\u274c Please enter a valid age");
                  // goto return
                  $async$goto = 1;
                  break;
                }
              }
              $async$handler = 4;
              t4 = $.__database._readField$0();
              t5 = J.get$length$asx($name) !== 0 ? $name : null;
              t6 = age;
              t7 = J.get$length$asx(major) !== 0 ? major : null;
              $async$goto = 7;
              return A._asyncAwait(A.updateStudent(t4, id, t6, t7, t5), $async$call$0);
            case 7:
              // returning from await.
              success = $async$result;
              $async$goto = success ? 8 : 9;
              break;
            case 8:
              // then
              idInput = t3._as(t2._as(t1.document).querySelector("#update-id"));
              nameInput = t3._as(t2._as(t1.document).querySelector("#update-name"));
              ageInput = t3._as(t2._as(t1.document).querySelector("#update-age"));
              majorInput = t3._as(t2._as(t1.document).querySelector("#update-major"));
              if (idInput != null)
                idInput.value = "";
              if (nameInput != null)
                nameInput.value = "";
              if (ageInput != null)
                ageInput.value = "";
              if (majorInput != null)
                majorInput.value = "";
              A.showOutput("\u2705 Student updated successfully!");
              $async$goto = 10;
              return A._asyncAwait(A.showAllStudents(), $async$call$0);
            case 10:
              // returning from await.
            case 9:
              // join
              $async$handler = 2;
              // goto after finally
              $async$goto = 6;
              break;
            case 4:
              // catch
              $async$handler = 3;
              $async$exception = $async$errorStack.pop();
              error = A.unwrapException($async$exception);
              A.showOutput("\u274c Error updating student: " + A.S(error));
              // goto after finally
              $async$goto = 6;
              break;
            case 3:
              // uncaught
              // goto rethrow
              $async$goto = 2;
              break;
            case 6:
              // after finally
            case 1:
              // return
              return A._asyncReturn($async$returnValue, $async$completer);
            case 2:
              // rethrow
              return A._asyncRethrow($async$errorStack.at(-1), $async$completer);
          }
      });
      return A._asyncStartSync($async$call$0, $async$completer);
    },
    $signature: 0
  };
  A.setupEventListeners_handleDeleteStudent.prototype = {
    call$0() {
      var $async$goto = 0,
        $async$completer = A._makeAsyncAwaitCompleter(type$.void),
        $async$returnValue, $async$handler = 2, $async$errorStack = [], deleteId, success, error, exception, deleteInput, $async$exception;
      var $async$call$0 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1) {
          $async$errorStack.push($async$result);
          $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              deleteInput = type$.nullable_JSObject._as(type$.JSObject._as(init.G.document).querySelector("#delete-id"));
              if (deleteInput == null) {
                A.showOutput("\u274c Delete input not found");
                // goto return
                $async$goto = 1;
                break;
              }
              deleteId = B.JSString_methods.trim$0(A._asString(deleteInput.value));
              if (J.get$length$asx(deleteId) === 0) {
                A.showOutput("\u274c Please enter a student ID to delete");
                // goto return
                $async$goto = 1;
                break;
              }
              $async$handler = 4;
              $async$goto = 7;
              return A._asyncAwait(A.deleteStudent($.__database._readField$0(), deleteId), $async$call$0);
            case 7:
              // returning from await.
              success = $async$result;
              $async$goto = success ? 8 : 9;
              break;
            case 8:
              // then
              deleteInput.value = "";
              A.showOutput("\u2705 Student deleted successfully!");
              $async$goto = 10;
              return A._asyncAwait(A.showAllStudents(), $async$call$0);
            case 10:
              // returning from await.
            case 9:
              // join
              $async$handler = 2;
              // goto after finally
              $async$goto = 6;
              break;
            case 4:
              // catch
              $async$handler = 3;
              $async$exception = $async$errorStack.pop();
              error = A.unwrapException($async$exception);
              A.showOutput("\u274c Error deleting student: " + A.S(error));
              // goto after finally
              $async$goto = 6;
              break;
            case 3:
              // uncaught
              // goto rethrow
              $async$goto = 2;
              break;
            case 6:
              // after finally
            case 1:
              // return
              return A._asyncReturn($async$returnValue, $async$completer);
            case 2:
              // rethrow
              return A._asyncRethrow($async$errorStack.at(-1), $async$completer);
          }
      });
      return A._asyncStartSync($async$call$0, $async$completer);
    },
    $signature: 0
  };
  A.setupEventListeners_handleClearAll.prototype = {
    call$0() {
      var $async$goto = 0,
        $async$completer = A._makeAsyncAwaitCompleter(type$.void),
        $async$handler = 1, $async$errorStack = [], error, exception, $async$exception;
      var $async$call$0 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1) {
          $async$errorStack.push($async$result);
          $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$goto = A._asBool(type$.JSObject._as(init.G.window).confirm("Are you sure you want to delete all students?")) ? 2 : 3;
              break;
            case 2:
              // then
              $async$handler = 5;
              $async$goto = 8;
              return A._asyncAwait(A.clearAllStudents($.__database._readField$0()), $async$call$0);
            case 8:
              // returning from await.
              A.showOutput("\u2705 All students cleared!");
              $async$goto = 9;
              return A._asyncAwait(A.showAllStudents(), $async$call$0);
            case 9:
              // returning from await.
              $async$handler = 1;
              // goto after finally
              $async$goto = 7;
              break;
            case 5:
              // catch
              $async$handler = 4;
              $async$exception = $async$errorStack.pop();
              error = A.unwrapException($async$exception);
              A.showOutput("\u274c Error clearing all students: " + A.S(error));
              // goto after finally
              $async$goto = 7;
              break;
            case 4:
              // uncaught
              // goto rethrow
              $async$goto = 1;
              break;
            case 7:
              // after finally
            case 3:
              // join
              // implicit return
              return A._asyncReturn(null, $async$completer);
            case 1:
              // rethrow
              return A._asyncRethrow($async$errorStack.at(-1), $async$completer);
          }
      });
      return A._asyncStartSync($async$call$0, $async$completer);
    },
    $signature: 0
  };
  A.Student.prototype = {
    toMap$0() {
      var _this = this;
      return A.LinkedHashMap_LinkedHashMap$_literal(["id", _this.id, "name", _this.name, "age", _this.age, "major", _this.major], type$.String, type$.dynamic);
    },
    toString$0(_) {
      var _this = this;
      return "Student{id: " + _this.id + ", name: " + _this.name + ", age: " + _this.age + ", major: " + _this.major + "}";
    }
  };
  A.initializeDatabase_closure.prototype = {
    call$1(e) {
      var _s8_ = "students",
        db = e.get$target().result;
      A.print("\ud83c\udfd7\ufe0f Creating database schema...");
      if (!J.contains$1$asx(db.get$objectStoreNames(), _s8_)) {
        db.createObjectStore$2$keyPath(_s8_, "id");
        A.print("\ud83c\udfd7\ufe0f Created object store: students");
      }
    },
    $signature: 79
  };
  (function aliases() {
    var _ = J.LegacyJavaScriptObject.prototype;
    _.super$LegacyJavaScriptObject$toString = _.toString$0;
    _ = A._HashMap.prototype;
    _.super$_HashMap$_containsKey = _._containsKey$1;
    _.super$_HashMap$_get = _._get$1;
    _.super$_HashMap$_set = _._set$2;
    _ = A._SplayTreeIterator.prototype;
    _.super$_SplayTreeIterator$moveNext = _.moveNext$0;
    _ = A.Object.prototype;
    _.super$Object$toString = _.toString$0;
    _ = A.SembastDatabaseFactoryMixin.prototype;
    _.super$SembastDatabaseFactoryMixin$openDatabaseWithOptions = _.openDatabaseWithOptions$2;
    _ = A.SembastEqualsFilter.prototype;
    _.super$SembastEqualsFilter$matchesRecord = _.matchesRecord$1;
    _ = A.SembastRecordMixin.prototype;
    _.super$SembastRecordMixin$value = _.set$value;
  })();
  (function installTearOffs() {
    var _static_2 = hunkHelpers._static_2,
      _static_0 = hunkHelpers._static_0,
      _static_1 = hunkHelpers._static_1,
      _static = hunkHelpers.installStaticTearOff,
      _instance_2_u = hunkHelpers._instance_2u,
      _instance_0_u = hunkHelpers._instance_0u,
      _instance_1_u = hunkHelpers._instance_1u,
      _instance = hunkHelpers.installInstanceTearOff;
    _static_2(J, "_interceptors_JSArray__compareAny$closure", "JSArray__compareAny", 26);
    _static_0(A, "_js_helper_Primitives_dateNow$closure", "Primitives_dateNow", 15);
    _static_1(A, "async__AsyncRun__scheduleImmediateJsOverride$closure", "_AsyncRun__scheduleImmediateJsOverride", 11);
    _static_1(A, "async__AsyncRun__scheduleImmediateWithSetImmediate$closure", "_AsyncRun__scheduleImmediateWithSetImmediate", 11);
    _static_1(A, "async__AsyncRun__scheduleImmediateWithTimer$closure", "_AsyncRun__scheduleImmediateWithTimer", 11);
    _static_0(A, "async___startMicrotaskLoop$closure", "_startMicrotaskLoop", 0);
    _static_2(A, "async___nullErrorHandler$closure", "_nullErrorHandler", 9);
    _static(A, "async___rootScheduleMicrotask$closure", 4, null, ["call$4"], ["_rootScheduleMicrotask"], 54, 0);
    _instance_2_u(A._Future.prototype, "get$_completeError", "_completeError$2", 9);
    var _;
    _instance_0_u(_ = A._ControllerSubscription.prototype, "get$_onPause", "_onPause$0", 0);
    _instance_0_u(_, "get$_onResume", "_onResume$0", 0);
    _instance_0_u(_ = A._BufferingStreamSubscription.prototype, "get$_onPause", "_onPause$0", 0);
    _instance_0_u(_, "get$_onResume", "_onResume$0", 0);
    _instance_1_u(_ = A._StreamIterator.prototype, "get$_onData", "_onData$1", 78);
    _instance_2_u(_, "get$_onError", "_onError$2", 9);
    _instance_0_u(_, "get$_onDone", "_onDone$0", 0);
    _static_2(A, "collection___defaultEquals$closure", "_defaultEquals", 12);
    _static_1(A, "collection___defaultHashCode$closure", "_defaultHashCode", 13);
    _instance(A._LinkedHashSet.prototype, "get$_newSimilarSet", 0, 0, null, ["call$1$0", "call$0"], ["_newSimilarSet$1$0", "_newSimilarSet$0"], 28, 0, 0);
    _static_1(A, "convert___defaultToEncodable$closure", "_defaultToEncodable", 6);
    _static_1(A, "core__identityHashCode$closure", "identityHashCode", 13);
    _static_2(A, "core__identical$closure", "identical", 12);
    _instance_2_u(_ = A.DeepCollectionEquality.prototype, "get$equals", "equals$2", 12);
    _instance_1_u(_, "get$hash", "hash$1", 13);
    _instance_1_u(_, "get$isValidKey", "isValidKey$1", 3);
    _instance_1_u(A._FinderData.prototype, "get$addRecord", "addRecord$1", 71);
    _static_2(A, "utils__compareKey$closure", "compareKey", 26);
  })();
  (function inheritance() {
    var _mixin = hunkHelpers.mixin,
      _inherit = hunkHelpers.inherit,
      _inheritMany = hunkHelpers.inheritMany;
    _inherit(A.Object, null);
    _inheritMany(A.Object, [A.JS_CONST, J.Interceptor, J.ArrayIterator, A.Iterable, A.CastIterator, A.MapBase, A.Closure, A.Error, A.SentinelValue, A.ListIterator, A.MappedIterator, A.WhereIterator, A.TakeIterator, A.SkipIterator, A.EmptyIterator, A.IndexedIterator, A.FixedLengthListMixin, A._Record, A.TypeErrorDecoder, A.NullThrownFromJavaScriptException, A.ExceptionAndStackTrace, A._StackTrace, A.LinkedHashMapCell, A.LinkedHashMapKeyIterator, A.LinkedHashMapValueIterator, A.JSSyntaxRegExp, A._MatchImplementation, A._Cell, A.Rti, A._FunctionParameters, A._Type, A._TimerImpl, A._AsyncAwaitCompleter, A.AsyncError, A._Completer, A._FutureListener, A._Future, A._AsyncCallbackEntry, A.Stream, A._StreamController, A._SyncStreamControllerDispatch, A._BufferingStreamSubscription, A._DelayedEvent, A._DelayedDone, A._PendingEvents, A._StreamIterator, A._ZoneFunction, A._Zone, A._HashMapKeyIterator, A.SetBase, A._LinkedHashSetCell, A._LinkedHashSetIterator, A.ListBase, A._MapBaseValueIterator, A._SplayTreeNode, A._SplayTree, A._SplayTreeIterator, A.Codec, A.Converter, A._Base64Encoder, A._Base64Decoder, A._JsonStringifier, A.DateTime, A.Duration, A.OutOfMemoryError, A.StackOverflowError, A._Exception, A.FormatException, A.MapEntry, A.Null, A._StringStackTrace, A.Stopwatch, A.StringBuffer, A._JSRandom, A.DefaultEquality, A.IterableEquality, A.ListEquality, A._UnorderedEquality, A._MapEntry, A.MapEquality, A.DeepCollectionEquality, A.ObjectStore, A.Request, A.IdbDatabaseBase, A.IdbVersionChangeEventBase, A.IdbFactoryBase, A.TransactionWithMetaMixin, A.IdbTransactionMeta, A.DatabaseWithMetaMixin, A.IdbDatabaseMeta, A.ObjectStoreWithMetaMixin, A.IdbObjectStoreMeta, A.IdbCursorMeta, A.IdbIndexMeta, A._IdbTransactionBase_Object_IdbTransactionMixin, A.IdbTransactionMixin, A.IdbCursor, A.DatabaseException0, A.KeyCursorSembastMixin, A.CursorWithValueSembastMixin, A._StoreCursorWithValueSembast_Object_KeyCursorSembastMixin, A.RecordSnapshotSembast, A.StoreCursorControllerSembastMixin, A.BaseCursorControllerSembastMixin, A.CursorWithValueControllerSembastMixin, A._StoreCursorWithValueControllerSembast_Object_CursorWithValueControllerSembastMixin, A.DatabaseMode, A.DatabaseException, A.SortOrder, A.Blob, A.DatabaseChangesListener, A.Cooperator, A.StoreContent, A.DatabaseContent, A.SembastDatabaseFactory, A.SembastDatabaseFactoryMixin, A.CommitEntries, A.SembastDatabaseMixin, A._SembastDatabase_Object_SembastDatabaseMixin, A.DatabaseExportStat, A.JdbImportResult, A.DatabaseOpenHelper, A.DatabaseOpenOptions, A.SembastFilterBase, A.FilterAnyInListMixin, A.FilterValueMixin, A.FilterFieldMixin, A._FilterSmartMatchMixin, A.SembastFinder, A.DatabaseListener, A.StorageBase, A.Meta, A.SembastRecordHelperMixin, A.SembastRecordMixin, A._ImmutableSembastRecord_Object_SembastRecordMixin, A._TxnRecord_Object_SembastRecordHelperMixin, A.RecordRefMixin, A._SembastRecordRef_Object_RecordRefMixin, A.RecordSnapshotMixin, A._SembastRecordSnapshot_Object_RecordSnapshotMixin, A.SembastRecordRawSnapshot, A.RecordsRefMixin, A._SembastRecordsRef_Object_RecordsRefMixin, A.Sort, A.SembastSortOrderBase, A.SembastStore, A._FinderData, A._SembastStoreRef_Object_StoreRefMixin, A.StoreRefMixin, A.StoreFactoryMixin, A._StoreFactoryBase_Object_StoreFactoryMixin, A.Timestamp, A.SembastTransaction, A.SembastTransactionStore, A._TypeAdapterCodecMixin, A.BasicLock, A.EventStreamProvider, A._EventStreamSubscription, A.Student]);
    _inheritMany(J.Interceptor, [J.JSBool, J.JSNull, J.JavaScriptObject, J.JavaScriptBigInt, J.JavaScriptSymbol, J.JSNumber, J.JSString]);
    _inheritMany(J.JavaScriptObject, [J.LegacyJavaScriptObject, J.JSArray, A.NativeByteBuffer, A.NativeTypedData]);
    _inheritMany(J.LegacyJavaScriptObject, [J.PlainJavaScriptObject, J.UnknownJavaScriptObject, J.JavaScriptFunction]);
    _inherit(J.JSUnmodifiableArray, J.JSArray);
    _inheritMany(J.JSNumber, [J.JSInt, J.JSNumNotInt]);
    _inheritMany(A.Iterable, [A._CastIterableBase, A.EfficientLengthIterable, A.MappedIterable, A.WhereIterable, A.TakeIterable, A.SkipIterable, A.IndexedIterable]);
    _inheritMany(A._CastIterableBase, [A.CastIterable, A.__CastListBase__CastIterableBase_ListMixin, A.CastSet]);
    _inherit(A._EfficientLengthCastIterable, A.CastIterable);
    _inherit(A._CastListBase, A.__CastListBase__CastIterableBase_ListMixin);
    _inherit(A.CastList, A._CastListBase);
    _inheritMany(A.MapBase, [A.CastMap, A.JsLinkedHashMap, A._HashMap, A.ImmutableMap]);
    _inheritMany(A.Closure, [A.Closure2Args, A.Closure0Args, A.TearOffClosure, A.initHooks_closure, A.initHooks_closure1, A._AsyncRun__initializeScheduleImmediate_internalCallback, A._AsyncRun__initializeScheduleImmediate_closure, A._awaitOnObject_closure, A.Future_wait_closure, A._Future__propagateToListeners_handleWhenCompleteCallback_closure, A.Stream_length_closure, A._RootZone_bindUnaryCallbackGuarded_closure, A._HashMap_values_closure, A._CustomHashMap_closure, A.DateTime_parse_parseIntOrZero, A.DateTime_parse_parseMilliAndMicroseconds, A.jsify__convert, A.IdbValueMapExt_getKeyValue_closure, A.DOMStringListExt_toStringIterable_closure, A.IDBRequestExt_handleOnError_closure, A.IDBRequestExt_handleOnSuccess_closure, A.IDBRequestExt_dartFutureNullable_closure, A.IDBRequestExt_dartFuture_closure, A.IDBDartifyExtension_dartifyStringOrStringList_closure, A.IdbFactoryNativeWrapperImpl_open_closure, A.IdbFactoryNativeWrapperImpl_deleteDatabase_closure, A.cursorWithValueStreamFromResult_closure, A.cursorWithValueStreamFromResult_closure0, A.TransactionNative__completer__closure, A.TransactionNative__completer__closure0, A.TransactionNative__completer__closure1, A.TransactionNative_completed_closure, A.BaseCursorControllerSembastMixin_setRecords_closure, A.DatabaseSembast__loadStoresMeta_closure, A.DatabaseSembast__loadStoresMeta_closure0, A.DatabaseSembast__loadStoresMeta__closure, A.DatabaseSembast__readMetaVersion_closure, A.DatabaseSembast__readMetaVersion__closure, A.DatabaseSembast__readMetaVersion___closure, A.DatabaseSembast_open_closure, A.DatabaseSembast_open_closure1, A.keyFilter_closure, A.ObjectStoreSembast_putImpl_closure, A.ObjectStoreSembast_putImpl_closure0, A.ObjectStoreSembast_putImpl__closure, A.ObjectStoreSembast_clear_closure0, A.TransactionSembast__execute_closure, A.TransactionSembast__next_closure, A.TransactionSembast_execute_sembastAction_closure, A.TransactionSembast_execute_sembastAction_closure1, A.TransactionSembast__enqueue_closure, A.TransactionSembast_closure, A.TransactionSembast__completed_closure, A.Cooperator_cooperate_closure, A.TxnDatabaseContent_addTxnStoreRecords_closure, A.SembastDatabase_txnCompact_addStringLine, A.SembastDatabase_txnCompact_addLine, A.SembastDatabase_open__handleVersionChanged_closure, A.SembastDatabase_inTransaction_closure, A._FilterSmartMatchMixin_smartMatchesRecord_matchValue, A.SembastEqualsFilter_matchesRecord_match, A.SembastRecordRefExtension_add_closure, A.SembastRecordRefExtension_put_closure, A.SembastRecordRefExtension_delete_closure, A.SembastStore_txnCurrentRecords_closure, A.SembastStore_txnFindKeys_closure, A.SembastStoreRefExtensionPrv_immutableRecordIterableToSnapshots_closure, A.SembastStoreRefExtension_drop_closure, A.SembastStoreRefExtension_generateIntKey_closure, A.SembastStoreRefExtension_delete_closure, A._TimestampAdapter_closure, A._TimestampAdapter_closure0, A._BlobAdapter_closure, A._BlobAdapter_closure0, A.cloneValue_closure0, A.cloneValueOrNull_closure0, A._smartMatchPartsAnyValue_matchItem, A._EventStreamSubscription_closure, A.initializeDatabase_closure]);
    _inheritMany(A.Closure2Args, [A.CastMap_forEach_closure, A.initHooks_closure0, A._awaitOnObject_closure0, A._wrapJsFunctionForAsync_closure, A.Future_wait_handleError, A._Future__propagateToListeners_handleWhenCompleteCallback_closure0, A.LinkedHashMap_LinkedHashMap$from_closure, A.MapBase_mapToString_closure, A._JsonStringifier_writeMap_closure, A.IdbObjectStoreMeta_toMap_closure, A._cloneMap_closure, A.IDBJsifyExtension_jsifyValueStrict_closure, A.TransactionSembast__execute_closure0, A._toSembastValue_closure, A._fromSembastValue_closure, A.SembastDatabase_open_closure_handleVersionChanged, A._toJsonEncodable_closure, A.SembastStore_forEachRecords_finderMatchesRecord, A.SembastStore_forEachRecordsSync_finderMatchesRecord, A.SembastStore_txnFindRecords_closure, A.SembastStore_txnFindRecordsSync_closure, A.cloneValue_closure, A.cloneValueOrNull_closure]);
    _inheritMany(A.Error, [A.LateError, A.TypeError, A.JsNoSuchMethodError, A.UnknownJsTypeError, A.RuntimeError, A._Error, A.JsonUnsupportedObjectError, A.AssertionError, A.ArgumentError, A.UnsupportedError, A.UnimplementedError, A.StateError, A.ConcurrentModificationError, A.DatabaseError]);
    _inheritMany(A.Closure0Args, [A.nullFuture_closure, A.Primitives_initTicker_closure, A._AsyncRun__scheduleImmediateJsOverride_internalCallback, A._AsyncRun__scheduleImmediateWithSetImmediate_internalCallback, A._TimerImpl_internalCallback, A.Future_Future$delayed_closure, A._Future__addListener_closure, A._Future__prependListeners_closure, A._Future__chainCoreFuture_closure, A._Future__asyncCompleteWithValue_closure, A._Future__asyncCompleteErrorObject_closure, A._Future__propagateToListeners_handleWhenCompleteCallback, A._Future__propagateToListeners_handleValueCallback, A._Future__propagateToListeners_handleError, A.Stream_length_closure0, A._StreamController__subscribe_closure, A._StreamController__recordCancel_complete, A._BufferingStreamSubscription__sendError_sendError, A._BufferingStreamSubscription__sendDone_sendDone, A._PendingEvents_schedule_closure, A._rootHandleError_closure, A._RootZone_bindCallback_closure, A._RootZone_bindCallbackGuarded_closure, A.DatabaseNative_createObjectStore_closure, A.DatabaseNative_transaction_closure, A.DatabaseNative_objectStoreNames_closure, A.DatabaseNative_name_closure, A.ObjectStoreNative_getObject_closure, A.ObjectStoreNative_clear_closure, A.ObjectStoreNative_put_closure, A.ObjectStoreNative_delete_closure, A.TransactionNative__completer_closure, A.TransactionNative_objectStore_closure, A.DatabaseSembast_open_closure0, A.ObjectStoreSembast_clear_closure, A.ObjectStoreSembast_delete_closure, A.ObjectStoreSembast_getObject_closure, A.ObjectStoreSembast_openCursor_closure, A.ObjectStoreSembast_put_closure, A.TransactionSembast__next_checkNextAction, A.TransactionSembast_execute_sembastAction, A.TransactionSembast_execute_sembastAction_closure0, A.Blob_operator$eq_closure, A.SembastDatabaseFactoryMixin_deleteDatabase_closure, A.SembastDatabase_txnCompact_writeCurrent, A.SembastDatabase_commitInMemory_saveInMemory, A.SembastDatabase_flush_closure, A.SembastDatabase_open_closure, A.SembastDatabase_open_closure_openDone, A.SembastDatabase_open_closure_findOrCreate, A.SembastDatabase_close_closure, A.SembastDatabase_databaseOperation_closure, A.SembastDatabase__runTransaction_closure, A.SembastDatabase__runTransaction_closure0, A.SembastDatabase__runTransaction_closure_transactionCleanUp, A.SembastDatabase__runTransaction__closure, A.SembastDatabase__runTransaction_closure_postTransaction, A.SembastDatabase__runTransaction_closure1, A.DatabaseOpenHelper_openDatabase_closure, A.BasicLock_synchronized_complete, A.setupEventListeners_handleAddStudent, A.setupEventListeners_handleGetAllStudents, A.setupEventListeners_handleGetStudent, A.setupEventListeners_handleUpdateStudent, A.setupEventListeners_handleDeleteStudent, A.setupEventListeners_handleClearAll]);
    _inheritMany(A.EfficientLengthIterable, [A.ListIterable, A.EmptyIterable, A.LinkedHashMapKeysIterable, A.LinkedHashMapValuesIterable, A._HashMapKeyIterable, A._MapBaseValueIterable, A._SplayTreeKeyIterable, A._SplayTreeValueIterable]);
    _inheritMany(A.ListIterable, [A.SubListIterable, A.MappedListIterable, A._GeneratorIterable]);
    _inherit(A.EfficientLengthMappedIterable, A.MappedIterable);
    _inherit(A.EfficientLengthTakeIterable, A.TakeIterable);
    _inherit(A.EfficientLengthSkipIterable, A.SkipIterable);
    _inherit(A.EfficientLengthIndexedIterable, A.IndexedIterable);
    _inherit(A._Record2, A._Record);
    _inherit(A._Record_2, A._Record2);
    _inherit(A.NullError, A.TypeError);
    _inheritMany(A.TearOffClosure, [A.StaticClosure, A.BoundClosure]);
    _inheritMany(A.NativeTypedData, [A.NativeByteData, A.NativeTypedArray]);
    _inheritMany(A.NativeTypedArray, [A._NativeTypedArrayOfDouble_NativeTypedArray_ListMixin, A._NativeTypedArrayOfInt_NativeTypedArray_ListMixin]);
    _inherit(A._NativeTypedArrayOfDouble_NativeTypedArray_ListMixin_FixedLengthListMixin, A._NativeTypedArrayOfDouble_NativeTypedArray_ListMixin);
    _inherit(A.NativeTypedArrayOfDouble, A._NativeTypedArrayOfDouble_NativeTypedArray_ListMixin_FixedLengthListMixin);
    _inherit(A._NativeTypedArrayOfInt_NativeTypedArray_ListMixin_FixedLengthListMixin, A._NativeTypedArrayOfInt_NativeTypedArray_ListMixin);
    _inherit(A.NativeTypedArrayOfInt, A._NativeTypedArrayOfInt_NativeTypedArray_ListMixin_FixedLengthListMixin);
    _inheritMany(A.NativeTypedArrayOfDouble, [A.NativeFloat32List, A.NativeFloat64List]);
    _inheritMany(A.NativeTypedArrayOfInt, [A.NativeInt16List, A.NativeInt32List, A.NativeInt8List, A.NativeUint16List, A.NativeUint32List, A.NativeUint8ClampedList, A.NativeUint8List]);
    _inherit(A._TypeError, A._Error);
    _inheritMany(A._Completer, [A._AsyncCompleter, A._SyncCompleter]);
    _inherit(A._SyncStreamController, A._StreamController);
    _inheritMany(A.Stream, [A._StreamImpl, A._EventStream]);
    _inherit(A._ControllerStream, A._StreamImpl);
    _inherit(A._ControllerSubscription, A._BufferingStreamSubscription);
    _inheritMany(A._DelayedEvent, [A._DelayedData, A._DelayedError]);
    _inherit(A._RootZone, A._Zone);
    _inheritMany(A._HashMap, [A._IdentityHashMap, A._CustomHashMap]);
    _inherit(A._SetBase, A.SetBase);
    _inherit(A._LinkedHashSet, A._SetBase);
    _inherit(A._SplayTreeMapNode, A._SplayTreeNode);
    _inherit(A._SplayTreeMap__SplayTree_MapMixin, A._SplayTree);
    _inherit(A.SplayTreeMap, A._SplayTreeMap__SplayTree_MapMixin);
    _inheritMany(A._SplayTreeIterator, [A._SplayTreeKeyIterator, A._SplayTreeValueIterator, A._SplayTreeMapEntryIterator]);
    _inheritMany(A.Codec, [A.Base64Codec, A.JsonCodec, A.JsonEncodableCodec, A.SembastTypeAdapter]);
    _inheritMany(A.Converter, [A.Base64Encoder, A.Base64Decoder, A.JsonEncoder, A.JsonEncodableEncoder, A.JsonEncodableDecoder, A._Converter]);
    _inherit(A.JsonCyclicError, A.JsonUnsupportedObjectError);
    _inherit(A._JsonStringStringifier, A._JsonStringifier);
    _inheritMany(A.ArgumentError, [A.RangeError, A.IndexError]);
    _inherit(A.SetEquality, A._UnorderedEquality);
    _inherit(A.OpenDBRequest, A.Request);
    _inheritMany(A.DatabaseError, [A.DatabaseReadOnlyError, A.DatabaseStoreNotFoundError, A.DatabaseTransactionStoreNotFoundError, A.DatabaseErrorNative]);
    _inherit(A.IdbVersionChangeTransactionMeta, A.IdbTransactionMeta);
    _inherit(A.IdbTransactionBase, A._IdbTransactionBase_Object_IdbTransactionMixin);
    _inherit(A.IdbCursorWithValue, A.IdbCursor);
    _inherit(A.CursorWithValueNative, A.IdbCursorWithValue);
    _inheritMany(A.IdbVersionChangeEventBase, [A.VersionChangeEventNative, A._SembastVersionChangeEvent]);
    _inheritMany(A.IdbDatabaseBase, [A.DatabaseNative, A._DatabaseSembast_IdbDatabaseBase_DatabaseWithMetaMixin]);
    _inheritMany(A.IdbFactoryBase, [A.IdbFactoryNativeWrapperImpl, A.IdbFactorySembastImpl]);
    _inherit(A.IdbFactoryNativeBrowserWrapperImpl, A.IdbFactoryNativeWrapperImpl);
    _inheritMany(A.ObjectStore, [A.ObjectStoreNative, A._ObjectStoreSembast_ObjectStore_ObjectStoreWithMetaMixin]);
    _inheritMany(A.IdbTransactionBase, [A.TransactionNativeBase, A._TransactionSembast_IdbTransactionBase_TransactionWithMetaMixin]);
    _inherit(A.TransactionNative, A.TransactionNativeBase);
    _inherit(A._StoreCursorWithValueSembast_Object_KeyCursorSembastMixin_CursorWithValueSembastMixin, A._StoreCursorWithValueSembast_Object_KeyCursorSembastMixin);
    _inherit(A.StoreCursorWithValueSembast, A._StoreCursorWithValueSembast_Object_KeyCursorSembastMixin_CursorWithValueSembastMixin);
    _inherit(A._StoreCursorWithValueControllerSembast_Object_CursorWithValueControllerSembastMixin_BaseCursorControllerSembastMixin, A._StoreCursorWithValueControllerSembast_Object_CursorWithValueControllerSembastMixin);
    _inherit(A._StoreCursorWithValueControllerSembast_Object_CursorWithValueControllerSembastMixin_BaseCursorControllerSembastMixin_StoreCursorControllerSembastMixin, A._StoreCursorWithValueControllerSembast_Object_CursorWithValueControllerSembastMixin_BaseCursorControllerSembastMixin);
    _inherit(A.StoreCursorWithValueControllerSembast, A._StoreCursorWithValueControllerSembast_Object_CursorWithValueControllerSembastMixin_BaseCursorControllerSembastMixin_StoreCursorControllerSembastMixin);
    _inherit(A.DatabaseSembast, A._DatabaseSembast_IdbDatabaseBase_DatabaseWithMetaMixin);
    _inherit(A.ObjectStoreSembast, A._ObjectStoreSembast_ObjectStore_ObjectStoreWithMetaMixin);
    _inherit(A.TransactionSembast, A._TransactionSembast_IdbTransactionBase_TransactionWithMetaMixin);
    _inheritMany(A.DatabaseContent, [A.DatabaseListenerContent, A.TxnDatabaseContent]);
    _inherit(A.CommitData, A.CommitEntries);
    _inherit(A.SembastDatabase, A._SembastDatabase_Object_SembastDatabaseMixin);
    _inheritMany(A.SembastFilterBase, [A.SembastCustomFilter, A._SembastEqualsFilter_SembastFilterBase_FilterAnyInListMixin, A.SembastCompositeFilter]);
    _inherit(A._SembastEqualsFilter_SembastFilterBase_FilterAnyInListMixin_FilterValueMixin, A._SembastEqualsFilter_SembastFilterBase_FilterAnyInListMixin);
    _inherit(A._SembastEqualsFilter_SembastFilterBase_FilterAnyInListMixin_FilterValueMixin_FilterFieldMixin, A._SembastEqualsFilter_SembastFilterBase_FilterAnyInListMixin_FilterValueMixin);
    _inherit(A._SembastEqualsFilter_SembastFilterBase_FilterAnyInListMixin_FilterValueMixin_FilterFieldMixin__FilterSmartMatchMixin, A._SembastEqualsFilter_SembastFilterBase_FilterAnyInListMixin_FilterValueMixin_FilterFieldMixin);
    _inherit(A.SembastEqualsFilter, A._SembastEqualsFilter_SembastFilterBase_FilterAnyInListMixin_FilterValueMixin_FilterFieldMixin__FilterSmartMatchMixin);
    _inherit(A.SembastNotEqualsFilter, A.SembastEqualsFilter);
    _inherit(A.ImmutableList, A.ListBase);
    _inherit(A._DatabaseFactoryMemory_SembastDatabaseFactory_SembastDatabaseFactoryMixin, A.SembastDatabaseFactory);
    _inherit(A.DatabaseFactoryMemory, A._DatabaseFactoryMemory_SembastDatabaseFactory_SembastDatabaseFactoryMixin);
    _inherit(A.DatabaseStorage, A.StorageBase);
    _inherit(A.DatabaseStorageMemory, A.DatabaseStorage);
    _inherit(A._ImmutableSembastRecord_Object_SembastRecordMixin_SembastRecordHelperMixin, A._ImmutableSembastRecord_Object_SembastRecordMixin);
    _inherit(A._ImmutableSembastRecord_Object_SembastRecordMixin_SembastRecordHelperMixin_RecordSnapshotMixin, A._ImmutableSembastRecord_Object_SembastRecordMixin_SembastRecordHelperMixin);
    _inherit(A.ImmutableSembastRecord, A._ImmutableSembastRecord_Object_SembastRecordMixin_SembastRecordHelperMixin_RecordSnapshotMixin);
    _inherit(A.ImmutableSembastRecordJdb, A.ImmutableSembastRecord);
    _inherit(A.TxnRecord, A._TxnRecord_Object_SembastRecordHelperMixin);
    _inherit(A.SembastRecordRef, A._SembastRecordRef_Object_RecordRefMixin);
    _inherit(A.SembastRecordSnapshot, A._SembastRecordSnapshot_Object_RecordSnapshotMixin);
    _inherit(A.SembastRecordsRef, A._SembastRecordsRef_Object_RecordsRefMixin);
    _inherit(A.SembastSortOrder, A.SembastSortOrderBase);
    _inherit(A.SembastStoreRef, A._SembastStoreRef_Object_StoreRefMixin);
    _inherit(A.StoreFactoryBase, A._StoreFactoryBase_Object_StoreFactoryMixin);
    _inheritMany(A.SembastTypeAdapter, [A.__TimestampAdapter_SembastTypeAdapter__TypeAdapterCodecMixin, A.__BlobAdapter_SembastTypeAdapter__TypeAdapterCodecMixin]);
    _inherit(A._TimestampAdapter, A.__TimestampAdapter_SembastTypeAdapter__TypeAdapterCodecMixin);
    _inherit(A._BlobAdapter, A.__BlobAdapter_SembastTypeAdapter__TypeAdapterCodecMixin);
    _mixin(A.__CastListBase__CastIterableBase_ListMixin, A.ListBase);
    _mixin(A._NativeTypedArrayOfDouble_NativeTypedArray_ListMixin, A.ListBase);
    _mixin(A._NativeTypedArrayOfDouble_NativeTypedArray_ListMixin_FixedLengthListMixin, A.FixedLengthListMixin);
    _mixin(A._NativeTypedArrayOfInt_NativeTypedArray_ListMixin, A.ListBase);
    _mixin(A._NativeTypedArrayOfInt_NativeTypedArray_ListMixin_FixedLengthListMixin, A.FixedLengthListMixin);
    _mixin(A._SyncStreamController, A._SyncStreamControllerDispatch);
    _mixin(A._SplayTreeMap__SplayTree_MapMixin, A.MapBase);
    _mixin(A._IdbTransactionBase_Object_IdbTransactionMixin, A.IdbTransactionMixin);
    _mixin(A._StoreCursorWithValueControllerSembast_Object_CursorWithValueControllerSembastMixin, A.CursorWithValueControllerSembastMixin);
    _mixin(A._StoreCursorWithValueControllerSembast_Object_CursorWithValueControllerSembastMixin_BaseCursorControllerSembastMixin, A.BaseCursorControllerSembastMixin);
    _mixin(A._StoreCursorWithValueControllerSembast_Object_CursorWithValueControllerSembastMixin_BaseCursorControllerSembastMixin_StoreCursorControllerSembastMixin, A.StoreCursorControllerSembastMixin);
    _mixin(A._StoreCursorWithValueSembast_Object_KeyCursorSembastMixin, A.KeyCursorSembastMixin);
    _mixin(A._StoreCursorWithValueSembast_Object_KeyCursorSembastMixin_CursorWithValueSembastMixin, A.CursorWithValueSembastMixin);
    _mixin(A._DatabaseSembast_IdbDatabaseBase_DatabaseWithMetaMixin, A.DatabaseWithMetaMixin);
    _mixin(A._ObjectStoreSembast_ObjectStore_ObjectStoreWithMetaMixin, A.ObjectStoreWithMetaMixin);
    _mixin(A._TransactionSembast_IdbTransactionBase_TransactionWithMetaMixin, A.TransactionWithMetaMixin);
    _mixin(A._SembastDatabase_Object_SembastDatabaseMixin, A.SembastDatabaseMixin);
    _mixin(A._SembastEqualsFilter_SembastFilterBase_FilterAnyInListMixin, A.FilterAnyInListMixin);
    _mixin(A._SembastEqualsFilter_SembastFilterBase_FilterAnyInListMixin_FilterValueMixin, A.FilterValueMixin);
    _mixin(A._SembastEqualsFilter_SembastFilterBase_FilterAnyInListMixin_FilterValueMixin_FilterFieldMixin, A.FilterFieldMixin);
    _mixin(A._SembastEqualsFilter_SembastFilterBase_FilterAnyInListMixin_FilterValueMixin_FilterFieldMixin__FilterSmartMatchMixin, A._FilterSmartMatchMixin);
    _mixin(A._DatabaseFactoryMemory_SembastDatabaseFactory_SembastDatabaseFactoryMixin, A.SembastDatabaseFactoryMixin);
    _mixin(A._ImmutableSembastRecord_Object_SembastRecordMixin, A.SembastRecordMixin);
    _mixin(A._ImmutableSembastRecord_Object_SembastRecordMixin_SembastRecordHelperMixin, A.SembastRecordHelperMixin);
    _mixin(A._ImmutableSembastRecord_Object_SembastRecordMixin_SembastRecordHelperMixin_RecordSnapshotMixin, A.RecordSnapshotMixin);
    _mixin(A._TxnRecord_Object_SembastRecordHelperMixin, A.SembastRecordHelperMixin);
    _mixin(A._SembastRecordRef_Object_RecordRefMixin, A.RecordRefMixin);
    _mixin(A._SembastRecordSnapshot_Object_RecordSnapshotMixin, A.RecordSnapshotMixin);
    _mixin(A._SembastRecordsRef_Object_RecordsRefMixin, A.RecordsRefMixin);
    _mixin(A._SembastStoreRef_Object_StoreRefMixin, A.StoreRefMixin);
    _mixin(A._StoreFactoryBase_Object_StoreFactoryMixin, A.StoreFactoryMixin);
    _mixin(A.__BlobAdapter_SembastTypeAdapter__TypeAdapterCodecMixin, A._TypeAdapterCodecMixin);
    _mixin(A.__TimestampAdapter_SembastTypeAdapter__TypeAdapterCodecMixin, A._TypeAdapterCodecMixin);
  })();
  var init = {
    G: typeof self != "undefined" ? self : globalThis,
    typeUniverse: {eC: new Map(), tR: {}, eT: {}, tPV: {}, sEA: []},
    mangledGlobalNames: {int: "int", double: "double", num: "num", String: "String", bool: "bool", Null: "Null", List: "List", Object: "Object", Map: "Map"},
    mangledNames: {},
    types: ["~()", "Future<@>()", "Null(JSObject)", "bool(Object?)", "~(@,@)", "Future<Object?>()", "@(@)", "Null(@)", "Null()", "~(Object,StackTrace)", "Future<Null>()", "~(~())", "bool(Object?,Object?)", "int(Object?)", "Future<~>()", "int()", "Null(Object,StackTrace)", "~(Object?,Object?)", "int(String?)", "ObjectStoreNative()", "~(JSObject)", "Future<Object>()", "ImmutableSembastRecord(TxnRecord)", "bool(Finder?,ImmutableSembastRecord)", "Future<int>(SembastTransaction)", "MapEntry<String,Object?>(@,@)", "int(@,@)", "TransactionNative()", "Set<0^>()<Object?>", "Iterable<String>()", "String()", "~(@)", "IdbFactoryNativeWrapperImpl(Object?)", "Null(@,StackTrace)", "~(int,@)", "Completer<Object?>()", "Database(@)", "RecordSnapshotSembast(RecordSnapshot<Object,Object>)", "~(String)", "List<IdbObjectStoreMeta>(List<RecordSnapshot<String,Object>?>)", "~(RecordSnapshot<String,Object>?)", "Future<int>(Transaction)", "Null(List<IdbObjectStoreMeta>)", "~(IdbObjectStoreMeta)", "Null(Database0,int,int)", "Object?(Object?)", "Future<Null>(Transaction)", "bool(RecordSnapshot<Object?,Object?>)", "Null(RecordSnapshot<Object,Object>?)", "Future<Object>(List<@>)", "Object(Object)", "Future<int>()", "Null(int)", "Null(~())", "~(Zone?,ZoneDelegate?,Zone,~())", "Future<@>(Transaction)", "Null(Object)", "Future<Null>(~)", "Future<Null>(@)", "bool()", "@(String)", "Future<@>(String)", "Future<@>(Map<@,@>)", "Future<@>(int?,int?)", "Future<Object?>(Transaction)", "Future<SembastDatabase>()", "Future<Object?>(SembastTransaction)", "int(IdbIndexMeta,IdbIndexMeta)", "int(SembastRecord,SembastRecord)", "int(ImmutableSembastRecord,ImmutableSembastRecord)", "Object?(SembastRecord)", "bool(ImmutableSembastRecord)", "Future<~>(SembastTransaction)", "String(int)", "String(Timestamp)", "Timestamp(String)", "String(Blob)", "Blob(String)", "~(Object?)", "Null(VersionChangeEvent)", "Object(Object?)", "@(@,String)", "Future<@>(@)"],
    interceptorsByTag: null,
    leafTags: null,
    arrayRti: Symbol("$ti"),
    rttc: {
      "2;": (t1, t2) => o => o instanceof A._Record_2 && t1._is(o._0) && t2._is(o._1)
    }
  };
  A._Universe_addRules(init.typeUniverse, JSON.parse('{"JavaScriptFunction":"LegacyJavaScriptObject","PlainJavaScriptObject":"LegacyJavaScriptObject","UnknownJavaScriptObject":"LegacyJavaScriptObject","JSArray":{"List":["1"],"EfficientLengthIterable":["1"],"JSObject":[],"Iterable":["1"]},"JSBool":{"bool":[],"TrustedGetRuntimeType":[]},"JSNull":{"Null":[],"TrustedGetRuntimeType":[]},"JavaScriptObject":{"JSObject":[]},"LegacyJavaScriptObject":{"JSObject":[]},"JSUnmodifiableArray":{"JSArray":["1"],"List":["1"],"EfficientLengthIterable":["1"],"JSObject":[],"Iterable":["1"]},"ArrayIterator":{"Iterator":["1"]},"JSNumber":{"double":[],"num":[],"Comparable":["num"]},"JSInt":{"double":[],"int":[],"num":[],"Comparable":["num"],"TrustedGetRuntimeType":[]},"JSNumNotInt":{"double":[],"num":[],"Comparable":["num"],"TrustedGetRuntimeType":[]},"JSString":{"String":[],"Comparable":["String"],"Pattern":[],"TrustedGetRuntimeType":[]},"_CastIterableBase":{"Iterable":["2"]},"CastIterator":{"Iterator":["2"]},"CastIterable":{"_CastIterableBase":["1","2"],"Iterable":["2"],"Iterable.E":"2"},"_EfficientLengthCastIterable":{"CastIterable":["1","2"],"_CastIterableBase":["1","2"],"EfficientLengthIterable":["2"],"Iterable":["2"],"Iterable.E":"2"},"_CastListBase":{"ListBase":["2"],"List":["2"],"_CastIterableBase":["1","2"],"EfficientLengthIterable":["2"],"Iterable":["2"]},"CastList":{"_CastListBase":["1","2"],"ListBase":["2"],"List":["2"],"_CastIterableBase":["1","2"],"EfficientLengthIterable":["2"],"Iterable":["2"],"ListBase.E":"2","Iterable.E":"2"},"CastSet":{"Set":["2"],"_CastIterableBase":["1","2"],"EfficientLengthIterable":["2"],"Iterable":["2"],"Iterable.E":"2"},"CastMap":{"MapBase":["3","4"],"Map":["3","4"],"MapBase.K":"3","MapBase.V":"4"},"LateError":{"Error":[]},"EfficientLengthIterable":{"Iterable":["1"]},"ListIterable":{"EfficientLengthIterable":["1"],"Iterable":["1"]},"SubListIterable":{"ListIterable":["1"],"EfficientLengthIterable":["1"],"Iterable":["1"],"Iterable.E":"1","ListIterable.E":"1"},"ListIterator":{"Iterator":["1"]},"MappedIterable":{"Iterable":["2"],"Iterable.E":"2"},"EfficientLengthMappedIterable":{"MappedIterable":["1","2"],"EfficientLengthIterable":["2"],"Iterable":["2"],"Iterable.E":"2"},"MappedIterator":{"Iterator":["2"]},"MappedListIterable":{"ListIterable":["2"],"EfficientLengthIterable":["2"],"Iterable":["2"],"Iterable.E":"2","ListIterable.E":"2"},"WhereIterable":{"Iterable":["1"],"Iterable.E":"1"},"WhereIterator":{"Iterator":["1"]},"TakeIterable":{"Iterable":["1"],"Iterable.E":"1"},"EfficientLengthTakeIterable":{"TakeIterable":["1"],"EfficientLengthIterable":["1"],"Iterable":["1"],"Iterable.E":"1"},"TakeIterator":{"Iterator":["1"]},"SkipIterable":{"Iterable":["1"],"Iterable.E":"1"},"EfficientLengthSkipIterable":{"SkipIterable":["1"],"EfficientLengthIterable":["1"],"Iterable":["1"],"Iterable.E":"1"},"SkipIterator":{"Iterator":["1"]},"EmptyIterable":{"EfficientLengthIterable":["1"],"Iterable":["1"],"Iterable.E":"1"},"EmptyIterator":{"Iterator":["1"]},"IndexedIterable":{"Iterable":["+(int,1)"],"Iterable.E":"+(int,1)"},"EfficientLengthIndexedIterable":{"IndexedIterable":["1"],"EfficientLengthIterable":["+(int,1)"],"Iterable":["+(int,1)"],"Iterable.E":"+(int,1)"},"IndexedIterator":{"Iterator":["+(int,1)"]},"_Record_2":{"_Record2":[],"_Record":[]},"NullError":{"TypeError":[],"Error":[]},"JsNoSuchMethodError":{"Error":[]},"UnknownJsTypeError":{"Error":[]},"NullThrownFromJavaScriptException":{"Exception":[]},"_StackTrace":{"StackTrace":[]},"Closure":{"Function":[]},"Closure0Args":{"Function":[]},"Closure2Args":{"Function":[]},"TearOffClosure":{"Function":[]},"StaticClosure":{"Function":[]},"BoundClosure":{"Function":[]},"RuntimeError":{"Error":[]},"JsLinkedHashMap":{"MapBase":["1","2"],"LinkedHashMap":["1","2"],"Map":["1","2"],"MapBase.K":"1","MapBase.V":"2"},"LinkedHashMapKeysIterable":{"EfficientLengthIterable":["1"],"Iterable":["1"],"Iterable.E":"1"},"LinkedHashMapKeyIterator":{"Iterator":["1"]},"LinkedHashMapValuesIterable":{"EfficientLengthIterable":["1"],"Iterable":["1"],"Iterable.E":"1"},"LinkedHashMapValueIterator":{"Iterator":["1"]},"_Record2":{"_Record":[]},"JSSyntaxRegExp":{"RegExp":[],"Pattern":[]},"NativeByteBuffer":{"JSObject":[],"ByteBuffer":[],"TrustedGetRuntimeType":[]},"NativeTypedData":{"JSObject":[]},"NativeByteData":{"ByteData":[],"JSObject":[],"TrustedGetRuntimeType":[]},"NativeTypedArray":{"JavaScriptIndexingBehavior":["1"],"JSObject":[]},"NativeTypedArrayOfDouble":{"ListBase":["double"],"List":["double"],"JavaScriptIndexingBehavior":["double"],"EfficientLengthIterable":["double"],"JSObject":[],"Iterable":["double"],"FixedLengthListMixin":["double"]},"NativeTypedArrayOfInt":{"ListBase":["int"],"List":["int"],"JavaScriptIndexingBehavior":["int"],"EfficientLengthIterable":["int"],"JSObject":[],"Iterable":["int"],"FixedLengthListMixin":["int"]},"NativeFloat32List":{"Float32List":[],"ListBase":["double"],"List":["double"],"JavaScriptIndexingBehavior":["double"],"EfficientLengthIterable":["double"],"JSObject":[],"Iterable":["double"],"FixedLengthListMixin":["double"],"TrustedGetRuntimeType":[],"ListBase.E":"double"},"NativeFloat64List":{"Float64List":[],"ListBase":["double"],"List":["double"],"JavaScriptIndexingBehavior":["double"],"EfficientLengthIterable":["double"],"JSObject":[],"Iterable":["double"],"FixedLengthListMixin":["double"],"TrustedGetRuntimeType":[],"ListBase.E":"double"},"NativeInt16List":{"Int16List":[],"ListBase":["int"],"List":["int"],"JavaScriptIndexingBehavior":["int"],"EfficientLengthIterable":["int"],"JSObject":[],"Iterable":["int"],"FixedLengthListMixin":["int"],"TrustedGetRuntimeType":[],"ListBase.E":"int"},"NativeInt32List":{"Int32List":[],"ListBase":["int"],"List":["int"],"JavaScriptIndexingBehavior":["int"],"EfficientLengthIterable":["int"],"JSObject":[],"Iterable":["int"],"FixedLengthListMixin":["int"],"TrustedGetRuntimeType":[],"ListBase.E":"int"},"NativeInt8List":{"Int8List":[],"ListBase":["int"],"List":["int"],"JavaScriptIndexingBehavior":["int"],"EfficientLengthIterable":["int"],"JSObject":[],"Iterable":["int"],"FixedLengthListMixin":["int"],"TrustedGetRuntimeType":[],"ListBase.E":"int"},"NativeUint16List":{"Uint16List":[],"ListBase":["int"],"List":["int"],"JavaScriptIndexingBehavior":["int"],"EfficientLengthIterable":["int"],"JSObject":[],"Iterable":["int"],"FixedLengthListMixin":["int"],"TrustedGetRuntimeType":[],"ListBase.E":"int"},"NativeUint32List":{"Uint32List":[],"ListBase":["int"],"List":["int"],"JavaScriptIndexingBehavior":["int"],"EfficientLengthIterable":["int"],"JSObject":[],"Iterable":["int"],"FixedLengthListMixin":["int"],"TrustedGetRuntimeType":[],"ListBase.E":"int"},"NativeUint8ClampedList":{"Uint8ClampedList":[],"ListBase":["int"],"List":["int"],"JavaScriptIndexingBehavior":["int"],"EfficientLengthIterable":["int"],"JSObject":[],"Iterable":["int"],"FixedLengthListMixin":["int"],"TrustedGetRuntimeType":[],"ListBase.E":"int"},"NativeUint8List":{"Uint8List":[],"ListBase":["int"],"List":["int"],"JavaScriptIndexingBehavior":["int"],"EfficientLengthIterable":["int"],"JSObject":[],"Iterable":["int"],"FixedLengthListMixin":["int"],"TrustedGetRuntimeType":[],"ListBase.E":"int"},"_Error":{"Error":[]},"_TypeError":{"TypeError":[],"Error":[]},"_AsyncAwaitCompleter":{"Completer":["1"]},"AsyncError":{"Error":[]},"_Completer":{"Completer":["1"]},"_AsyncCompleter":{"_Completer":["1"],"Completer":["1"]},"_SyncCompleter":{"_Completer":["1"],"Completer":["1"]},"_Future":{"Future":["1"]},"_StreamController":{"StreamController":["1"],"_StreamControllerLifecycle":["1"],"_EventDispatch":["1"]},"_SyncStreamController":{"_SyncStreamControllerDispatch":["1"],"_StreamController":["1"],"StreamController":["1"],"_StreamControllerLifecycle":["1"],"_EventDispatch":["1"]},"_ControllerStream":{"_StreamImpl":["1"],"Stream":["1"]},"_ControllerSubscription":{"_BufferingStreamSubscription":["1"],"StreamSubscription":["1"],"_EventDispatch":["1"]},"_BufferingStreamSubscription":{"StreamSubscription":["1"],"_EventDispatch":["1"]},"_StreamImpl":{"Stream":["1"]},"_DelayedData":{"_DelayedEvent":["1"]},"_DelayedError":{"_DelayedEvent":["@"]},"_DelayedDone":{"_DelayedEvent":["@"]},"_Zone":{"Zone":[]},"_RootZone":{"_Zone":[],"Zone":[]},"_SplayTreeMapNode":{"_SplayTreeNode":["1","_SplayTreeMapNode<1,2>"],"_SplayTreeNode.1":"_SplayTreeMapNode<1,2>","_SplayTreeNode.K":"1"},"_HashMap":{"MapBase":["1","2"],"Map":["1","2"],"MapBase.K":"1","MapBase.V":"2"},"_IdentityHashMap":{"_HashMap":["1","2"],"MapBase":["1","2"],"Map":["1","2"],"MapBase.K":"1","MapBase.V":"2"},"_CustomHashMap":{"_HashMap":["1","2"],"MapBase":["1","2"],"Map":["1","2"],"MapBase.K":"1","MapBase.V":"2"},"_HashMapKeyIterable":{"EfficientLengthIterable":["1"],"Iterable":["1"],"Iterable.E":"1"},"_HashMapKeyIterator":{"Iterator":["1"]},"_LinkedHashSet":{"_SetBase":["1"],"SetBase":["1"],"Set":["1"],"EfficientLengthIterable":["1"],"Iterable":["1"]},"_LinkedHashSetIterator":{"Iterator":["1"]},"ListBase":{"List":["1"],"EfficientLengthIterable":["1"],"Iterable":["1"]},"MapBase":{"Map":["1","2"]},"_MapBaseValueIterable":{"EfficientLengthIterable":["2"],"Iterable":["2"],"Iterable.E":"2"},"_MapBaseValueIterator":{"Iterator":["2"]},"SetBase":{"Set":["1"],"EfficientLengthIterable":["1"],"Iterable":["1"]},"_SetBase":{"SetBase":["1"],"Set":["1"],"EfficientLengthIterable":["1"],"Iterable":["1"]},"SplayTreeMap":{"MapBase":["1","2"],"_SplayTree":["1","_SplayTreeMapNode<1,2>"],"Map":["1","2"],"MapBase.K":"1","MapBase.V":"2","_SplayTree.K":"1","_SplayTree.1":"_SplayTreeMapNode<1,2>"},"_SplayTreeIterator":{"Iterator":["3"]},"_SplayTreeKeyIterable":{"EfficientLengthIterable":["1"],"Iterable":["1"],"Iterable.E":"1"},"_SplayTreeValueIterable":{"EfficientLengthIterable":["2"],"Iterable":["2"],"Iterable.E":"2"},"_SplayTreeKeyIterator":{"_SplayTreeIterator":["1","2","1"],"Iterator":["1"],"_SplayTreeIterator.K":"1","_SplayTreeIterator.T":"1","_SplayTreeIterator.1":"2"},"_SplayTreeValueIterator":{"_SplayTreeIterator":["1","_SplayTreeMapNode<1,2>","2"],"Iterator":["2"],"_SplayTreeIterator.K":"1","_SplayTreeIterator.T":"2","_SplayTreeIterator.1":"_SplayTreeMapNode<1,2>"},"_SplayTreeMapEntryIterator":{"_SplayTreeIterator":["1","_SplayTreeMapNode<1,2>","MapEntry<1,2>"],"Iterator":["MapEntry<1,2>"],"_SplayTreeIterator.K":"1","_SplayTreeIterator.T":"MapEntry<1,2>","_SplayTreeIterator.1":"_SplayTreeMapNode<1,2>"},"Base64Codec":{"Codec":["List<int>","String"],"Codec.S":"List<int>"},"Base64Encoder":{"Converter":["List<int>","String"]},"Base64Decoder":{"Converter":["String","List<int>"]},"JsonUnsupportedObjectError":{"Error":[]},"JsonCyclicError":{"Error":[]},"JsonCodec":{"Codec":["Object?","String"],"Codec.S":"Object?"},"JsonEncoder":{"Converter":["Object?","String"]},"DateTime":{"Comparable":["DateTime"]},"double":{"num":[],"Comparable":["num"]},"Duration":{"Comparable":["Duration"]},"int":{"num":[],"Comparable":["num"]},"List":{"EfficientLengthIterable":["1"],"Iterable":["1"]},"num":{"Comparable":["num"]},"Set":{"EfficientLengthIterable":["1"],"Iterable":["1"]},"String":{"Comparable":["String"],"Pattern":[]},"AssertionError":{"Error":[]},"TypeError":{"Error":[]},"ArgumentError":{"Error":[]},"RangeError":{"Error":[]},"IndexError":{"Error":[]},"UnsupportedError":{"Error":[]},"UnimplementedError":{"Error":[]},"StateError":{"Error":[]},"ConcurrentModificationError":{"Error":[]},"OutOfMemoryError":{"Error":[]},"StackOverflowError":{"Error":[]},"_Exception":{"Exception":[]},"FormatException":{"Exception":[]},"_GeneratorIterable":{"ListIterable":["1"],"EfficientLengthIterable":["1"],"Iterable":["1"],"Iterable.E":"1","ListIterable.E":"1"},"_StringStackTrace":{"StackTrace":[]},"StringBuffer":{"StringSink":[]},"DefaultEquality":{"Equality":["1"]},"IterableEquality":{"Equality":["Iterable<1>"]},"ListEquality":{"Equality":["List<1>"]},"_UnorderedEquality":{"Equality":["2"]},"SetEquality":{"_UnorderedEquality":["1","Set<1>"],"Equality":["Set<1>"],"_UnorderedEquality.E":"1","_UnorderedEquality.T":"Set<1>"},"MapEquality":{"Equality":["Map<1,2>"]},"DeepCollectionEquality":{"Equality":["@"]},"OpenDBRequest":{"Request":[]},"DatabaseError":{"Error":[]},"DatabaseReadOnlyError":{"Error":[]},"DatabaseStoreNotFoundError":{"Error":[]},"DatabaseTransactionStoreNotFoundError":{"Error":[]},"IdbDatabaseBase":{"Database":[]},"IdbVersionChangeEventBase":{"VersionChangeEvent":[]},"IdbFactoryBase":{"IdbFactory":[]},"IdbVersionChangeTransactionMeta":{"IdbTransactionMeta":[]},"IdbTransactionBase":{"Transaction0":[]},"IdbCursorWithValue":{"IdbCursor":[]},"DatabaseException0":{"Exception":[]},"CursorWithValueNative":{"IdbCursorWithValue":[],"IdbCursor":[]},"VersionChangeEventNative":{"VersionChangeEvent":[]},"DatabaseNative":{"Database":[]},"DatabaseErrorNative":{"Error":[]},"IdbFactoryNativeWrapperImpl":{"IdbFactory":[]},"IdbFactoryNativeBrowserWrapperImpl":{"IdbFactory":[]},"TransactionNativeBase":{"Transaction0":[]},"TransactionNative":{"Transaction0":[]},"StoreCursorWithValueSembast":{"IdbCursorWithValue":[],"IdbCursor":[]},"StoreCursorWithValueControllerSembast":{"BaseCursorControllerSembastMixin":["IdbCursorWithValue"],"BaseCursorControllerSembastMixin.T":"IdbCursorWithValue"},"_SembastVersionChangeEvent":{"VersionChangeEvent":[]},"DatabaseSembast":{"Database":[]},"IdbFactorySembastImpl":{"IdbFactorySembast":[],"IdbFactory":[]},"TransactionSembast":{"Transaction0":[]},"DatabaseException":{"Exception":[]},"Blob":{"Comparable":["Blob"]},"SembastDatabaseFactory":{"DatabaseFactory":[]},"SembastDatabase":{"Database0":[],"DatabaseClient":[]},"SembastFilterBase":{"Filter":[]},"SembastCustomFilter":{"Filter":[]},"SembastEqualsFilter":{"Filter":[]},"SembastNotEqualsFilter":{"Filter":[]},"SembastCompositeFilter":{"Filter":[]},"SembastFinder":{"Finder":[]},"ImmutableList":{"ListBase":["1"],"List":["1"],"EfficientLengthIterable":["1"],"Iterable":["1"],"ListBase.E":"1"},"ImmutableMap":{"MapBase":["1","2"],"Map":["1","2"],"MapBase.K":"1","MapBase.V":"2"},"JsonEncodableEncoder":{"Converter":["Object","Object"]},"JsonEncodableDecoder":{"Converter":["Object","Object"]},"JsonEncodableCodec":{"Codec":["Object","Object"],"Codec.S":"Object"},"DatabaseFactoryMemory":{"SembastDatabaseFactory":[],"DatabaseFactory":[]},"DatabaseStorageMemory":{"DatabaseStorage":[],"StorageBase":[]},"SembastRecord":{"RecordSnapshot":["Object?","Object?"]},"ImmutableSembastRecordJdb":{"ImmutableSembastRecord":[],"SembastRecord":[],"RecordSnapshotMixin":["Object?","Object?"],"RecordSnapshot":["Object?","Object?"],"RecordSnapshotMixin.V":"Object?","RecordSnapshotMixin.K":"Object?"},"ImmutableSembastRecord":{"SembastRecord":[],"RecordSnapshotMixin":["Object?","Object?"],"RecordSnapshot":["Object?","Object?"],"RecordSnapshotMixin.V":"Object?","RecordSnapshotMixin.K":"Object?"},"TxnRecord":{"SembastRecord":[],"RecordSnapshot":["Object?","Object?"]},"SembastRecordRef":{"RecordRefMixin":["1","2"],"RecordRef":["1","2"]},"SembastRecordSnapshot":{"RecordSnapshotMixin":["1","2"],"RecordSnapshot":["1","2"],"RecordSnapshotMixin.V":"2","RecordSnapshotMixin.K":"1"},"SembastRecordRawSnapshot":{"RecordSnapshot":["1","2"]},"SembastRecordsRef":{"RecordsRefMixin":["1","2"],"RecordsRef":["1","2"]},"SembastSortOrderBase":{"SortOrder":["1"]},"SembastSortOrder":{"SortOrder":["1"]},"DatabaseStorage":{"StorageBase":[]},"SembastStoreRef":{"StoreRefMixin":["1","2"],"StoreRef":["1","2"]},"StoreFactoryBase":{"StoreFactoryMixin":["1","2"]},"Timestamp":{"Comparable":["Timestamp"]},"SembastTransaction":{"Transaction":[],"DatabaseClient":[]},"SembastTypeAdapter":{"Codec":["1","2"]},"_Converter":{"Converter":["1","2"]},"_TimestampAdapter":{"_TypeAdapterCodecMixin":["Timestamp","String"],"SembastTypeAdapter":["Timestamp","String"],"Codec":["Timestamp","String"],"Codec.S":"Timestamp","_TypeAdapterCodecMixin.T":"String","_TypeAdapterCodecMixin.S":"Timestamp"},"_BlobAdapter":{"_TypeAdapterCodecMixin":["Blob","String"],"SembastTypeAdapter":["Blob","String"],"Codec":["Blob","String"],"Codec.S":"Blob","_TypeAdapterCodecMixin.T":"String","_TypeAdapterCodecMixin.S":"Blob"},"BasicLock":{"Lock":[]},"_EventStream":{"Stream":["1"]},"_EventStreamSubscription":{"StreamSubscription":["1"]},"Int8List":{"List":["int"],"EfficientLengthIterable":["int"],"Iterable":["int"]},"Uint8List":{"List":["int"],"EfficientLengthIterable":["int"],"Iterable":["int"]},"Uint8ClampedList":{"List":["int"],"EfficientLengthIterable":["int"],"Iterable":["int"]},"Int16List":{"List":["int"],"EfficientLengthIterable":["int"],"Iterable":["int"]},"Uint16List":{"List":["int"],"EfficientLengthIterable":["int"],"Iterable":["int"]},"Int32List":{"List":["int"],"EfficientLengthIterable":["int"],"Iterable":["int"]},"Uint32List":{"List":["int"],"EfficientLengthIterable":["int"],"Iterable":["int"]},"Float32List":{"List":["double"],"EfficientLengthIterable":["double"],"Iterable":["double"]},"Float64List":{"List":["double"],"EfficientLengthIterable":["double"],"Iterable":["double"]},"Database0":{"DatabaseClient":[]},"Transaction":{"DatabaseClient":[]},"JdbWriteEntry":{"JdbEntry":[]}}'));
  A._Universe_addErasedTypes(init.typeUniverse, JSON.parse('{"__CastListBase__CastIterableBase_ListMixin":2,"NativeTypedArray":1,"_DelayedEvent":1,"_SplayTreeMap__SplayTree_MapMixin":2,"_SembastRecordRef_Object_RecordRefMixin":2,"_SembastRecordSnapshot_Object_RecordSnapshotMixin":2,"_SembastRecordsRef_Object_RecordsRefMixin":2,"SembastSortOrderBase":1,"_SembastStoreRef_Object_StoreRefMixin":2,"_StoreFactoryBase_Object_StoreFactoryMixin":2}'));
  var string$ = {
    Error_: "Error handler must accept one Object or one Object and a StackTrace as arguments, and return a value of the returned future's type",
    Time_i: "Time including microseconds is outside valid range"
  };
  var type$ = (function rtii() {
    var findType = A.findType;
    return {
      AsyncCodec_of_nullable_Object_and_String: findType("AsyncCodec<Object?,String>"),
      AsyncError: findType("AsyncError"),
      Base64Codec: findType("Base64Codec"),
      BaseCursorControllerSembastMixin_IdbCursor: findType("BaseCursorControllerSembastMixin<IdbCursor>"),
      Blob: findType("Blob"),
      ByteBuffer: findType("ByteBuffer"),
      ByteData: findType("ByteData"),
      Comparable_dynamic: findType("Comparable<@>"),
      Database: findType("Database"),
      DatabaseSembast: findType("DatabaseSembast"),
      Database_2: findType("Database0"),
      DateTime: findType("DateTime"),
      Duration: findType("Duration"),
      EfficientLengthIterable_dynamic: findType("EfficientLengthIterable<@>"),
      Error: findType("Error"),
      Filter: findType("Filter"),
      Float32List: findType("Float32List"),
      Float64List: findType("Float64List"),
      Function: findType("Function"),
      Future_String: findType("Future<String>"),
      Future_nullable_Object_Function: findType("Future<Object?>()"),
      Future_nullable_String: findType("Future<String?>"),
      IdbCursorWithValue: findType("IdbCursorWithValue"),
      IdbFactory: findType("IdbFactory"),
      IdbFactorySembast: findType("IdbFactorySembast"),
      IdbIndexMeta: findType("IdbIndexMeta"),
      IdbObjectStoreMeta: findType("IdbObjectStoreMeta"),
      ImmutableList_nullable_Object: findType("ImmutableList<Object?>"),
      ImmutableMap_of_String_and_nullable_Object: findType("ImmutableMap<String,Object?>"),
      ImmutableSembastRecord: findType("ImmutableSembastRecord"),
      Int16List: findType("Int16List"),
      Int32List: findType("Int32List"),
      Int8List: findType("Int8List"),
      IterableEquality_dynamic: findType("IterableEquality<@>"),
      Iterable_ImmutableSembastRecord: findType("Iterable<ImmutableSembastRecord>"),
      Iterable_TxnRecord: findType("Iterable<TxnRecord>"),
      Iterable_dynamic: findType("Iterable<@>"),
      JSArray_Completer_dynamic: findType("JSArray<Completer<@>>"),
      JSArray_Function: findType("JSArray<Function>"),
      JSArray_Future_dynamic: findType("JSArray<Future<@>>"),
      JSArray_IdbIndexMeta: findType("JSArray<IdbIndexMeta>"),
      JSArray_IdbObjectStoreMeta: findType("JSArray<IdbObjectStoreMeta>"),
      JSArray_ImmutableSembastRecord: findType("JSArray<ImmutableSembastRecord>"),
      JSArray_ImmutableSembastRecordJdb: findType("JSArray<ImmutableSembastRecordJdb>"),
      JSArray_Map_dynamic_dynamic: findType("JSArray<Map<@,@>>"),
      JSArray_Map_of_String_and_nullable_Object: findType("JSArray<Map<String,Object?>>"),
      JSArray_SortOrder_nullable_Object: findType("JSArray<SortOrder<Object?>>"),
      JSArray_String: findType("JSArray<String>"),
      JSArray_Student: findType("JSArray<Student>"),
      JSArray_TxnRecord: findType("JSArray<TxnRecord>"),
      JSArray_dynamic: findType("JSArray<@>"),
      JSArray_int: findType("JSArray<int>"),
      JSArray_nullable_ImmutableSembastRecord: findType("JSArray<ImmutableSembastRecord?>"),
      JSArray_nullable_Object: findType("JSArray<Object?>"),
      JSArray_of_Future_nullable_Object_Function: findType("JSArray<Future<Object?>()>"),
      JSNull: findType("JSNull"),
      JSObject: findType("JSObject"),
      JavaScriptFunction: findType("JavaScriptFunction"),
      JavaScriptIndexingBehavior_dynamic: findType("JavaScriptIndexingBehavior<@>"),
      JdbImportResult: findType("JdbImportResult"),
      ListEquality_dynamic: findType("ListEquality<@>"),
      List_IdbIndexMeta: findType("List<IdbIndexMeta>"),
      List_IdbObjectStoreMeta: findType("List<IdbObjectStoreMeta>"),
      List_ImmutableSembastRecord: findType("List<ImmutableSembastRecord>"),
      List_RecordSnapshot_Object_Object: findType("List<RecordSnapshot<Object,Object>>"),
      List_String: findType("List<String>"),
      List_Student: findType("List<Student>"),
      List_TxnRecord: findType("List<TxnRecord>"),
      List_dynamic: findType("List<@>"),
      List_int: findType("List<int>"),
      List_nullable_ImmutableSembastRecord: findType("List<ImmutableSembastRecord?>"),
      List_nullable_Object: findType("List<Object?>"),
      List_nullable_RecordSnapshot_String_Object: findType("List<RecordSnapshot<String,Object>?>"),
      MapEntry_of_String_and_nullable_Object: findType("MapEntry<String,Object?>"),
      MapEquality_dynamic_dynamic: findType("MapEquality<@,@>"),
      Map_dynamic_dynamic: findType("Map<@,@>"),
      Map_of_String_and_nullable_Object: findType("Map<String,Object?>"),
      NativeByteBuffer: findType("NativeByteBuffer"),
      NativeUint8List: findType("NativeUint8List"),
      Null: findType("Null"),
      Object: findType("Object"),
      Record: findType("Record"),
      RecordSnapshotSembast: findType("RecordSnapshotSembast"),
      RecordSnapshot_Object_Object: findType("RecordSnapshot<Object,Object>"),
      Record_0: findType("+()"),
      SembastDatabase: findType("SembastDatabase"),
      SembastRecord: findType("SembastRecord"),
      SembastRecordRawSnapshot_of_nullable_Object_and_nullable_Object: findType("SembastRecordRawSnapshot<Object?,Object?>"),
      SembastSortOrder_nullable_Object: findType("SembastSortOrder<Object?>"),
      SembastStore: findType("SembastStore"),
      SembastStoreRef_Object_Object: findType("SembastStoreRef<Object,Object>"),
      SembastTypeAdapter_dynamic_dynamic: findType("SembastTypeAdapter<@,@>"),
      SetEquality_dynamic: findType("SetEquality<@>"),
      Set_dynamic: findType("Set<@>"),
      SortOrder_nullable_Object: findType("SortOrder<Object?>"),
      SplayTreeMap_of_nullable_Object_and_ImmutableSembastRecord: findType("SplayTreeMap<Object?,ImmutableSembastRecord>"),
      StackTrace: findType("StackTrace"),
      StoreChangesListeners: findType("StoreChangesListeners"),
      StoreContent: findType("StoreContent"),
      StoreCursorWithValueControllerSembast: findType("StoreCursorWithValueControllerSembast"),
      StoreListener: findType("StoreListener"),
      StoreRef_of_nullable_Object_and_nullable_Object: findType("StoreRef<Object?,Object?>"),
      String: findType("String"),
      Timestamp: findType("Timestamp"),
      TrustedGetRuntimeType: findType("TrustedGetRuntimeType"),
      TxnRecord: findType("TxnRecord"),
      TypeError: findType("TypeError"),
      Uint16List: findType("Uint16List"),
      Uint32List: findType("Uint32List"),
      Uint8ClampedList: findType("Uint8ClampedList"),
      Uint8List: findType("Uint8List"),
      UnknownJavaScriptObject: findType("UnknownJavaScriptObject"),
      Zone: findType("Zone"),
      _AsyncCompleter_void: findType("_AsyncCompleter<~>"),
      _Converter_Blob_String: findType("_Converter<Blob,String>"),
      _Converter_String_Blob: findType("_Converter<String,Blob>"),
      _Converter_String_Timestamp: findType("_Converter<String,Timestamp>"),
      _Converter_Timestamp_String: findType("_Converter<Timestamp,String>"),
      _Future_Database: findType("_Future<Database>"),
      _Future_Object: findType("_Future<Object>"),
      _Future_String: findType("_Future<String>"),
      _Future_bool: findType("_Future<bool>"),
      _Future_dynamic: findType("_Future<@>"),
      _Future_int: findType("_Future<int>"),
      _Future_nullable_Object: findType("_Future<Object?>"),
      _Future_void: findType("_Future<~>"),
      _IdentityHashMap_of_nullable_Object_and_nullable_Object: findType("_IdentityHashMap<Object?,Object?>"),
      _MapEntry: findType("_MapEntry"),
      _StreamControllerAddStreamState_nullable_Object: findType("_StreamControllerAddStreamState<Object?>"),
      _StreamIterator_IdbCursorWithValue: findType("_StreamIterator<IdbCursorWithValue>"),
      _StreamIterator_JdbEntry: findType("_StreamIterator<JdbEntry>"),
      _SyncCompleter_Database: findType("_SyncCompleter<Database>"),
      _SyncCompleter_Object: findType("_SyncCompleter<Object>"),
      _SyncCompleter_nullable_Object: findType("_SyncCompleter<Object?>"),
      _SyncCompleter_void: findType("_SyncCompleter<~>"),
      bool: findType("bool"),
      bool_Function_ImmutableSembastRecord: findType("bool(ImmutableSembastRecord)"),
      bool_Function_Object: findType("bool(Object)"),
      bool_Function_nullable_Object: findType("bool(Object?)"),
      double: findType("double"),
      dynamic: findType("@"),
      dynamic_Function: findType("@()"),
      dynamic_Function_Object: findType("@(Object)"),
      dynamic_Function_Object_StackTrace: findType("@(Object,StackTrace)"),
      int: findType("int"),
      int_Function_ImmutableSembastRecord_ImmutableSembastRecord: findType("int(ImmutableSembastRecord,ImmutableSembastRecord)"),
      nullable_Database: findType("Database0?"),
      nullable_Future_Null: findType("Future<Null>?"),
      nullable_ImmutableSembastRecord: findType("ImmutableSembastRecord?"),
      nullable_Iterable_String: findType("Iterable<String>?"),
      nullable_JSObject: findType("JSObject?"),
      nullable_List_TxnRecord: findType("List<TxnRecord>?"),
      nullable_List_dynamic: findType("List<@>?"),
      nullable_Object: findType("Object?"),
      nullable_ObjectStore: findType("ObjectStore?"),
      nullable_RecordSnapshot_Object_Object: findType("RecordSnapshot<Object,Object>?"),
      nullable_RecordSnapshot_String_Object: findType("RecordSnapshot<String,Object>?"),
      nullable_SembastTransactionStore: findType("SembastTransactionStore?"),
      nullable_StackTrace: findType("StackTrace?"),
      nullable_String: findType("String?"),
      nullable_Student: findType("Student?"),
      nullable_TransactionNativeBase: findType("TransactionNativeBase?"),
      nullable_Zone: findType("Zone?"),
      nullable_ZoneDelegate: findType("ZoneDelegate?"),
      nullable__DelayedEvent_dynamic: findType("_DelayedEvent<@>?"),
      nullable__FutureListener_dynamic_dynamic: findType("_FutureListener<@,@>?"),
      nullable__LinkedHashSetCell: findType("_LinkedHashSetCell?"),
      nullable_bool: findType("bool?"),
      nullable_double: findType("double?"),
      nullable_dynamic_Function_Database_int_int: findType("@(Database0,int,int)?"),
      nullable_int: findType("int?"),
      nullable_num: findType("num?"),
      nullable_void_Function: findType("~()?"),
      nullable_void_Function_JSObject: findType("~(JSObject)?"),
      nullable_void_Function_VersionChangeEvent: findType("~(VersionChangeEvent)?"),
      num: findType("num"),
      void: findType("~"),
      void_Function: findType("~()"),
      void_Function_Object: findType("~(Object)"),
      void_Function_Object_StackTrace: findType("~(Object,StackTrace)")
    };
  })();
  (function constants() {
    B.Interceptor_methods = J.Interceptor.prototype;
    B.JSArray_methods = J.JSArray.prototype;
    B.JSInt_methods = J.JSInt.prototype;
    B.JSNumber_methods = J.JSNumber.prototype;
    B.JSString_methods = J.JSString.prototype;
    B.JavaScriptFunction_methods = J.JavaScriptFunction.prototype;
    B.JavaScriptObject_methods = J.JavaScriptObject.prototype;
    B.PlainJavaScriptObject_methods = J.PlainJavaScriptObject.prototype;
    B.UnknownJavaScriptObject_methods = J.UnknownJavaScriptObject.prototype;
    B.C_Base64Encoder = new A.Base64Encoder();
    B.C_Base64Codec = new A.Base64Codec();
    B.C_Base64Decoder = new A.Base64Decoder();
    B.C_DefaultEquality = new A.DefaultEquality(A.findType("DefaultEquality<0&>"));
    B.C_DeepCollectionEquality = new A.DeepCollectionEquality();
    B.C_EmptyIterator = new A.EmptyIterator(A.findType("EmptyIterator<0&>"));
    B.C_JS_CONST = function getTagFallback(o) {
  var s = Object.prototype.toString.call(o);
  return s.substring(8, s.length - 1);
};
    B.C_JS_CONST0 = function() {
  var toStringFunction = Object.prototype.toString;
  function getTag(o) {
    var s = toStringFunction.call(o);
    return s.substring(8, s.length - 1);
  }
  function getUnknownTag(object, tag) {
    if (/^HTML[A-Z].*Element$/.test(tag)) {
      var name = toStringFunction.call(object);
      if (name == "[object Object]") return null;
      return "HTMLElement";
    }
  }
  function getUnknownTagGenericBrowser(object, tag) {
    if (object instanceof HTMLElement) return "HTMLElement";
    return getUnknownTag(object, tag);
  }
  function prototypeForTag(tag) {
    if (typeof window == "undefined") return null;
    if (typeof window[tag] == "undefined") return null;
    var constructor = window[tag];
    if (typeof constructor != "function") return null;
    return constructor.prototype;
  }
  function discriminator(tag) { return null; }
  var isBrowser = typeof HTMLElement == "function";
  return {
    getTag: getTag,
    getUnknownTag: isBrowser ? getUnknownTagGenericBrowser : getUnknownTag,
    prototypeForTag: prototypeForTag,
    discriminator: discriminator };
};
    B.C_JS_CONST6 = function(getTagFallback) {
  return function(hooks) {
    if (typeof navigator != "object") return hooks;
    var userAgent = navigator.userAgent;
    if (typeof userAgent != "string") return hooks;
    if (userAgent.indexOf("DumpRenderTree") >= 0) return hooks;
    if (userAgent.indexOf("Chrome") >= 0) {
      function confirm(p) {
        return typeof window == "object" && window[p] && window[p].name == p;
      }
      if (confirm("Window") && confirm("HTMLElement")) return hooks;
    }
    hooks.getTag = getTagFallback;
  };
};
    B.C_JS_CONST1 = function(hooks) {
  if (typeof dartExperimentalFixupGetTag != "function") return hooks;
  hooks.getTag = dartExperimentalFixupGetTag(hooks.getTag);
};
    B.C_JS_CONST5 = function(hooks) {
  if (typeof navigator != "object") return hooks;
  var userAgent = navigator.userAgent;
  if (typeof userAgent != "string") return hooks;
  if (userAgent.indexOf("Firefox") == -1) return hooks;
  var getTag = hooks.getTag;
  var quickMap = {
    "BeforeUnloadEvent": "Event",
    "DataTransfer": "Clipboard",
    "GeoGeolocation": "Geolocation",
    "Location": "!Location",
    "WorkerMessageEvent": "MessageEvent",
    "XMLDocument": "!Document"};
  function getTagFirefox(o) {
    var tag = getTag(o);
    return quickMap[tag] || tag;
  }
  hooks.getTag = getTagFirefox;
};
    B.C_JS_CONST4 = function(hooks) {
  if (typeof navigator != "object") return hooks;
  var userAgent = navigator.userAgent;
  if (typeof userAgent != "string") return hooks;
  if (userAgent.indexOf("Trident/") == -1) return hooks;
  var getTag = hooks.getTag;
  var quickMap = {
    "BeforeUnloadEvent": "Event",
    "DataTransfer": "Clipboard",
    "HTMLDDElement": "HTMLElement",
    "HTMLDTElement": "HTMLElement",
    "HTMLPhraseElement": "HTMLElement",
    "Position": "Geoposition"
  };
  function getTagIE(o) {
    var tag = getTag(o);
    var newTag = quickMap[tag];
    if (newTag) return newTag;
    if (tag == "Object") {
      if (window.DataView && (o instanceof window.DataView)) return "DataView";
    }
    return tag;
  }
  function prototypeForTagIE(tag) {
    var constructor = window[tag];
    if (constructor == null) return null;
    return constructor.prototype;
  }
  hooks.getTag = getTagIE;
  hooks.prototypeForTag = prototypeForTagIE;
};
    B.C_JS_CONST2 = function(hooks) {
  var getTag = hooks.getTag;
  var prototypeForTag = hooks.prototypeForTag;
  function getTagFixed(o) {
    var tag = getTag(o);
    if (tag == "Document") {
      if (!!o.xmlVersion) return "!Document";
      return "!HTMLDocument";
    }
    return tag;
  }
  function prototypeForTagFixed(tag) {
    if (tag == "Document") return null;
    return prototypeForTag(tag);
  }
  hooks.getTag = getTagFixed;
  hooks.prototypeForTag = prototypeForTagFixed;
};
    B.C_JS_CONST3 = function(hooks) { return hooks; }
;
    B.C_JsonCodec = new A.JsonCodec();
    B.C_OutOfMemoryError = new A.OutOfMemoryError();
    B.C_SentinelValue = new A.SentinelValue();
    B.C__DelayedDone = new A._DelayedDone();
    B.C__JSRandom = new A._JSRandom();
    B.C__RootZone = new A._RootZone();
    B.C__StringStackTrace = new A._StringStackTrace();
    B.DatabaseMode_0 = new A.DatabaseMode(0);
    B.DatabaseMode_1 = new A.DatabaseMode(1);
    B.DatabaseMode_2 = new A.DatabaseMode(2);
    B.DatabaseMode_3 = new A.DatabaseMode(3);
    B.DatabaseMode_4 = new A.DatabaseMode(4);
    B.Duration_0 = new A.Duration(0);
    B.JsonEncoder_null = new A.JsonEncoder(null);
    B.Type_ByteBuffer_rqD = A.typeLiteral("ByteBuffer");
    B.Type_ByteData_9dB = A.typeLiteral("ByteData");
    B.Type_Float32List_9Kz = A.typeLiteral("Float32List");
    B.Type_Float64List_9Kz = A.typeLiteral("Float64List");
    B.Type_Int16List_s5h = A.typeLiteral("Int16List");
    B.Type_Int32List_O8Z = A.typeLiteral("Int32List");
    B.Type_Int8List_rFV = A.typeLiteral("Int8List");
    B.Type_JSObject_ttY = A.typeLiteral("JSObject");
    B.Type_Object_A4p = A.typeLiteral("Object");
    B.Type_String_AXU = A.typeLiteral("String");
    B.Type_Uint16List_kmP = A.typeLiteral("Uint16List");
    B.Type_Uint32List_kmP = A.typeLiteral("Uint32List");
    B.Type_Uint8ClampedList_04U = A.typeLiteral("Uint8ClampedList");
    B.Type_Uint8List_8Eb = A.typeLiteral("Uint8List");
    B.Type_int_T7V = A.typeLiteral("int");
    B._ZoneFunction__RootZone__rootScheduleMicrotask = new A._ZoneFunction(B.C__RootZone, A.async___rootScheduleMicrotask$closure(), A.findType("_ZoneFunction<~(Zone,ZoneDelegate,Zone,~())>"));
  })();
  (function staticFields() {
    $._JS_INTEROP_INTERCEPTOR_TAG = null;
    $.toStringVisiting = A._setArrayType([], A.findType("JSArray<Object>"));
    $.printToZone = null;
    $.Primitives__identityHashCodeProperty = null;
    $.Primitives_timerFrequency = 0;
    $.Primitives_timerTicks = A._js_helper_Primitives_dateNow$closure();
    $.BoundClosure__receiverFieldNameCache = null;
    $.BoundClosure__interceptorFieldNameCache = null;
    $.getTagFunction = null;
    $.alternateTagFunction = null;
    $.prototypeForTagFunction = null;
    $.dispatchRecordsForInstanceTags = null;
    $.interceptorsForUncacheableTags = null;
    $.initNativeDispatchFlag = null;
    $._Record__computedFieldKeys = A._setArrayType([], A.findType("JSArray<List<Object>?>"));
    $._nextCallback = null;
    $._lastCallback = null;
    $._lastPriorityCallback = null;
    $._isInCallbackLoop = false;
    $.Zone__current = B.C__RootZone;
    $._idbSembastMemoryFactoryImpl = null;
    $._isRelease = null;
    $.PushIdGenerator__lastPushTime = null;
    $.ImmutableSembastRecord__lastRevision = 0;
    $.__database = A._Cell$named("database");
  })();
  (function lazyInitializers() {
    var _lazyFinal = hunkHelpers.lazyFinal,
      _lazy = hunkHelpers.lazy;
    _lazyFinal($, "DART_CLOSURE_PROPERTY_NAME", "$get$DART_CLOSURE_PROPERTY_NAME", () => A.getIsolateAffinityTag("_$dart_dartClosure"));
    _lazyFinal($, "nullFuture", "$get$nullFuture", () => B.C__RootZone.run$1$1(new A.nullFuture_closure(), A.findType("Future<~>")));
    _lazyFinal($, "TypeErrorDecoder_noSuchMethodPattern", "$get$TypeErrorDecoder_noSuchMethodPattern", () => A.TypeErrorDecoder_extractPattern(A.TypeErrorDecoder_provokeCallErrorOn({
      toString: function() {
        return "$receiver$";
      }
    })));
    _lazyFinal($, "TypeErrorDecoder_notClosurePattern", "$get$TypeErrorDecoder_notClosurePattern", () => A.TypeErrorDecoder_extractPattern(A.TypeErrorDecoder_provokeCallErrorOn({$method$: null,
      toString: function() {
        return "$receiver$";
      }
    })));
    _lazyFinal($, "TypeErrorDecoder_nullCallPattern", "$get$TypeErrorDecoder_nullCallPattern", () => A.TypeErrorDecoder_extractPattern(A.TypeErrorDecoder_provokeCallErrorOn(null)));
    _lazyFinal($, "TypeErrorDecoder_nullLiteralCallPattern", "$get$TypeErrorDecoder_nullLiteralCallPattern", () => A.TypeErrorDecoder_extractPattern(function() {
      var $argumentsExpr$ = "$arguments$";
      try {
        null.$method$($argumentsExpr$);
      } catch (e) {
        return e.message;
      }
    }()));
    _lazyFinal($, "TypeErrorDecoder_undefinedCallPattern", "$get$TypeErrorDecoder_undefinedCallPattern", () => A.TypeErrorDecoder_extractPattern(A.TypeErrorDecoder_provokeCallErrorOn(void 0)));
    _lazyFinal($, "TypeErrorDecoder_undefinedLiteralCallPattern", "$get$TypeErrorDecoder_undefinedLiteralCallPattern", () => A.TypeErrorDecoder_extractPattern(function() {
      var $argumentsExpr$ = "$arguments$";
      try {
        (void 0).$method$($argumentsExpr$);
      } catch (e) {
        return e.message;
      }
    }()));
    _lazyFinal($, "TypeErrorDecoder_nullPropertyPattern", "$get$TypeErrorDecoder_nullPropertyPattern", () => A.TypeErrorDecoder_extractPattern(A.TypeErrorDecoder_provokePropertyErrorOn(null)));
    _lazyFinal($, "TypeErrorDecoder_nullLiteralPropertyPattern", "$get$TypeErrorDecoder_nullLiteralPropertyPattern", () => A.TypeErrorDecoder_extractPattern(function() {
      try {
        null.$method$;
      } catch (e) {
        return e.message;
      }
    }()));
    _lazyFinal($, "TypeErrorDecoder_undefinedPropertyPattern", "$get$TypeErrorDecoder_undefinedPropertyPattern", () => A.TypeErrorDecoder_extractPattern(A.TypeErrorDecoder_provokePropertyErrorOn(void 0)));
    _lazyFinal($, "TypeErrorDecoder_undefinedLiteralPropertyPattern", "$get$TypeErrorDecoder_undefinedLiteralPropertyPattern", () => A.TypeErrorDecoder_extractPattern(function() {
      try {
        (void 0).$method$;
      } catch (e) {
        return e.message;
      }
    }()));
    _lazyFinal($, "_AsyncRun__scheduleImmediateClosure", "$get$_AsyncRun__scheduleImmediateClosure", () => A._AsyncRun__initializeScheduleImmediate());
    _lazyFinal($, "Future__nullFuture", "$get$Future__nullFuture", () => $.$get$nullFuture());
    _lazyFinal($, "Future__falseFuture", "$get$Future__falseFuture", () => A._Future$zoneValue(false, B.C__RootZone, type$.bool));
    _lazyFinal($, "_Base64Decoder__inverseAlphabet", "$get$_Base64Decoder__inverseAlphabet", () => A.NativeInt8List__create1(A._ensureNativeList(A._setArrayType([-2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -1, -2, -2, -2, -2, -2, 62, -2, 62, -2, 63, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -2, -2, -2, -1, -2, -2, -2, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -2, -2, -2, -2, 63, -2, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, -2, -2, -2, -2, -2], type$.JSArray_int))));
    _lazy($, "_Base64Decoder__emptyBuffer", "$get$_Base64Decoder__emptyBuffer", () => A.NativeUint8List_NativeUint8List(0));
    _lazyFinal($, "DateTime__parseFormat", "$get$DateTime__parseFormat", () => A.RegExp_RegExp("^([+-]?\\d{4,6})-?(\\d\\d)-?(\\d\\d)(?:[ T](\\d\\d)(?::?(\\d\\d)(?::?(\\d\\d)(?:[.,](\\d+))?)?)?( ?[zZ]| ?([-+])(\\d\\d)(?::?(\\d\\d))?)?)?$"));
    _lazyFinal($, "_hashSeed", "$get$_hashSeed", () => A.objectHashCode(B.Type_Object_A4p));
    _lazyFinal($, "Stopwatch__frequency", "$get$Stopwatch__frequency", () => {
      A.Primitives_initTicker();
      return $.Primitives_timerFrequency;
    });
    _lazyFinal($, "idbFactoryBrowserWrapperImpl", "$get$idbFactoryBrowserWrapperImpl", () => {
      var t1 = type$.JSObject;
      t1 = A.getProperty(A.getProperty(A.staticInteropGlobalContext(), "window", t1), "indexedDB", t1);
      t1.toString;
      return new A.IdbFactoryNativeBrowserWrapperImpl(t1);
    });
    _lazyFinal($, "intMapStoreFactory", "$get$intMapStoreFactory", () => new A.StoreFactoryBase(A.findType("StoreFactoryBase<int,Map<String,Object?>>")));
    _lazyFinal($, "globalCooperator", "$get$globalCooperator", () => {
      var t1 = new A.Stopwatch();
      $.$get$Stopwatch__frequency();
      t1.start$0();
      return new A.Cooperator(t1);
    });
    _lazyFinal($, "sembastDefaultJsonEncodableCodec", "$get$sembastDefaultJsonEncodableCodec", () => {
      var t1 = new A.JsonEncodableCodec();
      t1._adapters = A.sembastTypeAdaptersToMap($.$get$sembastDefaultTypeAdapters());
      t1.__JsonEncodableCodec__decoder_A = new A.JsonEncodableDecoder(t1);
      t1.__JsonEncodableCodec__encoder_A = new A.JsonEncodableEncoder(t1);
      return t1;
    });
    _lazyFinal($, "PushIdGenerator__random", "$get$PushIdGenerator__random", () => B.C__JSRandom);
    _lazyFinal($, "PushIdGenerator__lastRandChars", "$get$PushIdGenerator__lastRandChars", () => A.List_List$filled(12, null, false, type$.nullable_int));
    _lazyFinal($, "databaseFactoryMemory", "$get$databaseFactoryMemory", () => {
      var t1 = type$.String;
      return new A.DatabaseFactoryMemory(A.LinkedHashMap_LinkedHashMap$_empty(t1, type$.bool), A.LinkedHashMap_LinkedHashMap$_empty(t1, type$.SembastDatabase), A.LinkedHashMap_LinkedHashMap$_empty(t1, A.findType("DatabaseOpenHelper")));
    });
    _lazy($, "mainStoreRef", "$get$mainStoreRef", () => {
      var t1 = type$.Object;
      return A.SembastStoreRef$("_main", t1, t1);
    });
    _lazyFinal($, "sembastTimestampAdapter", "$get$sembastTimestampAdapter", () => A._TimestampAdapter$());
    _lazyFinal($, "sembastBlobAdapter", "$get$sembastBlobAdapter", () => A._BlobAdapter$());
    _lazyFinal($, "sembastDefaultTypeAdapters", "$get$sembastDefaultTypeAdapters", () => A._setArrayType([$.$get$sembastTimestampAdapter(), $.$get$sembastBlobAdapter()], A.findType("JSArray<SembastTypeAdapter<Object,String>>")));
    _lazyFinal($, "backtickChrCode", "$get$backtickChrCode", () => 96);
  })();
  (function nativeSupport() {
    !function() {
      var intern = function(s) {
        var o = {};
        o[s] = 1;
        return Object.keys(hunkHelpers.convertToFastObject(o))[0];
      };
      init.getIsolateTag = function(name) {
        return intern("___dart_" + name + init.isolateTag);
      };
      var tableProperty = "___dart_isolate_tags_";
      var usedProperties = Object[tableProperty] || (Object[tableProperty] = Object.create(null));
      var rootProperty = "_ZxYxX";
      for (var i = 0;; i++) {
        var property = intern(rootProperty + "_" + i + "_");
        if (!(property in usedProperties)) {
          usedProperties[property] = 1;
          init.isolateTag = property;
          break;
        }
      }
      init.dispatchPropertyName = init.getIsolateTag("dispatch_record");
    }();
    hunkHelpers.setOrUpdateInterceptorsByTag({ArrayBuffer: A.NativeByteBuffer, ArrayBufferView: A.NativeTypedData, DataView: A.NativeByteData, Float32Array: A.NativeFloat32List, Float64Array: A.NativeFloat64List, Int16Array: A.NativeInt16List, Int32Array: A.NativeInt32List, Int8Array: A.NativeInt8List, Uint16Array: A.NativeUint16List, Uint32Array: A.NativeUint32List, Uint8ClampedArray: A.NativeUint8ClampedList, CanvasPixelArray: A.NativeUint8ClampedList, Uint8Array: A.NativeUint8List});
    hunkHelpers.setOrUpdateLeafTags({ArrayBuffer: true, ArrayBufferView: false, DataView: true, Float32Array: true, Float64Array: true, Int16Array: true, Int32Array: true, Int8Array: true, Uint16Array: true, Uint32Array: true, Uint8ClampedArray: true, CanvasPixelArray: true, Uint8Array: false});
    A.NativeTypedArray.$nativeSuperclassTag = "ArrayBufferView";
    A._NativeTypedArrayOfDouble_NativeTypedArray_ListMixin.$nativeSuperclassTag = "ArrayBufferView";
    A._NativeTypedArrayOfDouble_NativeTypedArray_ListMixin_FixedLengthListMixin.$nativeSuperclassTag = "ArrayBufferView";
    A.NativeTypedArrayOfDouble.$nativeSuperclassTag = "ArrayBufferView";
    A._NativeTypedArrayOfInt_NativeTypedArray_ListMixin.$nativeSuperclassTag = "ArrayBufferView";
    A._NativeTypedArrayOfInt_NativeTypedArray_ListMixin_FixedLengthListMixin.$nativeSuperclassTag = "ArrayBufferView";
    A.NativeTypedArrayOfInt.$nativeSuperclassTag = "ArrayBufferView";
  })();
  Function.prototype.call$0 = function() {
    return this();
  };
  Function.prototype.call$1 = function(a) {
    return this(a);
  };
  Function.prototype.call$2 = function(a, b) {
    return this(a, b);
  };
  Function.prototype.call$3$1 = function(a) {
    return this(a);
  };
  Function.prototype.call$2$1 = function(a) {
    return this(a);
  };
  Function.prototype.call$1$1 = function(a) {
    return this(a);
  };
  Function.prototype.call$3 = function(a, b, c) {
    return this(a, b, c);
  };
  Function.prototype.call$4 = function(a, b, c, d) {
    return this(a, b, c, d);
  };
  Function.prototype.call$3$3 = function(a, b, c) {
    return this(a, b, c);
  };
  Function.prototype.call$2$2 = function(a, b) {
    return this(a, b);
  };
  Function.prototype.call$2$0 = function() {
    return this();
  };
  Function.prototype.call$1$0 = function() {
    return this();
  };
  Function.prototype.call$1$2 = function(a, b) {
    return this(a, b);
  };
  Function.prototype.call$2$3 = function(a, b, c) {
    return this(a, b, c);
  };
  convertAllToFastObject(holders);
  convertToFastObject($);
  (function(callback) {
    if (typeof document === "undefined") {
      callback(null);
      return;
    }
    if (typeof document.currentScript != "undefined") {
      callback(document.currentScript);
      return;
    }
    var scripts = document.scripts;
    function onLoad(event) {
      for (var i = 0; i < scripts.length; ++i) {
        scripts[i].removeEventListener("load", onLoad, false);
      }
      callback(event.target);
    }
    for (var i = 0; i < scripts.length; ++i) {
      scripts[i].addEventListener("load", onLoad, false);
    }
  })(function(currentScript) {
    init.currentScript = currentScript;
    var callMain = A.main;
    if (typeof dartMainRunner === "function") {
      dartMainRunner(callMain, []);
    } else {
      callMain([]);
    }
  });
})();

//# sourceMappingURL=main.dart.js.map
