---
marp: true
---

# Q1. Provider State Management

---

## Question 1.1

Data that can change over time and affects the UI, such as user login status, shopping cart items, or counter values: what explains this concept?

---

**Answer:**


---

## Question 1.2

What is the main limitation of StatefulWidget when managing state in Flutter applications?

1. It's too complex to implement
2. State is trapped inside one widget and cannot be shared
3. It doesn't support setState() method
4. It requires external dependencies

---

**Answer:**


---

## Question 1.3

Which method must ALWAYS be called in a ChangeNotifier class when the state changes to notify all listeners?

---

**Answer:**


---

## Question 1.4

These are the three main components of the Provider package. Which one is wrong?

1. ChangeNotifierProvider - Creates and provides the model
2. Consumer - Listens and rebuilds when state changes
3. context.read() - Accesses model without listening
4. StateNotifier - Manages state transitions

---

**Answer:**


---

## Question 1.5

In the Provider pattern, what should you use for triggering actions (like button presses) that don't need to listen to state changes?

---

**Answer:**


---

## Question 1.6

These are benefits of using ChangeNotifier over StatefulWidget. Which one is wrong?

- Separation of concerns
- Reactive UI updates
- Shared state across widgets
- Automatic dependency injection
- Requires less boilerplate code
- Faster performance

---

**Answer:**


---

## Question 1.7

What is the correct way to set up a ChangeNotifier model for the entire app?

```dart
// Option A
void main() {
  runApp(
    Provider(
      create: (context) => CounterModel(),
      child: MyApp(),
    ),
  );
}

// Option B
void main() {
  runApp(
    ChangeNotifierProvider(
      create: (context) => CounterModel(),
      child: MyApp(),
    ),
  );
}
```

---

**Answer:**


---

## Question 1.8

Complete this ChangeNotifier class implementation:

```dart
class CounterModel extends ChangeNotifier {
  int _count = 0;
  
  int get count => _count;
  
  void increment() {
    _count++;
    // What should go here?
  }
}
```

---

**Answer:**


---

## Question 1.9

Which Consumer implementation is correct for displaying state data? (Hint: Consumer should only display data, not trigger actions)

```dart
// Option A
Consumer<CounterModel>(
  builder: (context, counterModel, child) {
    return Text('${counterModel.count}');
  },
)

// Option B
Consumer<CounterModel>(
  builder: (context, counterModel, child) {
    counterModel.increment();
    return Text('${counterModel.count}');
  },
)
```

---

**Answer:**


---

## Question 1.10

In the Provider workflow, what is the correct sequence when a user clicks a button?

1. Builder in Consumer is invoked → notifyListeners() is called → context.read() method is invoked
2. context.read() method is invoked → notifyListeners() is called → Builder in Consumer is invoked
3. notifyListeners() is called → context.read() method is invoked → Builder in Consumer is invoked

---

**Answer:**


---

## Question 1.11

Compare the Provider approach with the setState() approach. What is the main architectural advantage of using Provider?

---

**Answer:**


---

## Question 1.12

A student writes this code but the UI doesn't update when the button is pressed. What's the most likely problem?

```dart
class CounterModel extends ChangeNotifier {
  int _count = 0;
  int get count => _count;
  
  void increment() {
    _count++;
    // Missing something here?
  }
}
```

---

**Answer:**


---

## Summary

We have 12 questions on this page.

1. How many questions did you answer? ( / 12)
2. What percentage of questions did you answer? (  %)
3. List question numbers that you cannot answer:
4. (Optional) Explain why you could not answer these questions.
