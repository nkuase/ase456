---
marp: true
---

# Q2. MVVM Pattern in Flutter

---

## Question 1

Model-View-ViewModel is an architectural pattern that separates concerns. Using the restaurant analogy from the lecture, what does the ViewModel represent?

1. Kitchen (data preparation)
2. Dining room (customer experience)
3. Waiter (communication bridge)
4. Menu (available options)

---

**Answer:**


---

## Question 2

These are the three components of MVVM and their Flutter implementations. Which pairing is wrong?

| Component  | Flutter Implementation                      |
|------------|---------------------------------------------|
| Model      | Dart classes                                |
| View       | Widgets                                     |
| ViewModel  | ChangeNotifier + State Management(Provider) |
| Controller | StatefulWidget                              |

---

**Answer:**


---

## Question 3

Which scenario would NOT be appropriate for using MVVM pattern?

1. Complex business logic requirements
2. Need for extensive unit testing
3. Simple static content app
4. Large team development project

---

**Answer:**


---

## Question 4

(T/F) MVVM provides better separation of concerns and testability.
(T/F) The ViewModel exposes data/state to the View through bindings, while MVC has tighter coupling between Controller and View, making Controllers heavy and harder to test.

---

**Answer:**


---

## Question 5

What is the correct project structure for implementing MVVM in Flutter?

```txt
Option A:
📁 lib/
├── 📁 controllers/
├── 📁 models/
└── 📁 views/

Option B:
📁 lib/
├── 📁 models/
├── 📁 viewmodels/
├── 📁 views/
└── main.dart

Option C:
📁 lib/
├── 📁 data/
├── 📁 ui/
└── 📁 logic/
```

---

**Answer:**


---

## Question 6

Complete this Model class implementation following MVVM best practices:

```dart
class Todo {
  final String id;
  final String title;
  final bool isCompleted;

  Todo({required this.id, required this.title, this.isCompleted = false});

  // What method should be implemented here for immutable updates?
}
```

---

**Answer:**


---

## Question 7

This is a list of the essential characteristics that a ViewModel must have in Flutter MVVM implementation. Which is wrong?

- Extends ChangeNotifier for state management
- Contains ALL business logic
- No UI dependencies (pure business code)  
- Uses notifyListeners() to update UI
- Provides read-only access to data
- Contains ALL business logic

---

**Answer:**


---

## Question 8

When should you use Consumer vs context.read() in MVVM? Match each use case:

**Use Cases:**
A. Displaying todo count that changes (for displaying changing data)
B. Button click to add new todo (for triggering actions)
C. Showing completion statistics
D. Delete button action

**Methods:**

1. Consumer<T>
2. context.read<T>()

---

**Answer:**


---

## Question 9

Which implementation is correct for displaying data that updates automatically?

```dart
// Option A
Widget _buildStats() {
  return Consumer<TodoViewModel>(
    builder: (context, viewModel, child) {
      return Text('Total: ${viewModel.todos.length}');
    },
  );
}

// Option B  
Widget _buildStats() {
  final viewModel = context.read<TodoViewModel>();
  return Text('Total: ${viewModel.todos.length}');
}
```

---

**Answer:**


---

## Question 10

Using Consumer for actions only creates unnecessary rebuilds in this code. Explain the simple solution to this issue. (Hint: why context.read() solve this issue?)

```dart
Consumer<TodoViewModel>(
  builder: (context, viewModel, child) {
    return ElevatedButton(
      onPressed: () => viewModel.addTodo('Task'),
      child: Text('Add'),
    );
  },
)
```

---

**Answer:**


---

## Question 11

What is the correct sequence in the MVVM data flow when a user taps the "Add" button? (Hint: View is the start and rebuilding is the last)

1. Consumer rebuilds automatically → ViewModel updates _todos → View calls addTodo() → notifyListeners()
2. View calls addTodo() → ViewModel updates _todos → notifyListeners() → Consumer rebuilds automatically  
3. notifyListeners() → View calls addTodo() → ViewModel updates _todos → Consumer rebuilds automatically

---

**Answer:**


---

## Question 12

How should the ViewModel be set up in main.dart to wire MVVM components together?

```dart
// Option A
class MyApp extends StatelessWidget {
  Widget build(BuildContext context) {
    return MaterialApp(
      home: Provider(
        create: (context) => TodoViewModel(),
        child: TodoView(),
      ),
    );
  }
}

// Option B
class MyApp extends StatelessWidget {
  Widget build(BuildContext context) {
    return MaterialApp(
      home: ChangeNotifierProvider(
        create: (context) => TodoViewModel(),
        child: TodoView(),
      ),
    );
  }
}
```

---

**Answer:**


---

## Question 13

(T/F) MVVM separates business logic (ViewModel) from UI (View), allowing pure Dart unit tests without Flutter dependencies.
(T/F) You can test business logic independently by creating ViewModel instances and testing methods directly, as shown in the example test.

---

**Answer:**


---

## Question 14

A student implements a ViewModel but forgets one crucial method call. The UI doesn't update when data changes. What's missing?

```dart
class TodoViewModel extends ChangeNotifier {
  final List<Todo> _todos = [];
  
  void addTodo(String title) {
    final newTodo = Todo(id: '1', title: title);
    _todos.add(newTodo);
    // What's missing here?
  }
}
```

---

**Answer:**


---

## Question 15

Explain why Flutter apps benefit more from MVVM compared to MVC, specifically considering Flutter's event-driven nature.

---

**Answer:**


---

## Summary

We have 15 questions on this page.

1. How many questions did you answer? ( / 15)
2. What percentage of questions did you answer? (  %)
3. List question numbers that you cannot answer:
4. (Optional) Explain why you could not answer these questions.
